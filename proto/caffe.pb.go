// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: caffe.proto

package proto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Phase int32

const (
	Phase_TRAIN Phase = 0
	Phase_TEST  Phase = 1
)

var Phase_name = map[int32]string{
	0: "TRAIN",
	1: "TEST",
}
var Phase_value = map[string]int32{
	"TRAIN": 0,
	"TEST":  1,
}

func (x Phase) Enum() *Phase {
	p := new(Phase)
	*p = x
	return p
}
func (x Phase) String() string {
	return proto.EnumName(Phase_name, int32(x))
}
func (x *Phase) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Phase_value, data, "Phase")
	if err != nil {
		return err
	}
	*x = Phase(value)
	return nil
}
func (Phase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{0}
}

// Normalize the filler variance by fan_in, fan_out, or their average.
// Applies to 'xavier' and 'msra' fillers.
type FillerParameter_VarianceNorm int32

const (
	FillerParameter_FAN_IN  FillerParameter_VarianceNorm = 0
	FillerParameter_FAN_OUT FillerParameter_VarianceNorm = 1
	FillerParameter_AVERAGE FillerParameter_VarianceNorm = 2
)

var FillerParameter_VarianceNorm_name = map[int32]string{
	0: "FAN_IN",
	1: "FAN_OUT",
	2: "AVERAGE",
}
var FillerParameter_VarianceNorm_value = map[string]int32{
	"FAN_IN":  0,
	"FAN_OUT": 1,
	"AVERAGE": 2,
}

func (x FillerParameter_VarianceNorm) Enum() *FillerParameter_VarianceNorm {
	p := new(FillerParameter_VarianceNorm)
	*p = x
	return p
}
func (x FillerParameter_VarianceNorm) String() string {
	return proto.EnumName(FillerParameter_VarianceNorm_name, int32(x))
}
func (x *FillerParameter_VarianceNorm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FillerParameter_VarianceNorm_value, data, "FillerParameter_VarianceNorm")
	if err != nil {
		return err
	}
	*x = FillerParameter_VarianceNorm(value)
	return nil
}
func (FillerParameter_VarianceNorm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{4, 0}
}

type SolverParameter_SnapshotFormat int32

const (
	SolverParameter_HDF5        SolverParameter_SnapshotFormat = 0
	SolverParameter_BINARYPROTO SolverParameter_SnapshotFormat = 1
)

var SolverParameter_SnapshotFormat_name = map[int32]string{
	0: "HDF5",
	1: "BINARYPROTO",
}
var SolverParameter_SnapshotFormat_value = map[string]int32{
	"HDF5":        0,
	"BINARYPROTO": 1,
}

func (x SolverParameter_SnapshotFormat) Enum() *SolverParameter_SnapshotFormat {
	p := new(SolverParameter_SnapshotFormat)
	*p = x
	return p
}
func (x SolverParameter_SnapshotFormat) String() string {
	return proto.EnumName(SolverParameter_SnapshotFormat_name, int32(x))
}
func (x *SolverParameter_SnapshotFormat) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SolverParameter_SnapshotFormat_value, data, "SolverParameter_SnapshotFormat")
	if err != nil {
		return err
	}
	*x = SolverParameter_SnapshotFormat(value)
	return nil
}
func (SolverParameter_SnapshotFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{6, 0}
}

// the mode solver will use: 0 for CPU and 1 for GPU. Use GPU in default.
type SolverParameter_SolverMode int32

const (
	SolverParameter_CPU SolverParameter_SolverMode = 0
	SolverParameter_GPU SolverParameter_SolverMode = 1
)

var SolverParameter_SolverMode_name = map[int32]string{
	0: "CPU",
	1: "GPU",
}
var SolverParameter_SolverMode_value = map[string]int32{
	"CPU": 0,
	"GPU": 1,
}

func (x SolverParameter_SolverMode) Enum() *SolverParameter_SolverMode {
	p := new(SolverParameter_SolverMode)
	*p = x
	return p
}
func (x SolverParameter_SolverMode) String() string {
	return proto.EnumName(SolverParameter_SolverMode_name, int32(x))
}
func (x *SolverParameter_SolverMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SolverParameter_SolverMode_value, data, "SolverParameter_SolverMode")
	if err != nil {
		return err
	}
	*x = SolverParameter_SolverMode(value)
	return nil
}
func (SolverParameter_SolverMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{6, 1}
}

// DEPRECATED: old solver enum types, use string instead
type SolverParameter_SolverType int32

const (
	SolverParameter_SGD      SolverParameter_SolverType = 0
	SolverParameter_NESTEROV SolverParameter_SolverType = 1
	SolverParameter_ADAGRAD  SolverParameter_SolverType = 2
	SolverParameter_RMSPROP  SolverParameter_SolverType = 3
	SolverParameter_ADADELTA SolverParameter_SolverType = 4
	SolverParameter_ADAM     SolverParameter_SolverType = 5
)

var SolverParameter_SolverType_name = map[int32]string{
	0: "SGD",
	1: "NESTEROV",
	2: "ADAGRAD",
	3: "RMSPROP",
	4: "ADADELTA",
	5: "ADAM",
}
var SolverParameter_SolverType_value = map[string]int32{
	"SGD":      0,
	"NESTEROV": 1,
	"ADAGRAD":  2,
	"RMSPROP":  3,
	"ADADELTA": 4,
	"ADAM":     5,
}

func (x SolverParameter_SolverType) Enum() *SolverParameter_SolverType {
	p := new(SolverParameter_SolverType)
	*p = x
	return p
}
func (x SolverParameter_SolverType) String() string {
	return proto.EnumName(SolverParameter_SolverType_name, int32(x))
}
func (x *SolverParameter_SolverType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SolverParameter_SolverType_value, data, "SolverParameter_SolverType")
	if err != nil {
		return err
	}
	*x = SolverParameter_SolverType(value)
	return nil
}
func (SolverParameter_SolverType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{6, 2}
}

type ParamSpec_DimCheckMode int32

const (
	// STRICT (default) requires that num, channels, height, width each match.
	ParamSpec_STRICT ParamSpec_DimCheckMode = 0
	// PERMISSIVE requires only the count (num*channels*height*width) to match.
	ParamSpec_PERMISSIVE ParamSpec_DimCheckMode = 1
)

var ParamSpec_DimCheckMode_name = map[int32]string{
	0: "STRICT",
	1: "PERMISSIVE",
}
var ParamSpec_DimCheckMode_value = map[string]int32{
	"STRICT":     0,
	"PERMISSIVE": 1,
}

func (x ParamSpec_DimCheckMode) Enum() *ParamSpec_DimCheckMode {
	p := new(ParamSpec_DimCheckMode)
	*p = x
	return p
}
func (x ParamSpec_DimCheckMode) String() string {
	return proto.EnumName(ParamSpec_DimCheckMode_name, int32(x))
}
func (x *ParamSpec_DimCheckMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ParamSpec_DimCheckMode_value, data, "ParamSpec_DimCheckMode")
	if err != nil {
		return err
	}
	*x = ParamSpec_DimCheckMode(value)
	return nil
}
func (ParamSpec_DimCheckMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{10, 0}
}

// How to normalize the loss for loss layers that aggregate across batches,
// spatial dimensions, or other dimensions.  Currently only implemented in
// SoftmaxWithLoss layer.
type LossParameter_NormalizationMode int32

const (
	// Divide by the number of examples in the batch times spatial dimensions.
	// Outputs that receive the ignore label will NOT be ignored in computing
	// the normalization factor.
	LossParameter_FULL LossParameter_NormalizationMode = 0
	// Divide by the total number of output locations that do not take the
	// ignore_label.  If ignore_label is not set, this behaves like FULL.
	LossParameter_VALID LossParameter_NormalizationMode = 1
	// Divide by the batch size.
	LossParameter_BATCH_SIZE LossParameter_NormalizationMode = 2
	// Do not normalize the loss.
	LossParameter_NONE LossParameter_NormalizationMode = 3
)

var LossParameter_NormalizationMode_name = map[int32]string{
	0: "FULL",
	1: "VALID",
	2: "BATCH_SIZE",
	3: "NONE",
}
var LossParameter_NormalizationMode_value = map[string]int32{
	"FULL":       0,
	"VALID":      1,
	"BATCH_SIZE": 2,
	"NONE":       3,
}

func (x LossParameter_NormalizationMode) Enum() *LossParameter_NormalizationMode {
	p := new(LossParameter_NormalizationMode)
	*p = x
	return p
}
func (x LossParameter_NormalizationMode) String() string {
	return proto.EnumName(LossParameter_NormalizationMode_name, int32(x))
}
func (x *LossParameter_NormalizationMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LossParameter_NormalizationMode_value, data, "LossParameter_NormalizationMode")
	if err != nil {
		return err
	}
	*x = LossParameter_NormalizationMode(value)
	return nil
}
func (LossParameter_NormalizationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{13, 0}
}

type ConvolutionParameter_Engine int32

const (
	ConvolutionParameter_DEFAULT ConvolutionParameter_Engine = 0
	ConvolutionParameter_CAFFE   ConvolutionParameter_Engine = 1
	ConvolutionParameter_CUDNN   ConvolutionParameter_Engine = 2
)

var ConvolutionParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var ConvolutionParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x ConvolutionParameter_Engine) Enum() *ConvolutionParameter_Engine {
	p := new(ConvolutionParameter_Engine)
	*p = x
	return p
}
func (x ConvolutionParameter_Engine) String() string {
	return proto.EnumName(ConvolutionParameter_Engine_name, int32(x))
}
func (x *ConvolutionParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConvolutionParameter_Engine_value, data, "ConvolutionParameter_Engine")
	if err != nil {
		return err
	}
	*x = ConvolutionParameter_Engine(value)
	return nil
}
func (ConvolutionParameter_Engine) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{20, 0}
}

type DataParameter_DB int32

const (
	DataParameter_LEVELDB DataParameter_DB = 0
	DataParameter_LMDB    DataParameter_DB = 1
)

var DataParameter_DB_name = map[int32]string{
	0: "LEVELDB",
	1: "LMDB",
}
var DataParameter_DB_value = map[string]int32{
	"LEVELDB": 0,
	"LMDB":    1,
}

func (x DataParameter_DB) Enum() *DataParameter_DB {
	p := new(DataParameter_DB)
	*p = x
	return p
}
func (x DataParameter_DB) String() string {
	return proto.EnumName(DataParameter_DB_name, int32(x))
}
func (x *DataParameter_DB) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DataParameter_DB_value, data, "DataParameter_DB")
	if err != nil {
		return err
	}
	*x = DataParameter_DB(value)
	return nil
}
func (DataParameter_DB) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{22, 0}
}

type EltwiseParameter_EltwiseOp int32

const (
	EltwiseParameter_PROD EltwiseParameter_EltwiseOp = 0
	EltwiseParameter_SUM  EltwiseParameter_EltwiseOp = 1
	EltwiseParameter_MAX  EltwiseParameter_EltwiseOp = 2
)

var EltwiseParameter_EltwiseOp_name = map[int32]string{
	0: "PROD",
	1: "SUM",
	2: "MAX",
}
var EltwiseParameter_EltwiseOp_value = map[string]int32{
	"PROD": 0,
	"SUM":  1,
	"MAX":  2,
}

func (x EltwiseParameter_EltwiseOp) Enum() *EltwiseParameter_EltwiseOp {
	p := new(EltwiseParameter_EltwiseOp)
	*p = x
	return p
}
func (x EltwiseParameter_EltwiseOp) String() string {
	return proto.EnumName(EltwiseParameter_EltwiseOp_name, int32(x))
}
func (x *EltwiseParameter_EltwiseOp) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EltwiseParameter_EltwiseOp_value, data, "EltwiseParameter_EltwiseOp")
	if err != nil {
		return err
	}
	*x = EltwiseParameter_EltwiseOp(value)
	return nil
}
func (EltwiseParameter_EltwiseOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{25, 0}
}

type HingeLossParameter_Norm int32

const (
	HingeLossParameter_L1 HingeLossParameter_Norm = 1
	HingeLossParameter_L2 HingeLossParameter_Norm = 2
)

var HingeLossParameter_Norm_name = map[int32]string{
	1: "L1",
	2: "L2",
}
var HingeLossParameter_Norm_value = map[string]int32{
	"L1": 1,
	"L2": 2,
}

func (x HingeLossParameter_Norm) Enum() *HingeLossParameter_Norm {
	p := new(HingeLossParameter_Norm)
	*p = x
	return p
}
func (x HingeLossParameter_Norm) String() string {
	return proto.EnumName(HingeLossParameter_Norm_name, int32(x))
}
func (x *HingeLossParameter_Norm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HingeLossParameter_Norm_value, data, "HingeLossParameter_Norm")
	if err != nil {
		return err
	}
	*x = HingeLossParameter_Norm(value)
	return nil
}
func (HingeLossParameter_Norm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{32, 0}
}

type LRNParameter_NormRegion int32

const (
	LRNParameter_ACROSS_CHANNELS LRNParameter_NormRegion = 0
	LRNParameter_WITHIN_CHANNEL  LRNParameter_NormRegion = 1
)

var LRNParameter_NormRegion_name = map[int32]string{
	0: "ACROSS_CHANNELS",
	1: "WITHIN_CHANNEL",
}
var LRNParameter_NormRegion_value = map[string]int32{
	"ACROSS_CHANNELS": 0,
	"WITHIN_CHANNEL":  1,
}

func (x LRNParameter_NormRegion) Enum() *LRNParameter_NormRegion {
	p := new(LRNParameter_NormRegion)
	*p = x
	return p
}
func (x LRNParameter_NormRegion) String() string {
	return proto.EnumName(LRNParameter_NormRegion_name, int32(x))
}
func (x *LRNParameter_NormRegion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LRNParameter_NormRegion_value, data, "LRNParameter_NormRegion")
	if err != nil {
		return err
	}
	*x = LRNParameter_NormRegion(value)
	return nil
}
func (LRNParameter_NormRegion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{38, 0}
}

type LRNParameter_Engine int32

const (
	LRNParameter_DEFAULT LRNParameter_Engine = 0
	LRNParameter_CAFFE   LRNParameter_Engine = 1
	LRNParameter_CUDNN   LRNParameter_Engine = 2
)

var LRNParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var LRNParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x LRNParameter_Engine) Enum() *LRNParameter_Engine {
	p := new(LRNParameter_Engine)
	*p = x
	return p
}
func (x LRNParameter_Engine) String() string {
	return proto.EnumName(LRNParameter_Engine_name, int32(x))
}
func (x *LRNParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LRNParameter_Engine_value, data, "LRNParameter_Engine")
	if err != nil {
		return err
	}
	*x = LRNParameter_Engine(value)
	return nil
}
func (LRNParameter_Engine) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{38, 1}
}

type PoolingParameter_PoolMethod int32

const (
	PoolingParameter_MAX        PoolingParameter_PoolMethod = 0
	PoolingParameter_AVE        PoolingParameter_PoolMethod = 1
	PoolingParameter_STOCHASTIC PoolingParameter_PoolMethod = 2
)

var PoolingParameter_PoolMethod_name = map[int32]string{
	0: "MAX",
	1: "AVE",
	2: "STOCHASTIC",
}
var PoolingParameter_PoolMethod_value = map[string]int32{
	"MAX":        0,
	"AVE":        1,
	"STOCHASTIC": 2,
}

func (x PoolingParameter_PoolMethod) Enum() *PoolingParameter_PoolMethod {
	p := new(PoolingParameter_PoolMethod)
	*p = x
	return p
}
func (x PoolingParameter_PoolMethod) String() string {
	return proto.EnumName(PoolingParameter_PoolMethod_name, int32(x))
}
func (x *PoolingParameter_PoolMethod) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PoolingParameter_PoolMethod_value, data, "PoolingParameter_PoolMethod")
	if err != nil {
		return err
	}
	*x = PoolingParameter_PoolMethod(value)
	return nil
}
func (PoolingParameter_PoolMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{42, 0}
}

type PoolingParameter_Engine int32

const (
	PoolingParameter_DEFAULT PoolingParameter_Engine = 0
	PoolingParameter_CAFFE   PoolingParameter_Engine = 1
	PoolingParameter_CUDNN   PoolingParameter_Engine = 2
)

var PoolingParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var PoolingParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x PoolingParameter_Engine) Enum() *PoolingParameter_Engine {
	p := new(PoolingParameter_Engine)
	*p = x
	return p
}
func (x PoolingParameter_Engine) String() string {
	return proto.EnumName(PoolingParameter_Engine_name, int32(x))
}
func (x *PoolingParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PoolingParameter_Engine_value, data, "PoolingParameter_Engine")
	if err != nil {
		return err
	}
	*x = PoolingParameter_Engine(value)
	return nil
}
func (PoolingParameter_Engine) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{42, 1}
}

type ReductionParameter_ReductionOp int32

const (
	ReductionParameter_SUM   ReductionParameter_ReductionOp = 1
	ReductionParameter_ASUM  ReductionParameter_ReductionOp = 2
	ReductionParameter_SUMSQ ReductionParameter_ReductionOp = 3
	ReductionParameter_MEAN  ReductionParameter_ReductionOp = 4
)

var ReductionParameter_ReductionOp_name = map[int32]string{
	1: "SUM",
	2: "ASUM",
	3: "SUMSQ",
	4: "MEAN",
}
var ReductionParameter_ReductionOp_value = map[string]int32{
	"SUM":   1,
	"ASUM":  2,
	"SUMSQ": 3,
	"MEAN":  4,
}

func (x ReductionParameter_ReductionOp) Enum() *ReductionParameter_ReductionOp {
	p := new(ReductionParameter_ReductionOp)
	*p = x
	return p
}
func (x ReductionParameter_ReductionOp) String() string {
	return proto.EnumName(ReductionParameter_ReductionOp_name, int32(x))
}
func (x *ReductionParameter_ReductionOp) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ReductionParameter_ReductionOp_value, data, "ReductionParameter_ReductionOp")
	if err != nil {
		return err
	}
	*x = ReductionParameter_ReductionOp(value)
	return nil
}
func (ReductionParameter_ReductionOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{46, 0}
}

type ReLUParameter_Engine int32

const (
	ReLUParameter_DEFAULT ReLUParameter_Engine = 0
	ReLUParameter_CAFFE   ReLUParameter_Engine = 1
	ReLUParameter_CUDNN   ReLUParameter_Engine = 2
)

var ReLUParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var ReLUParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x ReLUParameter_Engine) Enum() *ReLUParameter_Engine {
	p := new(ReLUParameter_Engine)
	*p = x
	return p
}
func (x ReLUParameter_Engine) String() string {
	return proto.EnumName(ReLUParameter_Engine_name, int32(x))
}
func (x *ReLUParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ReLUParameter_Engine_value, data, "ReLUParameter_Engine")
	if err != nil {
		return err
	}
	*x = ReLUParameter_Engine(value)
	return nil
}
func (ReLUParameter_Engine) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{47, 0}
}

type SigmoidParameter_Engine int32

const (
	SigmoidParameter_DEFAULT SigmoidParameter_Engine = 0
	SigmoidParameter_CAFFE   SigmoidParameter_Engine = 1
	SigmoidParameter_CUDNN   SigmoidParameter_Engine = 2
)

var SigmoidParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var SigmoidParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x SigmoidParameter_Engine) Enum() *SigmoidParameter_Engine {
	p := new(SigmoidParameter_Engine)
	*p = x
	return p
}
func (x SigmoidParameter_Engine) String() string {
	return proto.EnumName(SigmoidParameter_Engine_name, int32(x))
}
func (x *SigmoidParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SigmoidParameter_Engine_value, data, "SigmoidParameter_Engine")
	if err != nil {
		return err
	}
	*x = SigmoidParameter_Engine(value)
	return nil
}
func (SigmoidParameter_Engine) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{50, 0}
}

type SoftmaxParameter_Engine int32

const (
	SoftmaxParameter_DEFAULT SoftmaxParameter_Engine = 0
	SoftmaxParameter_CAFFE   SoftmaxParameter_Engine = 1
	SoftmaxParameter_CUDNN   SoftmaxParameter_Engine = 2
)

var SoftmaxParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var SoftmaxParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x SoftmaxParameter_Engine) Enum() *SoftmaxParameter_Engine {
	p := new(SoftmaxParameter_Engine)
	*p = x
	return p
}
func (x SoftmaxParameter_Engine) String() string {
	return proto.EnumName(SoftmaxParameter_Engine_name, int32(x))
}
func (x *SoftmaxParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SoftmaxParameter_Engine_value, data, "SoftmaxParameter_Engine")
	if err != nil {
		return err
	}
	*x = SoftmaxParameter_Engine(value)
	return nil
}
func (SoftmaxParameter_Engine) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{52, 0}
}

type TanHParameter_Engine int32

const (
	TanHParameter_DEFAULT TanHParameter_Engine = 0
	TanHParameter_CAFFE   TanHParameter_Engine = 1
	TanHParameter_CUDNN   TanHParameter_Engine = 2
)

var TanHParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var TanHParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x TanHParameter_Engine) Enum() *TanHParameter_Engine {
	p := new(TanHParameter_Engine)
	*p = x
	return p
}
func (x TanHParameter_Engine) String() string {
	return proto.EnumName(TanHParameter_Engine_name, int32(x))
}
func (x *TanHParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TanHParameter_Engine_value, data, "TanHParameter_Engine")
	if err != nil {
		return err
	}
	*x = TanHParameter_Engine(value)
	return nil
}
func (TanHParameter_Engine) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{53, 0}
}

type SPPParameter_PoolMethod int32

const (
	SPPParameter_MAX        SPPParameter_PoolMethod = 0
	SPPParameter_AVE        SPPParameter_PoolMethod = 1
	SPPParameter_STOCHASTIC SPPParameter_PoolMethod = 2
)

var SPPParameter_PoolMethod_name = map[int32]string{
	0: "MAX",
	1: "AVE",
	2: "STOCHASTIC",
}
var SPPParameter_PoolMethod_value = map[string]int32{
	"MAX":        0,
	"AVE":        1,
	"STOCHASTIC": 2,
}

func (x SPPParameter_PoolMethod) Enum() *SPPParameter_PoolMethod {
	p := new(SPPParameter_PoolMethod)
	*p = x
	return p
}
func (x SPPParameter_PoolMethod) String() string {
	return proto.EnumName(SPPParameter_PoolMethod_name, int32(x))
}
func (x *SPPParameter_PoolMethod) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SPPParameter_PoolMethod_value, data, "SPPParameter_PoolMethod")
	if err != nil {
		return err
	}
	*x = SPPParameter_PoolMethod(value)
	return nil
}
func (SPPParameter_PoolMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{57, 0}
}

type SPPParameter_Engine int32

const (
	SPPParameter_DEFAULT SPPParameter_Engine = 0
	SPPParameter_CAFFE   SPPParameter_Engine = 1
	SPPParameter_CUDNN   SPPParameter_Engine = 2
)

var SPPParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var SPPParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x SPPParameter_Engine) Enum() *SPPParameter_Engine {
	p := new(SPPParameter_Engine)
	*p = x
	return p
}
func (x SPPParameter_Engine) String() string {
	return proto.EnumName(SPPParameter_Engine_name, int32(x))
}
func (x *SPPParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SPPParameter_Engine_value, data, "SPPParameter_Engine")
	if err != nil {
		return err
	}
	*x = SPPParameter_Engine(value)
	return nil
}
func (SPPParameter_Engine) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{57, 1}
}

type V1LayerParameter_LayerType int32

const (
	V1LayerParameter_NONE                       V1LayerParameter_LayerType = 0
	V1LayerParameter_ABSVAL                     V1LayerParameter_LayerType = 35
	V1LayerParameter_ACCURACY                   V1LayerParameter_LayerType = 1
	V1LayerParameter_ARGMAX                     V1LayerParameter_LayerType = 30
	V1LayerParameter_BNLL                       V1LayerParameter_LayerType = 2
	V1LayerParameter_CONCAT                     V1LayerParameter_LayerType = 3
	V1LayerParameter_CONTRASTIVE_LOSS           V1LayerParameter_LayerType = 37
	V1LayerParameter_CONVOLUTION                V1LayerParameter_LayerType = 4
	V1LayerParameter_DATA                       V1LayerParameter_LayerType = 5
	V1LayerParameter_DECONVOLUTION              V1LayerParameter_LayerType = 39
	V1LayerParameter_DROPOUT                    V1LayerParameter_LayerType = 6
	V1LayerParameter_DUMMY_DATA                 V1LayerParameter_LayerType = 32
	V1LayerParameter_EUCLIDEAN_LOSS             V1LayerParameter_LayerType = 7
	V1LayerParameter_ELTWISE                    V1LayerParameter_LayerType = 25
	V1LayerParameter_EXP                        V1LayerParameter_LayerType = 38
	V1LayerParameter_FLATTEN                    V1LayerParameter_LayerType = 8
	V1LayerParameter_HDF5_DATA                  V1LayerParameter_LayerType = 9
	V1LayerParameter_HDF5_OUTPUT                V1LayerParameter_LayerType = 10
	V1LayerParameter_HINGE_LOSS                 V1LayerParameter_LayerType = 28
	V1LayerParameter_IM2COL                     V1LayerParameter_LayerType = 11
	V1LayerParameter_IMAGE_DATA                 V1LayerParameter_LayerType = 12
	V1LayerParameter_INFOGAIN_LOSS              V1LayerParameter_LayerType = 13
	V1LayerParameter_INNER_PRODUCT              V1LayerParameter_LayerType = 14
	V1LayerParameter_LRN                        V1LayerParameter_LayerType = 15
	V1LayerParameter_MEMORY_DATA                V1LayerParameter_LayerType = 29
	V1LayerParameter_MULTINOMIAL_LOGISTIC_LOSS  V1LayerParameter_LayerType = 16
	V1LayerParameter_MVN                        V1LayerParameter_LayerType = 34
	V1LayerParameter_POOLING                    V1LayerParameter_LayerType = 17
	V1LayerParameter_POWER                      V1LayerParameter_LayerType = 26
	V1LayerParameter_RELU                       V1LayerParameter_LayerType = 18
	V1LayerParameter_SIGMOID                    V1LayerParameter_LayerType = 19
	V1LayerParameter_SIGMOID_CROSS_ENTROPY_LOSS V1LayerParameter_LayerType = 27
	V1LayerParameter_SILENCE                    V1LayerParameter_LayerType = 36
	V1LayerParameter_SOFTMAX                    V1LayerParameter_LayerType = 20
	V1LayerParameter_SOFTMAX_LOSS               V1LayerParameter_LayerType = 21
	V1LayerParameter_SPLIT                      V1LayerParameter_LayerType = 22
	V1LayerParameter_SLICE                      V1LayerParameter_LayerType = 33
	V1LayerParameter_TANH                       V1LayerParameter_LayerType = 23
	V1LayerParameter_WINDOW_DATA                V1LayerParameter_LayerType = 24
	V1LayerParameter_THRESHOLD                  V1LayerParameter_LayerType = 31
)

var V1LayerParameter_LayerType_name = map[int32]string{
	0:  "NONE",
	35: "ABSVAL",
	1:  "ACCURACY",
	30: "ARGMAX",
	2:  "BNLL",
	3:  "CONCAT",
	37: "CONTRASTIVE_LOSS",
	4:  "CONVOLUTION",
	5:  "DATA",
	39: "DECONVOLUTION",
	6:  "DROPOUT",
	32: "DUMMY_DATA",
	7:  "EUCLIDEAN_LOSS",
	25: "ELTWISE",
	38: "EXP",
	8:  "FLATTEN",
	9:  "HDF5_DATA",
	10: "HDF5_OUTPUT",
	28: "HINGE_LOSS",
	11: "IM2COL",
	12: "IMAGE_DATA",
	13: "INFOGAIN_LOSS",
	14: "INNER_PRODUCT",
	15: "LRN",
	29: "MEMORY_DATA",
	16: "MULTINOMIAL_LOGISTIC_LOSS",
	34: "MVN",
	17: "POOLING",
	26: "POWER",
	18: "RELU",
	19: "SIGMOID",
	27: "SIGMOID_CROSS_ENTROPY_LOSS",
	36: "SILENCE",
	20: "SOFTMAX",
	21: "SOFTMAX_LOSS",
	22: "SPLIT",
	33: "SLICE",
	23: "TANH",
	24: "WINDOW_DATA",
	31: "THRESHOLD",
}
var V1LayerParameter_LayerType_value = map[string]int32{
	"NONE":                       0,
	"ABSVAL":                     35,
	"ACCURACY":                   1,
	"ARGMAX":                     30,
	"BNLL":                       2,
	"CONCAT":                     3,
	"CONTRASTIVE_LOSS":           37,
	"CONVOLUTION":                4,
	"DATA":                       5,
	"DECONVOLUTION":              39,
	"DROPOUT":                    6,
	"DUMMY_DATA":                 32,
	"EUCLIDEAN_LOSS":             7,
	"ELTWISE":                    25,
	"EXP":                        38,
	"FLATTEN":                    8,
	"HDF5_DATA":                  9,
	"HDF5_OUTPUT":                10,
	"HINGE_LOSS":                 28,
	"IM2COL":                     11,
	"IMAGE_DATA":                 12,
	"INFOGAIN_LOSS":              13,
	"INNER_PRODUCT":              14,
	"LRN":                        15,
	"MEMORY_DATA":                29,
	"MULTINOMIAL_LOGISTIC_LOSS":  16,
	"MVN":                        34,
	"POOLING":                    17,
	"POWER":                      26,
	"RELU":                       18,
	"SIGMOID":                    19,
	"SIGMOID_CROSS_ENTROPY_LOSS": 27,
	"SILENCE":                    36,
	"SOFTMAX":                    20,
	"SOFTMAX_LOSS":               21,
	"SPLIT":                      22,
	"SLICE":                      33,
	"TANH":                       23,
	"WINDOW_DATA":                24,
	"THRESHOLD":                  31,
}

func (x V1LayerParameter_LayerType) Enum() *V1LayerParameter_LayerType {
	p := new(V1LayerParameter_LayerType)
	*p = x
	return p
}
func (x V1LayerParameter_LayerType) String() string {
	return proto.EnumName(V1LayerParameter_LayerType_name, int32(x))
}
func (x *V1LayerParameter_LayerType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(V1LayerParameter_LayerType_value, data, "V1LayerParameter_LayerType")
	if err != nil {
		return err
	}
	*x = V1LayerParameter_LayerType(value)
	return nil
}
func (V1LayerParameter_LayerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{58, 0}
}

type V1LayerParameter_DimCheckMode int32

const (
	V1LayerParameter_STRICT     V1LayerParameter_DimCheckMode = 0
	V1LayerParameter_PERMISSIVE V1LayerParameter_DimCheckMode = 1
)

var V1LayerParameter_DimCheckMode_name = map[int32]string{
	0: "STRICT",
	1: "PERMISSIVE",
}
var V1LayerParameter_DimCheckMode_value = map[string]int32{
	"STRICT":     0,
	"PERMISSIVE": 1,
}

func (x V1LayerParameter_DimCheckMode) Enum() *V1LayerParameter_DimCheckMode {
	p := new(V1LayerParameter_DimCheckMode)
	*p = x
	return p
}
func (x V1LayerParameter_DimCheckMode) String() string {
	return proto.EnumName(V1LayerParameter_DimCheckMode_name, int32(x))
}
func (x *V1LayerParameter_DimCheckMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(V1LayerParameter_DimCheckMode_value, data, "V1LayerParameter_DimCheckMode")
	if err != nil {
		return err
	}
	*x = V1LayerParameter_DimCheckMode(value)
	return nil
}
func (V1LayerParameter_DimCheckMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{58, 1}
}

type V0LayerParameter_PoolMethod int32

const (
	V0LayerParameter_MAX        V0LayerParameter_PoolMethod = 0
	V0LayerParameter_AVE        V0LayerParameter_PoolMethod = 1
	V0LayerParameter_STOCHASTIC V0LayerParameter_PoolMethod = 2
)

var V0LayerParameter_PoolMethod_name = map[int32]string{
	0: "MAX",
	1: "AVE",
	2: "STOCHASTIC",
}
var V0LayerParameter_PoolMethod_value = map[string]int32{
	"MAX":        0,
	"AVE":        1,
	"STOCHASTIC": 2,
}

func (x V0LayerParameter_PoolMethod) Enum() *V0LayerParameter_PoolMethod {
	p := new(V0LayerParameter_PoolMethod)
	*p = x
	return p
}
func (x V0LayerParameter_PoolMethod) String() string {
	return proto.EnumName(V0LayerParameter_PoolMethod_name, int32(x))
}
func (x *V0LayerParameter_PoolMethod) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(V0LayerParameter_PoolMethod_value, data, "V0LayerParameter_PoolMethod")
	if err != nil {
		return err
	}
	*x = V0LayerParameter_PoolMethod(value)
	return nil
}
func (V0LayerParameter_PoolMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{59, 0}
}

// Specifies the shape (dimensions) of a Blob.
type BlobShape struct {
	Dim []int64 `protobuf:"varint,1,rep,packed,name=dim" json:"dim,omitempty"`
}

func (m *BlobShape) Reset()         { *m = BlobShape{} }
func (m *BlobShape) String() string { return proto.CompactTextString(m) }
func (*BlobShape) ProtoMessage()    {}
func (*BlobShape) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{0}
}
func (m *BlobShape) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobShape) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobShape.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlobShape) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobShape.Merge(dst, src)
}
func (m *BlobShape) XXX_Size() int {
	return m.Size()
}
func (m *BlobShape) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobShape.DiscardUnknown(m)
}

var xxx_messageInfo_BlobShape proto.InternalMessageInfo

func (m *BlobShape) GetDim() []int64 {
	if m != nil {
		return m.Dim
	}
	return nil
}

type BlobProto struct {
	Shape      *BlobShape `protobuf:"bytes,7,opt,name=shape" json:"shape,omitempty"`
	Data       []float32  `protobuf:"fixed32,5,rep,packed,name=data" json:"data,omitempty"`
	Diff       []float32  `protobuf:"fixed32,6,rep,packed,name=diff" json:"diff,omitempty"`
	DoubleData []float64  `protobuf:"fixed64,8,rep,packed,name=double_data,json=doubleData" json:"double_data,omitempty"`
	DoubleDiff []float64  `protobuf:"fixed64,9,rep,packed,name=double_diff,json=doubleDiff" json:"double_diff,omitempty"`
	// 4D dimensions -- deprecated.  Use "shape" instead.
	Num      *int32 `protobuf:"varint,1,opt,name=num,def=0" json:"num,omitempty"`
	Channels *int32 `protobuf:"varint,2,opt,name=channels,def=0" json:"channels,omitempty"`
	Height   *int32 `protobuf:"varint,3,opt,name=height,def=0" json:"height,omitempty"`
	Width    *int32 `protobuf:"varint,4,opt,name=width,def=0" json:"width,omitempty"`
}

func (m *BlobProto) Reset()         { *m = BlobProto{} }
func (m *BlobProto) String() string { return proto.CompactTextString(m) }
func (*BlobProto) ProtoMessage()    {}
func (*BlobProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{1}
}
func (m *BlobProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlobProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobProto.Merge(dst, src)
}
func (m *BlobProto) XXX_Size() int {
	return m.Size()
}
func (m *BlobProto) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobProto.DiscardUnknown(m)
}

var xxx_messageInfo_BlobProto proto.InternalMessageInfo

const Default_BlobProto_Num int32 = 0
const Default_BlobProto_Channels int32 = 0
const Default_BlobProto_Height int32 = 0
const Default_BlobProto_Width int32 = 0

func (m *BlobProto) GetShape() *BlobShape {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *BlobProto) GetData() []float32 {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *BlobProto) GetDiff() []float32 {
	if m != nil {
		return m.Diff
	}
	return nil
}

func (m *BlobProto) GetDoubleData() []float64 {
	if m != nil {
		return m.DoubleData
	}
	return nil
}

func (m *BlobProto) GetDoubleDiff() []float64 {
	if m != nil {
		return m.DoubleDiff
	}
	return nil
}

func (m *BlobProto) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return Default_BlobProto_Num
}

func (m *BlobProto) GetChannels() int32 {
	if m != nil && m.Channels != nil {
		return *m.Channels
	}
	return Default_BlobProto_Channels
}

func (m *BlobProto) GetHeight() int32 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return Default_BlobProto_Height
}

func (m *BlobProto) GetWidth() int32 {
	if m != nil && m.Width != nil {
		return *m.Width
	}
	return Default_BlobProto_Width
}

// The BlobProtoVector is simply a way to pass multiple blobproto instances
// around.
type BlobProtoVector struct {
	Blobs []*BlobProto `protobuf:"bytes,1,rep,name=blobs" json:"blobs,omitempty"`
}

func (m *BlobProtoVector) Reset()         { *m = BlobProtoVector{} }
func (m *BlobProtoVector) String() string { return proto.CompactTextString(m) }
func (*BlobProtoVector) ProtoMessage()    {}
func (*BlobProtoVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{2}
}
func (m *BlobProtoVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobProtoVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobProtoVector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlobProtoVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobProtoVector.Merge(dst, src)
}
func (m *BlobProtoVector) XXX_Size() int {
	return m.Size()
}
func (m *BlobProtoVector) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobProtoVector.DiscardUnknown(m)
}

var xxx_messageInfo_BlobProtoVector proto.InternalMessageInfo

func (m *BlobProtoVector) GetBlobs() []*BlobProto {
	if m != nil {
		return m.Blobs
	}
	return nil
}

type Datum struct {
	Channels int32 `protobuf:"varint,1,opt,name=channels" json:"channels"`
	Height   int32 `protobuf:"varint,2,opt,name=height" json:"height"`
	Width    int32 `protobuf:"varint,3,opt,name=width" json:"width"`
	// the actual image data, in bytes
	Data  []byte `protobuf:"bytes,4,opt,name=data" json:"data"`
	Label int32  `protobuf:"varint,5,opt,name=label" json:"label"`
	// Optionally, the datum could also hold float data.
	FloatData []float32 `protobuf:"fixed32,6,rep,name=float_data,json=floatData" json:"float_data,omitempty"`
	// If true data contains an encoded image that need to be decoded
	Encoded *bool `protobuf:"varint,7,opt,name=encoded,def=0" json:"encoded,omitempty"`
}

func (m *Datum) Reset()         { *m = Datum{} }
func (m *Datum) String() string { return proto.CompactTextString(m) }
func (*Datum) ProtoMessage()    {}
func (*Datum) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{3}
}
func (m *Datum) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Datum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Datum.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Datum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Datum.Merge(dst, src)
}
func (m *Datum) XXX_Size() int {
	return m.Size()
}
func (m *Datum) XXX_DiscardUnknown() {
	xxx_messageInfo_Datum.DiscardUnknown(m)
}

var xxx_messageInfo_Datum proto.InternalMessageInfo

const Default_Datum_Encoded bool = false

func (m *Datum) GetChannels() int32 {
	if m != nil {
		return m.Channels
	}
	return 0
}

func (m *Datum) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Datum) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Datum) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Datum) GetLabel() int32 {
	if m != nil {
		return m.Label
	}
	return 0
}

func (m *Datum) GetFloatData() []float32 {
	if m != nil {
		return m.FloatData
	}
	return nil
}

func (m *Datum) GetEncoded() bool {
	if m != nil && m.Encoded != nil {
		return *m.Encoded
	}
	return Default_Datum_Encoded
}

type FillerParameter struct {
	// The filler type.
	Type  *string  `protobuf:"bytes,1,opt,name=type,def=constant" json:"type,omitempty"`
	Value *float32 `protobuf:"fixed32,2,opt,name=value,def=0" json:"value,omitempty"`
	Min   *float32 `protobuf:"fixed32,3,opt,name=min,def=0" json:"min,omitempty"`
	Max   *float32 `protobuf:"fixed32,4,opt,name=max,def=1" json:"max,omitempty"`
	Mean  *float32 `protobuf:"fixed32,5,opt,name=mean,def=0" json:"mean,omitempty"`
	Std   *float32 `protobuf:"fixed32,6,opt,name=std,def=1" json:"std,omitempty"`
	// The expected number of non-zero output weights for a given input in
	// Gaussian filler -- the default -1 means don't perform sparsification.
	Sparse       *int32                        `protobuf:"varint,7,opt,name=sparse,def=-1" json:"sparse,omitempty"`
	VarianceNorm *FillerParameter_VarianceNorm `protobuf:"varint,8,opt,name=variance_norm,json=varianceNorm,enum=caffe.FillerParameter_VarianceNorm,def=0" json:"variance_norm,omitempty"`
}

func (m *FillerParameter) Reset()         { *m = FillerParameter{} }
func (m *FillerParameter) String() string { return proto.CompactTextString(m) }
func (*FillerParameter) ProtoMessage()    {}
func (*FillerParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{4}
}
func (m *FillerParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FillerParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FillerParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FillerParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FillerParameter.Merge(dst, src)
}
func (m *FillerParameter) XXX_Size() int {
	return m.Size()
}
func (m *FillerParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_FillerParameter.DiscardUnknown(m)
}

var xxx_messageInfo_FillerParameter proto.InternalMessageInfo

const Default_FillerParameter_Type string = "constant"
const Default_FillerParameter_Value float32 = 0
const Default_FillerParameter_Min float32 = 0
const Default_FillerParameter_Max float32 = 1
const Default_FillerParameter_Mean float32 = 0
const Default_FillerParameter_Std float32 = 1
const Default_FillerParameter_Sparse int32 = -1
const Default_FillerParameter_VarianceNorm FillerParameter_VarianceNorm = FillerParameter_FAN_IN

func (m *FillerParameter) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_FillerParameter_Type
}

func (m *FillerParameter) GetValue() float32 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return Default_FillerParameter_Value
}

func (m *FillerParameter) GetMin() float32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return Default_FillerParameter_Min
}

func (m *FillerParameter) GetMax() float32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return Default_FillerParameter_Max
}

func (m *FillerParameter) GetMean() float32 {
	if m != nil && m.Mean != nil {
		return *m.Mean
	}
	return Default_FillerParameter_Mean
}

func (m *FillerParameter) GetStd() float32 {
	if m != nil && m.Std != nil {
		return *m.Std
	}
	return Default_FillerParameter_Std
}

func (m *FillerParameter) GetSparse() int32 {
	if m != nil && m.Sparse != nil {
		return *m.Sparse
	}
	return Default_FillerParameter_Sparse
}

func (m *FillerParameter) GetVarianceNorm() FillerParameter_VarianceNorm {
	if m != nil && m.VarianceNorm != nil {
		return *m.VarianceNorm
	}
	return Default_FillerParameter_VarianceNorm
}

type NetParameter struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// DEPRECATED. See InputParameter. The input blobs to the network.
	Input []string `protobuf:"bytes,3,rep,name=input" json:"input,omitempty"`
	// DEPRECATED. See InputParameter. The shape of the input blobs.
	InputShape []*BlobShape `protobuf:"bytes,8,rep,name=input_shape,json=inputShape" json:"input_shape,omitempty"`
	// 4D input dimensions -- deprecated.  Use "input_shape" instead.
	// If specified, for each input blob there should be four
	// values specifying the num, channels, height and width of the input blob.
	// Thus, there should be a total of (4 * #input) numbers.
	InputDim []int32 `protobuf:"varint,4,rep,name=input_dim,json=inputDim" json:"input_dim,omitempty"`
	// Whether the network will force every layer to carry out backward operation.
	// If set False, then whether to carry out backward is determined
	// automatically according to the net structure and learning rates.
	ForceBackward *bool `protobuf:"varint,5,opt,name=force_backward,json=forceBackward,def=0" json:"force_backward,omitempty"`
	// The current "state" of the network, including the phase, level, and stage.
	// Some layers may be included/excluded depending on this state and the states
	// specified in the layers' include and exclude fields.
	State *NetState `protobuf:"bytes,6,opt,name=state" json:"state,omitempty"`
	// Print debugging information about results while running Net::Forward,
	// Net::Backward, and Net::Update.
	DebugInfo *bool `protobuf:"varint,7,opt,name=debug_info,json=debugInfo,def=0" json:"debug_info,omitempty"`
	// The layers that make up the net.  Each of their configurations, including
	// connectivity and behavior, is specified as a LayerParameter.
	Layer []*LayerParameter `protobuf:"bytes,100,rep,name=layer" json:"layer,omitempty"`
	// DEPRECATED: use 'layer' instead.
	Layers []*V1LayerParameter `protobuf:"bytes,2,rep,name=layers" json:"layers,omitempty"`
}

func (m *NetParameter) Reset()         { *m = NetParameter{} }
func (m *NetParameter) String() string { return proto.CompactTextString(m) }
func (*NetParameter) ProtoMessage()    {}
func (*NetParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{5}
}
func (m *NetParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NetParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetParameter.Merge(dst, src)
}
func (m *NetParameter) XXX_Size() int {
	return m.Size()
}
func (m *NetParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_NetParameter.DiscardUnknown(m)
}

var xxx_messageInfo_NetParameter proto.InternalMessageInfo

const Default_NetParameter_ForceBackward bool = false
const Default_NetParameter_DebugInfo bool = false

func (m *NetParameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetParameter) GetInput() []string {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *NetParameter) GetInputShape() []*BlobShape {
	if m != nil {
		return m.InputShape
	}
	return nil
}

func (m *NetParameter) GetInputDim() []int32 {
	if m != nil {
		return m.InputDim
	}
	return nil
}

func (m *NetParameter) GetForceBackward() bool {
	if m != nil && m.ForceBackward != nil {
		return *m.ForceBackward
	}
	return Default_NetParameter_ForceBackward
}

func (m *NetParameter) GetState() *NetState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *NetParameter) GetDebugInfo() bool {
	if m != nil && m.DebugInfo != nil {
		return *m.DebugInfo
	}
	return Default_NetParameter_DebugInfo
}

func (m *NetParameter) GetLayer() []*LayerParameter {
	if m != nil {
		return m.Layer
	}
	return nil
}

func (m *NetParameter) GetLayers() []*V1LayerParameter {
	if m != nil {
		return m.Layers
	}
	return nil
}

// NOTE
// Update the next available ID when you add a new SolverParameter field.
//
// SolverParameter next available ID: 41 (last added: type)
type SolverParameter struct {
	// Proto filename for the train net, possibly combined with one or more
	// test nets.
	Net string `protobuf:"bytes,24,opt,name=net" json:"net"`
	// Inline train net param, possibly combined with one or more test nets.
	NetParam      *NetParameter   `protobuf:"bytes,25,opt,name=net_param,json=netParam" json:"net_param,omitempty"`
	TrainNet      string          `protobuf:"bytes,1,opt,name=train_net,json=trainNet" json:"train_net"`
	TestNet       []string        `protobuf:"bytes,2,rep,name=test_net,json=testNet" json:"test_net,omitempty"`
	TrainNetParam *NetParameter   `protobuf:"bytes,21,opt,name=train_net_param,json=trainNetParam" json:"train_net_param,omitempty"`
	TestNetParam  []*NetParameter `protobuf:"bytes,22,rep,name=test_net_param,json=testNetParam" json:"test_net_param,omitempty"`
	// The states for the train/test nets. Must be unspecified or
	// specified once per net.
	//
	// By default, all states will have solver = true;
	// train_state will have phase = TRAIN,
	// and all test_state's will have phase = TEST.
	// Other defaults are set according to the NetState defaults.
	TrainState *NetState   `protobuf:"bytes,26,opt,name=train_state,json=trainState" json:"train_state,omitempty"`
	TestState  []*NetState `protobuf:"bytes,27,rep,name=test_state,json=testState" json:"test_state,omitempty"`
	// The number of iterations for each test net.
	TestIter []int32 `protobuf:"varint,3,rep,name=test_iter,json=testIter" json:"test_iter,omitempty"`
	// The number of iterations between two testing phases.
	TestInterval    *int32 `protobuf:"varint,4,opt,name=test_interval,json=testInterval,def=0" json:"test_interval,omitempty"`
	TestComputeLoss *bool  `protobuf:"varint,19,opt,name=test_compute_loss,json=testComputeLoss,def=0" json:"test_compute_loss,omitempty"`
	// If true, run an initial test pass before the first iteration,
	// ensuring memory availability and printing the starting value of the loss.
	TestInitialization *bool   `protobuf:"varint,32,opt,name=test_initialization,json=testInitialization,def=1" json:"test_initialization,omitempty"`
	BaseLr             float32 `protobuf:"fixed32,5,opt,name=base_lr,json=baseLr" json:"base_lr"`
	// the number of iterations between displaying info. If display = 0, no info
	// will be displayed.
	Display int32 `protobuf:"varint,6,opt,name=display" json:"display"`
	// Display the loss averaged over the last average_loss iterations
	AverageLoss *int32 `protobuf:"varint,33,opt,name=average_loss,json=averageLoss,def=1" json:"average_loss,omitempty"`
	MaxIter     int32  `protobuf:"varint,7,opt,name=max_iter,json=maxIter" json:"max_iter"`
	// accumulate gradients over `iter_size` x `batch_size` instances
	IterSize *int32 `protobuf:"varint,36,opt,name=iter_size,json=iterSize,def=1" json:"iter_size,omitempty"`
	// The learning rate decay policy. The currently implemented learning rate
	// policies are as follows:
	//    - fixed: always return base_lr.
	//    - step: return base_lr * gamma ^ (floor(iter / step))
	//    - exp: return base_lr * gamma ^ iter
	//    - inv: return base_lr * (1 + gamma * iter) ^ (- power)
	//    - multistep: similar to step but it allows non uniform steps defined by
	//      stepvalue
	//    - poly: the effective learning rate follows a polynomial decay, to be
	//      zero by the max_iter. return base_lr (1 - iter/max_iter) ^ (power)
	//    - sigmoid: the effective learning rate follows a sigmod decay
	//      return base_lr ( 1/(1 + exp(-gamma * (iter - stepsize))))
	//
	// where base_lr, max_iter, gamma, step, stepvalue and power are defined
	// in the solver parameter protocol buffer, and iter is the current iteration.
	LrPolicy    string  `protobuf:"bytes,8,opt,name=lr_policy,json=lrPolicy" json:"lr_policy"`
	Gamma       float32 `protobuf:"fixed32,9,opt,name=gamma" json:"gamma"`
	Power       float32 `protobuf:"fixed32,10,opt,name=power" json:"power"`
	Momentum    float32 `protobuf:"fixed32,11,opt,name=momentum" json:"momentum"`
	WeightDecay float32 `protobuf:"fixed32,12,opt,name=weight_decay,json=weightDecay" json:"weight_decay"`
	// regularization types supported: L1 and L2
	// controlled by weight_decay
	RegularizationType *string `protobuf:"bytes,29,opt,name=regularization_type,json=regularizationType,def=L2" json:"regularization_type,omitempty"`
	// the stepsize for learning rate policy "step"
	Stepsize int32 `protobuf:"varint,13,opt,name=stepsize" json:"stepsize"`
	// the stepsize for learning rate policy "multistep"
	Stepvalue []int32 `protobuf:"varint,34,rep,name=stepvalue" json:"stepvalue,omitempty"`
	// Set clip_gradients to >= 0 to clip parameter gradients to that L2 norm,
	// whenever their actual L2 norm is larger.
	ClipGradients  *float32 `protobuf:"fixed32,35,opt,name=clip_gradients,json=clipGradients,def=-1" json:"clip_gradients,omitempty"`
	Snapshot       *int32   `protobuf:"varint,14,opt,name=snapshot,def=0" json:"snapshot,omitempty"`
	SnapshotPrefix string   `protobuf:"bytes,15,opt,name=snapshot_prefix,json=snapshotPrefix" json:"snapshot_prefix"`
	// whether to snapshot diff in the results or not. Snapshotting diff will help
	// debugging but the final protocol buffer size will be much larger.
	SnapshotDiff   *bool                           `protobuf:"varint,16,opt,name=snapshot_diff,json=snapshotDiff,def=0" json:"snapshot_diff,omitempty"`
	SnapshotFormat *SolverParameter_SnapshotFormat `protobuf:"varint,37,opt,name=snapshot_format,json=snapshotFormat,enum=caffe.SolverParameter_SnapshotFormat,def=1" json:"snapshot_format,omitempty"`
	SolverMode     *SolverParameter_SolverMode     `protobuf:"varint,17,opt,name=solver_mode,json=solverMode,enum=caffe.SolverParameter_SolverMode,def=1" json:"solver_mode,omitempty"`
	// the device_id will that be used in GPU mode. Use device_id = 0 in default.
	DeviceId *int32 `protobuf:"varint,18,opt,name=device_id,json=deviceId,def=0" json:"device_id,omitempty"`
	// If non-negative, the seed with which the Solver will initialize the Caffe
	// random number generator -- useful for reproducible results. Otherwise,
	// (and by default) initialize using a seed derived from the system clock.
	RandomSeed *int64 `protobuf:"varint,20,opt,name=random_seed,json=randomSeed,def=-1" json:"random_seed,omitempty"`
	// type of the solver
	Type *string `protobuf:"bytes,40,opt,name=type,def=SGD" json:"type,omitempty"`
	// numerical stability for RMSProp, AdaGrad and AdaDelta and Adam
	Delta *float32 `protobuf:"fixed32,31,opt,name=delta,def=1e-08" json:"delta,omitempty"`
	// parameters for the Adam solver
	Momentum2 *float32 `protobuf:"fixed32,39,opt,name=momentum2,def=0.999" json:"momentum2,omitempty"`
	// RMSProp decay value
	// MeanSquare(t) = rms_decay*MeanSquare(t-1) + (1-rms_decay)*SquareGradient(t)
	RmsDecay float32 `protobuf:"fixed32,38,opt,name=rms_decay,json=rmsDecay" json:"rms_decay"`
	// If true, print information about the state of the net that may help with
	// debugging learning problems.
	DebugInfo *bool `protobuf:"varint,23,opt,name=debug_info,json=debugInfo,def=0" json:"debug_info,omitempty"`
	// If false, don't save a snapshot after training finishes.
	SnapshotAfterTrain *bool `protobuf:"varint,28,opt,name=snapshot_after_train,json=snapshotAfterTrain,def=1" json:"snapshot_after_train,omitempty"`
	// DEPRECATED: use type instead of solver_type
	SolverType *SolverParameter_SolverType `protobuf:"varint,30,opt,name=solver_type,json=solverType,enum=caffe.SolverParameter_SolverType,def=0" json:"solver_type,omitempty"`
}

func (m *SolverParameter) Reset()         { *m = SolverParameter{} }
func (m *SolverParameter) String() string { return proto.CompactTextString(m) }
func (*SolverParameter) ProtoMessage()    {}
func (*SolverParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{6}
}
func (m *SolverParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SolverParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SolverParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SolverParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SolverParameter.Merge(dst, src)
}
func (m *SolverParameter) XXX_Size() int {
	return m.Size()
}
func (m *SolverParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_SolverParameter.DiscardUnknown(m)
}

var xxx_messageInfo_SolverParameter proto.InternalMessageInfo

const Default_SolverParameter_TestInterval int32 = 0
const Default_SolverParameter_TestComputeLoss bool = false
const Default_SolverParameter_TestInitialization bool = true
const Default_SolverParameter_AverageLoss int32 = 1
const Default_SolverParameter_IterSize int32 = 1
const Default_SolverParameter_RegularizationType string = "L2"
const Default_SolverParameter_ClipGradients float32 = -1
const Default_SolverParameter_Snapshot int32 = 0
const Default_SolverParameter_SnapshotDiff bool = false
const Default_SolverParameter_SnapshotFormat SolverParameter_SnapshotFormat = SolverParameter_BINARYPROTO
const Default_SolverParameter_SolverMode SolverParameter_SolverMode = SolverParameter_GPU
const Default_SolverParameter_DeviceId int32 = 0
const Default_SolverParameter_RandomSeed int64 = -1
const Default_SolverParameter_Type string = "SGD"
const Default_SolverParameter_Delta float32 = 1e-08
const Default_SolverParameter_Momentum2 float32 = 0.999
const Default_SolverParameter_DebugInfo bool = false
const Default_SolverParameter_SnapshotAfterTrain bool = true
const Default_SolverParameter_SolverType SolverParameter_SolverType = SolverParameter_SGD

func (m *SolverParameter) GetNet() string {
	if m != nil {
		return m.Net
	}
	return ""
}

func (m *SolverParameter) GetNetParam() *NetParameter {
	if m != nil {
		return m.NetParam
	}
	return nil
}

func (m *SolverParameter) GetTrainNet() string {
	if m != nil {
		return m.TrainNet
	}
	return ""
}

func (m *SolverParameter) GetTestNet() []string {
	if m != nil {
		return m.TestNet
	}
	return nil
}

func (m *SolverParameter) GetTrainNetParam() *NetParameter {
	if m != nil {
		return m.TrainNetParam
	}
	return nil
}

func (m *SolverParameter) GetTestNetParam() []*NetParameter {
	if m != nil {
		return m.TestNetParam
	}
	return nil
}

func (m *SolverParameter) GetTrainState() *NetState {
	if m != nil {
		return m.TrainState
	}
	return nil
}

func (m *SolverParameter) GetTestState() []*NetState {
	if m != nil {
		return m.TestState
	}
	return nil
}

func (m *SolverParameter) GetTestIter() []int32 {
	if m != nil {
		return m.TestIter
	}
	return nil
}

func (m *SolverParameter) GetTestInterval() int32 {
	if m != nil && m.TestInterval != nil {
		return *m.TestInterval
	}
	return Default_SolverParameter_TestInterval
}

func (m *SolverParameter) GetTestComputeLoss() bool {
	if m != nil && m.TestComputeLoss != nil {
		return *m.TestComputeLoss
	}
	return Default_SolverParameter_TestComputeLoss
}

func (m *SolverParameter) GetTestInitialization() bool {
	if m != nil && m.TestInitialization != nil {
		return *m.TestInitialization
	}
	return Default_SolverParameter_TestInitialization
}

func (m *SolverParameter) GetBaseLr() float32 {
	if m != nil {
		return m.BaseLr
	}
	return 0
}

func (m *SolverParameter) GetDisplay() int32 {
	if m != nil {
		return m.Display
	}
	return 0
}

func (m *SolverParameter) GetAverageLoss() int32 {
	if m != nil && m.AverageLoss != nil {
		return *m.AverageLoss
	}
	return Default_SolverParameter_AverageLoss
}

func (m *SolverParameter) GetMaxIter() int32 {
	if m != nil {
		return m.MaxIter
	}
	return 0
}

func (m *SolverParameter) GetIterSize() int32 {
	if m != nil && m.IterSize != nil {
		return *m.IterSize
	}
	return Default_SolverParameter_IterSize
}

func (m *SolverParameter) GetLrPolicy() string {
	if m != nil {
		return m.LrPolicy
	}
	return ""
}

func (m *SolverParameter) GetGamma() float32 {
	if m != nil {
		return m.Gamma
	}
	return 0
}

func (m *SolverParameter) GetPower() float32 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *SolverParameter) GetMomentum() float32 {
	if m != nil {
		return m.Momentum
	}
	return 0
}

func (m *SolverParameter) GetWeightDecay() float32 {
	if m != nil {
		return m.WeightDecay
	}
	return 0
}

func (m *SolverParameter) GetRegularizationType() string {
	if m != nil && m.RegularizationType != nil {
		return *m.RegularizationType
	}
	return Default_SolverParameter_RegularizationType
}

func (m *SolverParameter) GetStepsize() int32 {
	if m != nil {
		return m.Stepsize
	}
	return 0
}

func (m *SolverParameter) GetStepvalue() []int32 {
	if m != nil {
		return m.Stepvalue
	}
	return nil
}

func (m *SolverParameter) GetClipGradients() float32 {
	if m != nil && m.ClipGradients != nil {
		return *m.ClipGradients
	}
	return Default_SolverParameter_ClipGradients
}

func (m *SolverParameter) GetSnapshot() int32 {
	if m != nil && m.Snapshot != nil {
		return *m.Snapshot
	}
	return Default_SolverParameter_Snapshot
}

func (m *SolverParameter) GetSnapshotPrefix() string {
	if m != nil {
		return m.SnapshotPrefix
	}
	return ""
}

func (m *SolverParameter) GetSnapshotDiff() bool {
	if m != nil && m.SnapshotDiff != nil {
		return *m.SnapshotDiff
	}
	return Default_SolverParameter_SnapshotDiff
}

func (m *SolverParameter) GetSnapshotFormat() SolverParameter_SnapshotFormat {
	if m != nil && m.SnapshotFormat != nil {
		return *m.SnapshotFormat
	}
	return Default_SolverParameter_SnapshotFormat
}

func (m *SolverParameter) GetSolverMode() SolverParameter_SolverMode {
	if m != nil && m.SolverMode != nil {
		return *m.SolverMode
	}
	return Default_SolverParameter_SolverMode
}

func (m *SolverParameter) GetDeviceId() int32 {
	if m != nil && m.DeviceId != nil {
		return *m.DeviceId
	}
	return Default_SolverParameter_DeviceId
}

func (m *SolverParameter) GetRandomSeed() int64 {
	if m != nil && m.RandomSeed != nil {
		return *m.RandomSeed
	}
	return Default_SolverParameter_RandomSeed
}

func (m *SolverParameter) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_SolverParameter_Type
}

func (m *SolverParameter) GetDelta() float32 {
	if m != nil && m.Delta != nil {
		return *m.Delta
	}
	return Default_SolverParameter_Delta
}

func (m *SolverParameter) GetMomentum2() float32 {
	if m != nil && m.Momentum2 != nil {
		return *m.Momentum2
	}
	return Default_SolverParameter_Momentum2
}

func (m *SolverParameter) GetRmsDecay() float32 {
	if m != nil {
		return m.RmsDecay
	}
	return 0
}

func (m *SolverParameter) GetDebugInfo() bool {
	if m != nil && m.DebugInfo != nil {
		return *m.DebugInfo
	}
	return Default_SolverParameter_DebugInfo
}

func (m *SolverParameter) GetSnapshotAfterTrain() bool {
	if m != nil && m.SnapshotAfterTrain != nil {
		return *m.SnapshotAfterTrain
	}
	return Default_SolverParameter_SnapshotAfterTrain
}

func (m *SolverParameter) GetSolverType() SolverParameter_SolverType {
	if m != nil && m.SolverType != nil {
		return *m.SolverType
	}
	return Default_SolverParameter_SolverType
}

// A message that stores the solver snapshots
type SolverState struct {
	Iter        int32        `protobuf:"varint,1,opt,name=iter" json:"iter"`
	LearnedNet  string       `protobuf:"bytes,2,opt,name=learned_net,json=learnedNet" json:"learned_net"`
	History     []*BlobProto `protobuf:"bytes,3,rep,name=history" json:"history,omitempty"`
	CurrentStep *int32       `protobuf:"varint,4,opt,name=current_step,json=currentStep,def=0" json:"current_step,omitempty"`
}

func (m *SolverState) Reset()         { *m = SolverState{} }
func (m *SolverState) String() string { return proto.CompactTextString(m) }
func (*SolverState) ProtoMessage()    {}
func (*SolverState) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{7}
}
func (m *SolverState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SolverState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SolverState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SolverState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SolverState.Merge(dst, src)
}
func (m *SolverState) XXX_Size() int {
	return m.Size()
}
func (m *SolverState) XXX_DiscardUnknown() {
	xxx_messageInfo_SolverState.DiscardUnknown(m)
}

var xxx_messageInfo_SolverState proto.InternalMessageInfo

const Default_SolverState_CurrentStep int32 = 0

func (m *SolverState) GetIter() int32 {
	if m != nil {
		return m.Iter
	}
	return 0
}

func (m *SolverState) GetLearnedNet() string {
	if m != nil {
		return m.LearnedNet
	}
	return ""
}

func (m *SolverState) GetHistory() []*BlobProto {
	if m != nil {
		return m.History
	}
	return nil
}

func (m *SolverState) GetCurrentStep() int32 {
	if m != nil && m.CurrentStep != nil {
		return *m.CurrentStep
	}
	return Default_SolverState_CurrentStep
}

type NetState struct {
	Phase *Phase   `protobuf:"varint,1,opt,name=phase,enum=caffe.Phase,def=1" json:"phase,omitempty"`
	Level *int32   `protobuf:"varint,2,opt,name=level,def=0" json:"level,omitempty"`
	Stage []string `protobuf:"bytes,3,rep,name=stage" json:"stage,omitempty"`
}

func (m *NetState) Reset()         { *m = NetState{} }
func (m *NetState) String() string { return proto.CompactTextString(m) }
func (*NetState) ProtoMessage()    {}
func (*NetState) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{8}
}
func (m *NetState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NetState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetState.Merge(dst, src)
}
func (m *NetState) XXX_Size() int {
	return m.Size()
}
func (m *NetState) XXX_DiscardUnknown() {
	xxx_messageInfo_NetState.DiscardUnknown(m)
}

var xxx_messageInfo_NetState proto.InternalMessageInfo

const Default_NetState_Phase Phase = Phase_TEST
const Default_NetState_Level int32 = 0

func (m *NetState) GetPhase() Phase {
	if m != nil && m.Phase != nil {
		return *m.Phase
	}
	return Default_NetState_Phase
}

func (m *NetState) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return Default_NetState_Level
}

func (m *NetState) GetStage() []string {
	if m != nil {
		return m.Stage
	}
	return nil
}

type NetStateRule struct {
	// Set phase to require the NetState have a particular phase (TRAIN or TEST)
	// to meet this rule.
	Phase Phase `protobuf:"varint,1,opt,name=phase,enum=caffe.Phase" json:"phase"`
	// Set the minimum and/or maximum levels in which the layer should be used.
	// Leave undefined to meet the rule regardless of level.
	MinLevel int32 `protobuf:"varint,2,opt,name=min_level,json=minLevel" json:"min_level"`
	MaxLevel int32 `protobuf:"varint,3,opt,name=max_level,json=maxLevel" json:"max_level"`
	// Customizable sets of stages to include or exclude.
	// The net must have ALL of the specified stages and NONE of the specified
	// "not_stage"s to meet the rule.
	// (Use multiple NetStateRules to specify conjunctions of stages.)
	Stage    []string `protobuf:"bytes,4,rep,name=stage" json:"stage,omitempty"`
	NotStage []string `protobuf:"bytes,5,rep,name=not_stage,json=notStage" json:"not_stage,omitempty"`
}

func (m *NetStateRule) Reset()         { *m = NetStateRule{} }
func (m *NetStateRule) String() string { return proto.CompactTextString(m) }
func (*NetStateRule) ProtoMessage()    {}
func (*NetStateRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{9}
}
func (m *NetStateRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetStateRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetStateRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NetStateRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetStateRule.Merge(dst, src)
}
func (m *NetStateRule) XXX_Size() int {
	return m.Size()
}
func (m *NetStateRule) XXX_DiscardUnknown() {
	xxx_messageInfo_NetStateRule.DiscardUnknown(m)
}

var xxx_messageInfo_NetStateRule proto.InternalMessageInfo

func (m *NetStateRule) GetPhase() Phase {
	if m != nil {
		return m.Phase
	}
	return Phase_TRAIN
}

func (m *NetStateRule) GetMinLevel() int32 {
	if m != nil {
		return m.MinLevel
	}
	return 0
}

func (m *NetStateRule) GetMaxLevel() int32 {
	if m != nil {
		return m.MaxLevel
	}
	return 0
}

func (m *NetStateRule) GetStage() []string {
	if m != nil {
		return m.Stage
	}
	return nil
}

func (m *NetStateRule) GetNotStage() []string {
	if m != nil {
		return m.NotStage
	}
	return nil
}

// Specifies training parameters (multipliers on global learning constants,
// and the name and other settings used for weight sharing).
type ParamSpec struct {
	// The names of the parameter blobs -- useful for sharing parameters among
	// layers, but never required otherwise.  To share a parameter between two
	// layers, give it a (non-empty) name.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// Whether to require shared weights to have the same shape, or just the same
	// count -- defaults to STRICT if unspecified.
	ShareMode ParamSpec_DimCheckMode `protobuf:"varint,2,opt,name=share_mode,json=shareMode,enum=caffe.ParamSpec_DimCheckMode" json:"share_mode"`
	// The multiplier on the global learning rate for this parameter.
	LrMult *float32 `protobuf:"fixed32,3,opt,name=lr_mult,json=lrMult,def=1" json:"lr_mult,omitempty"`
	// The multiplier on the global weight decay for this parameter.
	DecayMult *float32 `protobuf:"fixed32,4,opt,name=decay_mult,json=decayMult,def=1" json:"decay_mult,omitempty"`
}

func (m *ParamSpec) Reset()         { *m = ParamSpec{} }
func (m *ParamSpec) String() string { return proto.CompactTextString(m) }
func (*ParamSpec) ProtoMessage()    {}
func (*ParamSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{10}
}
func (m *ParamSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParamSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParamSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ParamSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParamSpec.Merge(dst, src)
}
func (m *ParamSpec) XXX_Size() int {
	return m.Size()
}
func (m *ParamSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ParamSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ParamSpec proto.InternalMessageInfo

const Default_ParamSpec_LrMult float32 = 1
const Default_ParamSpec_DecayMult float32 = 1

func (m *ParamSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ParamSpec) GetShareMode() ParamSpec_DimCheckMode {
	if m != nil {
		return m.ShareMode
	}
	return ParamSpec_STRICT
}

func (m *ParamSpec) GetLrMult() float32 {
	if m != nil && m.LrMult != nil {
		return *m.LrMult
	}
	return Default_ParamSpec_LrMult
}

func (m *ParamSpec) GetDecayMult() float32 {
	if m != nil && m.DecayMult != nil {
		return *m.DecayMult
	}
	return Default_ParamSpec_DecayMult
}

// NOTE
// Update the next available ID when you add a new LayerParameter field.
//
// LayerParameter next available layer-specific ID: 147 (last added: recurrent_param)
type LayerParameter struct {
	Name   string   `protobuf:"bytes,1,opt,name=name" json:"name"`
	Type   string   `protobuf:"bytes,2,opt,name=type" json:"type"`
	Bottom []string `protobuf:"bytes,3,rep,name=bottom" json:"bottom,omitempty"`
	Top    []string `protobuf:"bytes,4,rep,name=top" json:"top,omitempty"`
	// The train / test phase for computation.
	Phase Phase `protobuf:"varint,10,opt,name=phase,enum=caffe.Phase" json:"phase"`
	// The amount of weight to assign each top blob in the objective.
	// Each layer assigns a default value, usually of either 0 or 1,
	// to each top blob.
	LossWeight []float32 `protobuf:"fixed32,5,rep,name=loss_weight,json=lossWeight" json:"loss_weight,omitempty"`
	// Specifies training parameters (multipliers on global learning constants,
	// and the name and other settings used for weight sharing).
	Param []*ParamSpec `protobuf:"bytes,6,rep,name=param" json:"param,omitempty"`
	// The blobs containing the numeric parameters of the layer.
	Blobs []*BlobProto `protobuf:"bytes,7,rep,name=blobs" json:"blobs,omitempty"`
	// Specifies whether to backpropagate to each bottom. If unspecified,
	// Caffe will automatically infer whether each input needs backpropagation
	// to compute parameter gradients. If set to true for some inputs,
	// backpropagation to those inputs is forced; if set false for some inputs,
	// backpropagation to those inputs is skipped.
	//
	// The size must be either 0 or equal to the number of bottoms.
	PropagateDown []bool `protobuf:"varint,11,rep,name=propagate_down,json=propagateDown" json:"propagate_down,omitempty"`
	// Rules controlling whether and when a layer is included in the network,
	// based on the current NetState.  You may specify a non-zero number of rules
	// to include OR exclude, but not both.  If no include or exclude rules are
	// specified, the layer is always included.  If the current NetState meets
	// ANY (i.e., one or more) of the specified rules, the layer is
	// included/excluded.
	Include []*NetStateRule `protobuf:"bytes,8,rep,name=include" json:"include,omitempty"`
	Exclude []*NetStateRule `protobuf:"bytes,9,rep,name=exclude" json:"exclude,omitempty"`
	// Parameters for data pre-processing.
	TransformParam *TransformationParameter `protobuf:"bytes,100,opt,name=transform_param,json=transformParam" json:"transform_param,omitempty"`
	// Parameters shared by loss layers.
	LossParam *LossParameter `protobuf:"bytes,101,opt,name=loss_param,json=lossParam" json:"loss_param,omitempty"`
	// Layer type-specific parameters.
	//
	// Note: certain layers may have more than one computational engine
	// for their implementation. These layers include an Engine type and
	// engine parameter for selecting the implementation.
	// The default for the engine is set by the ENGINE switch at compile-time.
	AccuracyParam        *AccuracyParameter        `protobuf:"bytes,102,opt,name=accuracy_param,json=accuracyParam" json:"accuracy_param,omitempty"`
	ArgmaxParam          *ArgMaxParameter          `protobuf:"bytes,103,opt,name=argmax_param,json=argmaxParam" json:"argmax_param,omitempty"`
	BatchNormParam       *BatchNormParameter       `protobuf:"bytes,139,opt,name=batch_norm_param,json=batchNormParam" json:"batch_norm_param,omitempty"`
	BiasParam            *BiasParameter            `protobuf:"bytes,141,opt,name=bias_param,json=biasParam" json:"bias_param,omitempty"`
	ConcatParam          *ConcatParameter          `protobuf:"bytes,104,opt,name=concat_param,json=concatParam" json:"concat_param,omitempty"`
	ContrastiveLossParam *ContrastiveLossParameter `protobuf:"bytes,105,opt,name=contrastive_loss_param,json=contrastiveLossParam" json:"contrastive_loss_param,omitempty"`
	ConvolutionParam     *ConvolutionParameter     `protobuf:"bytes,106,opt,name=convolution_param,json=convolutionParam" json:"convolution_param,omitempty"`
	CropParam            *CropParameter            `protobuf:"bytes,144,opt,name=crop_param,json=cropParam" json:"crop_param,omitempty"`
	DataParam            *DataParameter            `protobuf:"bytes,107,opt,name=data_param,json=dataParam" json:"data_param,omitempty"`
	DropoutParam         *DropoutParameter         `protobuf:"bytes,108,opt,name=dropout_param,json=dropoutParam" json:"dropout_param,omitempty"`
	DummyDataParam       *DummyDataParameter       `protobuf:"bytes,109,opt,name=dummy_data_param,json=dummyDataParam" json:"dummy_data_param,omitempty"`
	EltwiseParam         *EltwiseParameter         `protobuf:"bytes,110,opt,name=eltwise_param,json=eltwiseParam" json:"eltwise_param,omitempty"`
	EluParam             *ELUParameter             `protobuf:"bytes,140,opt,name=elu_param,json=eluParam" json:"elu_param,omitempty"`
	EmbedParam           *EmbedParameter           `protobuf:"bytes,137,opt,name=embed_param,json=embedParam" json:"embed_param,omitempty"`
	ExpParam             *ExpParameter             `protobuf:"bytes,111,opt,name=exp_param,json=expParam" json:"exp_param,omitempty"`
	FlattenParam         *FlattenParameter         `protobuf:"bytes,135,opt,name=flatten_param,json=flattenParam" json:"flatten_param,omitempty"`
	Hdf5DataParam        *HDF5DataParameter        `protobuf:"bytes,112,opt,name=hdf5_data_param,json=hdf5DataParam" json:"hdf5_data_param,omitempty"`
	Hdf5OutputParam      *HDF5OutputParameter      `protobuf:"bytes,113,opt,name=hdf5_output_param,json=hdf5OutputParam" json:"hdf5_output_param,omitempty"`
	HingeLossParam       *HingeLossParameter       `protobuf:"bytes,114,opt,name=hinge_loss_param,json=hingeLossParam" json:"hinge_loss_param,omitempty"`
	ImageDataParam       *ImageDataParameter       `protobuf:"bytes,115,opt,name=image_data_param,json=imageDataParam" json:"image_data_param,omitempty"`
	InfogainLossParam    *InfogainLossParameter    `protobuf:"bytes,116,opt,name=infogain_loss_param,json=infogainLossParam" json:"infogain_loss_param,omitempty"`
	InnerProductParam    *InnerProductParameter    `protobuf:"bytes,117,opt,name=inner_product_param,json=innerProductParam" json:"inner_product_param,omitempty"`
	InputParam           *InputParameter           `protobuf:"bytes,143,opt,name=input_param,json=inputParam" json:"input_param,omitempty"`
	LogParam             *LogParameter             `protobuf:"bytes,134,opt,name=log_param,json=logParam" json:"log_param,omitempty"`
	LrnParam             *LRNParameter             `protobuf:"bytes,118,opt,name=lrn_param,json=lrnParam" json:"lrn_param,omitempty"`
	MemoryDataParam      *MemoryDataParameter      `protobuf:"bytes,119,opt,name=memory_data_param,json=memoryDataParam" json:"memory_data_param,omitempty"`
	MvnParam             *MVNParameter             `protobuf:"bytes,120,opt,name=mvn_param,json=mvnParam" json:"mvn_param,omitempty"`
	ParameterParam       *ParameterParameter       `protobuf:"bytes,145,opt,name=parameter_param,json=parameterParam" json:"parameter_param,omitempty"`
	PoolingParam         *PoolingParameter         `protobuf:"bytes,121,opt,name=pooling_param,json=poolingParam" json:"pooling_param,omitempty"`
	PowerParam           *PowerParameter           `protobuf:"bytes,122,opt,name=power_param,json=powerParam" json:"power_param,omitempty"`
	PreluParam           *PReLUParameter           `protobuf:"bytes,131,opt,name=prelu_param,json=preluParam" json:"prelu_param,omitempty"`
	PythonParam          *PythonParameter          `protobuf:"bytes,130,opt,name=python_param,json=pythonParam" json:"python_param,omitempty"`
	RecurrentParam       *RecurrentParameter       `protobuf:"bytes,146,opt,name=recurrent_param,json=recurrentParam" json:"recurrent_param,omitempty"`
	ReductionParam       *ReductionParameter       `protobuf:"bytes,136,opt,name=reduction_param,json=reductionParam" json:"reduction_param,omitempty"`
	ReluParam            *ReLUParameter            `protobuf:"bytes,123,opt,name=relu_param,json=reluParam" json:"relu_param,omitempty"`
	ReshapeParam         *ReshapeParameter         `protobuf:"bytes,133,opt,name=reshape_param,json=reshapeParam" json:"reshape_param,omitempty"`
	ScaleParam           *ScaleParameter           `protobuf:"bytes,142,opt,name=scale_param,json=scaleParam" json:"scale_param,omitempty"`
	SigmoidParam         *SigmoidParameter         `protobuf:"bytes,124,opt,name=sigmoid_param,json=sigmoidParam" json:"sigmoid_param,omitempty"`
	SoftmaxParam         *SoftmaxParameter         `protobuf:"bytes,125,opt,name=softmax_param,json=softmaxParam" json:"softmax_param,omitempty"`
	SppParam             *SPPParameter             `protobuf:"bytes,132,opt,name=spp_param,json=sppParam" json:"spp_param,omitempty"`
	SliceParam           *SliceParameter           `protobuf:"bytes,126,opt,name=slice_param,json=sliceParam" json:"slice_param,omitempty"`
	TanhParam            *TanHParameter            `protobuf:"bytes,127,opt,name=tanh_param,json=tanhParam" json:"tanh_param,omitempty"`
	ThresholdParam       *ThresholdParameter       `protobuf:"bytes,128,opt,name=threshold_param,json=thresholdParam" json:"threshold_param,omitempty"`
	TileParam            *TileParameter            `protobuf:"bytes,138,opt,name=tile_param,json=tileParam" json:"tile_param,omitempty"`
	WindowDataParam      *WindowDataParameter      `protobuf:"bytes,129,opt,name=window_data_param,json=windowDataParam" json:"window_data_param,omitempty"`
}

func (m *LayerParameter) Reset()         { *m = LayerParameter{} }
func (m *LayerParameter) String() string { return proto.CompactTextString(m) }
func (*LayerParameter) ProtoMessage()    {}
func (*LayerParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{11}
}
func (m *LayerParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LayerParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LayerParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LayerParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LayerParameter.Merge(dst, src)
}
func (m *LayerParameter) XXX_Size() int {
	return m.Size()
}
func (m *LayerParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_LayerParameter.DiscardUnknown(m)
}

var xxx_messageInfo_LayerParameter proto.InternalMessageInfo

func (m *LayerParameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LayerParameter) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LayerParameter) GetBottom() []string {
	if m != nil {
		return m.Bottom
	}
	return nil
}

func (m *LayerParameter) GetTop() []string {
	if m != nil {
		return m.Top
	}
	return nil
}

func (m *LayerParameter) GetPhase() Phase {
	if m != nil {
		return m.Phase
	}
	return Phase_TRAIN
}

func (m *LayerParameter) GetLossWeight() []float32 {
	if m != nil {
		return m.LossWeight
	}
	return nil
}

func (m *LayerParameter) GetParam() []*ParamSpec {
	if m != nil {
		return m.Param
	}
	return nil
}

func (m *LayerParameter) GetBlobs() []*BlobProto {
	if m != nil {
		return m.Blobs
	}
	return nil
}

func (m *LayerParameter) GetPropagateDown() []bool {
	if m != nil {
		return m.PropagateDown
	}
	return nil
}

func (m *LayerParameter) GetInclude() []*NetStateRule {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *LayerParameter) GetExclude() []*NetStateRule {
	if m != nil {
		return m.Exclude
	}
	return nil
}

func (m *LayerParameter) GetTransformParam() *TransformationParameter {
	if m != nil {
		return m.TransformParam
	}
	return nil
}

func (m *LayerParameter) GetLossParam() *LossParameter {
	if m != nil {
		return m.LossParam
	}
	return nil
}

func (m *LayerParameter) GetAccuracyParam() *AccuracyParameter {
	if m != nil {
		return m.AccuracyParam
	}
	return nil
}

func (m *LayerParameter) GetArgmaxParam() *ArgMaxParameter {
	if m != nil {
		return m.ArgmaxParam
	}
	return nil
}

func (m *LayerParameter) GetBatchNormParam() *BatchNormParameter {
	if m != nil {
		return m.BatchNormParam
	}
	return nil
}

func (m *LayerParameter) GetBiasParam() *BiasParameter {
	if m != nil {
		return m.BiasParam
	}
	return nil
}

func (m *LayerParameter) GetConcatParam() *ConcatParameter {
	if m != nil {
		return m.ConcatParam
	}
	return nil
}

func (m *LayerParameter) GetContrastiveLossParam() *ContrastiveLossParameter {
	if m != nil {
		return m.ContrastiveLossParam
	}
	return nil
}

func (m *LayerParameter) GetConvolutionParam() *ConvolutionParameter {
	if m != nil {
		return m.ConvolutionParam
	}
	return nil
}

func (m *LayerParameter) GetCropParam() *CropParameter {
	if m != nil {
		return m.CropParam
	}
	return nil
}

func (m *LayerParameter) GetDataParam() *DataParameter {
	if m != nil {
		return m.DataParam
	}
	return nil
}

func (m *LayerParameter) GetDropoutParam() *DropoutParameter {
	if m != nil {
		return m.DropoutParam
	}
	return nil
}

func (m *LayerParameter) GetDummyDataParam() *DummyDataParameter {
	if m != nil {
		return m.DummyDataParam
	}
	return nil
}

func (m *LayerParameter) GetEltwiseParam() *EltwiseParameter {
	if m != nil {
		return m.EltwiseParam
	}
	return nil
}

func (m *LayerParameter) GetEluParam() *ELUParameter {
	if m != nil {
		return m.EluParam
	}
	return nil
}

func (m *LayerParameter) GetEmbedParam() *EmbedParameter {
	if m != nil {
		return m.EmbedParam
	}
	return nil
}

func (m *LayerParameter) GetExpParam() *ExpParameter {
	if m != nil {
		return m.ExpParam
	}
	return nil
}

func (m *LayerParameter) GetFlattenParam() *FlattenParameter {
	if m != nil {
		return m.FlattenParam
	}
	return nil
}

func (m *LayerParameter) GetHdf5DataParam() *HDF5DataParameter {
	if m != nil {
		return m.Hdf5DataParam
	}
	return nil
}

func (m *LayerParameter) GetHdf5OutputParam() *HDF5OutputParameter {
	if m != nil {
		return m.Hdf5OutputParam
	}
	return nil
}

func (m *LayerParameter) GetHingeLossParam() *HingeLossParameter {
	if m != nil {
		return m.HingeLossParam
	}
	return nil
}

func (m *LayerParameter) GetImageDataParam() *ImageDataParameter {
	if m != nil {
		return m.ImageDataParam
	}
	return nil
}

func (m *LayerParameter) GetInfogainLossParam() *InfogainLossParameter {
	if m != nil {
		return m.InfogainLossParam
	}
	return nil
}

func (m *LayerParameter) GetInnerProductParam() *InnerProductParameter {
	if m != nil {
		return m.InnerProductParam
	}
	return nil
}

func (m *LayerParameter) GetInputParam() *InputParameter {
	if m != nil {
		return m.InputParam
	}
	return nil
}

func (m *LayerParameter) GetLogParam() *LogParameter {
	if m != nil {
		return m.LogParam
	}
	return nil
}

func (m *LayerParameter) GetLrnParam() *LRNParameter {
	if m != nil {
		return m.LrnParam
	}
	return nil
}

func (m *LayerParameter) GetMemoryDataParam() *MemoryDataParameter {
	if m != nil {
		return m.MemoryDataParam
	}
	return nil
}

func (m *LayerParameter) GetMvnParam() *MVNParameter {
	if m != nil {
		return m.MvnParam
	}
	return nil
}

func (m *LayerParameter) GetParameterParam() *ParameterParameter {
	if m != nil {
		return m.ParameterParam
	}
	return nil
}

func (m *LayerParameter) GetPoolingParam() *PoolingParameter {
	if m != nil {
		return m.PoolingParam
	}
	return nil
}

func (m *LayerParameter) GetPowerParam() *PowerParameter {
	if m != nil {
		return m.PowerParam
	}
	return nil
}

func (m *LayerParameter) GetPreluParam() *PReLUParameter {
	if m != nil {
		return m.PreluParam
	}
	return nil
}

func (m *LayerParameter) GetPythonParam() *PythonParameter {
	if m != nil {
		return m.PythonParam
	}
	return nil
}

func (m *LayerParameter) GetRecurrentParam() *RecurrentParameter {
	if m != nil {
		return m.RecurrentParam
	}
	return nil
}

func (m *LayerParameter) GetReductionParam() *ReductionParameter {
	if m != nil {
		return m.ReductionParam
	}
	return nil
}

func (m *LayerParameter) GetReluParam() *ReLUParameter {
	if m != nil {
		return m.ReluParam
	}
	return nil
}

func (m *LayerParameter) GetReshapeParam() *ReshapeParameter {
	if m != nil {
		return m.ReshapeParam
	}
	return nil
}

func (m *LayerParameter) GetScaleParam() *ScaleParameter {
	if m != nil {
		return m.ScaleParam
	}
	return nil
}

func (m *LayerParameter) GetSigmoidParam() *SigmoidParameter {
	if m != nil {
		return m.SigmoidParam
	}
	return nil
}

func (m *LayerParameter) GetSoftmaxParam() *SoftmaxParameter {
	if m != nil {
		return m.SoftmaxParam
	}
	return nil
}

func (m *LayerParameter) GetSppParam() *SPPParameter {
	if m != nil {
		return m.SppParam
	}
	return nil
}

func (m *LayerParameter) GetSliceParam() *SliceParameter {
	if m != nil {
		return m.SliceParam
	}
	return nil
}

func (m *LayerParameter) GetTanhParam() *TanHParameter {
	if m != nil {
		return m.TanhParam
	}
	return nil
}

func (m *LayerParameter) GetThresholdParam() *ThresholdParameter {
	if m != nil {
		return m.ThresholdParam
	}
	return nil
}

func (m *LayerParameter) GetTileParam() *TileParameter {
	if m != nil {
		return m.TileParam
	}
	return nil
}

func (m *LayerParameter) GetWindowDataParam() *WindowDataParameter {
	if m != nil {
		return m.WindowDataParam
	}
	return nil
}

// Message that stores parameters used to apply transformation
// to the data layer's data
type TransformationParameter struct {
	// For data pre-processing, we can do simple scaling and subtracting the
	// data mean, if provided. Note that the mean subtraction is always carried
	// out before scaling.
	Scale *float32 `protobuf:"fixed32,1,opt,name=scale,def=1" json:"scale,omitempty"`
	// Specify if we want to randomly mirror data.
	Mirror *bool `protobuf:"varint,2,opt,name=mirror,def=0" json:"mirror,omitempty"`
	// Specify if we would like to randomly crop an image.
	CropSize *uint32 `protobuf:"varint,3,opt,name=crop_size,json=cropSize,def=0" json:"crop_size,omitempty"`
	// mean_file and mean_value cannot be specified at the same time
	MeanFile string `protobuf:"bytes,4,opt,name=mean_file,json=meanFile" json:"mean_file"`
	// if specified can be repeated once (would subtract it from all the channels)
	// or can be repeated the same number of times as channels
	// (would subtract them from the corresponding channel)
	MeanValue []float32 `protobuf:"fixed32,5,rep,name=mean_value,json=meanValue" json:"mean_value,omitempty"`
	// Force the decoded image to have 3 color channels.
	ForceColor *bool `protobuf:"varint,6,opt,name=force_color,json=forceColor,def=0" json:"force_color,omitempty"`
	// Force the decoded image to have 1 color channels.
	ForceGray *bool `protobuf:"varint,7,opt,name=force_gray,json=forceGray,def=0" json:"force_gray,omitempty"`
}

func (m *TransformationParameter) Reset()         { *m = TransformationParameter{} }
func (m *TransformationParameter) String() string { return proto.CompactTextString(m) }
func (*TransformationParameter) ProtoMessage()    {}
func (*TransformationParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{12}
}
func (m *TransformationParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransformationParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransformationParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TransformationParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransformationParameter.Merge(dst, src)
}
func (m *TransformationParameter) XXX_Size() int {
	return m.Size()
}
func (m *TransformationParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_TransformationParameter.DiscardUnknown(m)
}

var xxx_messageInfo_TransformationParameter proto.InternalMessageInfo

const Default_TransformationParameter_Scale float32 = 1
const Default_TransformationParameter_Mirror bool = false
const Default_TransformationParameter_CropSize uint32 = 0
const Default_TransformationParameter_ForceColor bool = false
const Default_TransformationParameter_ForceGray bool = false

func (m *TransformationParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_TransformationParameter_Scale
}

func (m *TransformationParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_TransformationParameter_Mirror
}

func (m *TransformationParameter) GetCropSize() uint32 {
	if m != nil && m.CropSize != nil {
		return *m.CropSize
	}
	return Default_TransformationParameter_CropSize
}

func (m *TransformationParameter) GetMeanFile() string {
	if m != nil {
		return m.MeanFile
	}
	return ""
}

func (m *TransformationParameter) GetMeanValue() []float32 {
	if m != nil {
		return m.MeanValue
	}
	return nil
}

func (m *TransformationParameter) GetForceColor() bool {
	if m != nil && m.ForceColor != nil {
		return *m.ForceColor
	}
	return Default_TransformationParameter_ForceColor
}

func (m *TransformationParameter) GetForceGray() bool {
	if m != nil && m.ForceGray != nil {
		return *m.ForceGray
	}
	return Default_TransformationParameter_ForceGray
}

// Message that stores parameters shared by loss layers
type LossParameter struct {
	// If specified, ignore instances with the given label.
	IgnoreLabel   int32                            `protobuf:"varint,1,opt,name=ignore_label,json=ignoreLabel" json:"ignore_label"`
	Normalization *LossParameter_NormalizationMode `protobuf:"varint,3,opt,name=normalization,enum=caffe.LossParameter_NormalizationMode,def=1" json:"normalization,omitempty"`
	// Deprecated.  Ignored if normalization is specified.  If normalization
	// is not specified, then setting this to false will be equivalent to
	// normalization = BATCH_SIZE to be consistent with previous behavior.
	Normalize bool `protobuf:"varint,2,opt,name=normalize" json:"normalize"`
}

func (m *LossParameter) Reset()         { *m = LossParameter{} }
func (m *LossParameter) String() string { return proto.CompactTextString(m) }
func (*LossParameter) ProtoMessage()    {}
func (*LossParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{13}
}
func (m *LossParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LossParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LossParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LossParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LossParameter.Merge(dst, src)
}
func (m *LossParameter) XXX_Size() int {
	return m.Size()
}
func (m *LossParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_LossParameter.DiscardUnknown(m)
}

var xxx_messageInfo_LossParameter proto.InternalMessageInfo

const Default_LossParameter_Normalization LossParameter_NormalizationMode = LossParameter_VALID

func (m *LossParameter) GetIgnoreLabel() int32 {
	if m != nil {
		return m.IgnoreLabel
	}
	return 0
}

func (m *LossParameter) GetNormalization() LossParameter_NormalizationMode {
	if m != nil && m.Normalization != nil {
		return *m.Normalization
	}
	return Default_LossParameter_Normalization
}

func (m *LossParameter) GetNormalize() bool {
	if m != nil {
		return m.Normalize
	}
	return false
}

type AccuracyParameter struct {
	// When computing accuracy, count as correct by comparing the true label to
	// the top k scoring classes.  By default, only compare to the top scoring
	// class (i.e. argmax).
	TopK *uint32 `protobuf:"varint,1,opt,name=top_k,json=topK,def=1" json:"top_k,omitempty"`
	// The "label" axis of the prediction blob, whose argmax corresponds to the
	// predicted label -- may be negative to index from the end (e.g., -1 for the
	// last axis).  For example, if axis == 1 and the predictions are
	// (N x C x H x W), the label blob is expected to contain N*H*W ground truth
	// labels with integer values in {0, 1, ..., C-1}.
	Axis *int32 `protobuf:"varint,2,opt,name=axis,def=1" json:"axis,omitempty"`
	// If specified, ignore instances with the given label.
	IgnoreLabel int32 `protobuf:"varint,3,opt,name=ignore_label,json=ignoreLabel" json:"ignore_label"`
}

func (m *AccuracyParameter) Reset()         { *m = AccuracyParameter{} }
func (m *AccuracyParameter) String() string { return proto.CompactTextString(m) }
func (*AccuracyParameter) ProtoMessage()    {}
func (*AccuracyParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{14}
}
func (m *AccuracyParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccuracyParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccuracyParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AccuracyParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccuracyParameter.Merge(dst, src)
}
func (m *AccuracyParameter) XXX_Size() int {
	return m.Size()
}
func (m *AccuracyParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_AccuracyParameter.DiscardUnknown(m)
}

var xxx_messageInfo_AccuracyParameter proto.InternalMessageInfo

const Default_AccuracyParameter_TopK uint32 = 1
const Default_AccuracyParameter_Axis int32 = 1

func (m *AccuracyParameter) GetTopK() uint32 {
	if m != nil && m.TopK != nil {
		return *m.TopK
	}
	return Default_AccuracyParameter_TopK
}

func (m *AccuracyParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_AccuracyParameter_Axis
}

func (m *AccuracyParameter) GetIgnoreLabel() int32 {
	if m != nil {
		return m.IgnoreLabel
	}
	return 0
}

type ArgMaxParameter struct {
	// If true produce pairs (argmax, maxval)
	OutMaxVal *bool   `protobuf:"varint,1,opt,name=out_max_val,json=outMaxVal,def=0" json:"out_max_val,omitempty"`
	TopK      *uint32 `protobuf:"varint,2,opt,name=top_k,json=topK,def=1" json:"top_k,omitempty"`
	// The axis along which to maximise -- may be negative to index from the
	// end (e.g., -1 for the last axis).
	// By default ArgMaxLayer maximizes over the flattened trailing dimensions
	// for each index of the first / num dimension.
	Axis int32 `protobuf:"varint,3,opt,name=axis" json:"axis"`
}

func (m *ArgMaxParameter) Reset()         { *m = ArgMaxParameter{} }
func (m *ArgMaxParameter) String() string { return proto.CompactTextString(m) }
func (*ArgMaxParameter) ProtoMessage()    {}
func (*ArgMaxParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{15}
}
func (m *ArgMaxParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgMaxParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgMaxParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ArgMaxParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgMaxParameter.Merge(dst, src)
}
func (m *ArgMaxParameter) XXX_Size() int {
	return m.Size()
}
func (m *ArgMaxParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgMaxParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ArgMaxParameter proto.InternalMessageInfo

const Default_ArgMaxParameter_OutMaxVal bool = false
const Default_ArgMaxParameter_TopK uint32 = 1

func (m *ArgMaxParameter) GetOutMaxVal() bool {
	if m != nil && m.OutMaxVal != nil {
		return *m.OutMaxVal
	}
	return Default_ArgMaxParameter_OutMaxVal
}

func (m *ArgMaxParameter) GetTopK() uint32 {
	if m != nil && m.TopK != nil {
		return *m.TopK
	}
	return Default_ArgMaxParameter_TopK
}

func (m *ArgMaxParameter) GetAxis() int32 {
	if m != nil {
		return m.Axis
	}
	return 0
}

type ConcatParameter struct {
	// The axis along which to concatenate -- may be negative to index from the
	// end (e.g., -1 for the last axis).  Other axes must have the
	// same dimension for all the bottom blobs.
	// By default, ConcatLayer concatenates blobs along the "channels" axis (1).
	Axis *int32 `protobuf:"varint,2,opt,name=axis,def=1" json:"axis,omitempty"`
	// DEPRECATED: alias for "axis" -- does not support negative indexing.
	ConcatDim *uint32 `protobuf:"varint,1,opt,name=concat_dim,json=concatDim,def=1" json:"concat_dim,omitempty"`
}

func (m *ConcatParameter) Reset()         { *m = ConcatParameter{} }
func (m *ConcatParameter) String() string { return proto.CompactTextString(m) }
func (*ConcatParameter) ProtoMessage()    {}
func (*ConcatParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{16}
}
func (m *ConcatParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConcatParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConcatParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConcatParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConcatParameter.Merge(dst, src)
}
func (m *ConcatParameter) XXX_Size() int {
	return m.Size()
}
func (m *ConcatParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ConcatParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ConcatParameter proto.InternalMessageInfo

const Default_ConcatParameter_Axis int32 = 1
const Default_ConcatParameter_ConcatDim uint32 = 1

func (m *ConcatParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_ConcatParameter_Axis
}

func (m *ConcatParameter) GetConcatDim() uint32 {
	if m != nil && m.ConcatDim != nil {
		return *m.ConcatDim
	}
	return Default_ConcatParameter_ConcatDim
}

type BatchNormParameter struct {
	// If false, accumulate global mean/variance values via a moving average. If
	// true, use those accumulated values instead of computing mean/variance
	// across the batch.
	UseGlobalStats bool `protobuf:"varint,1,opt,name=use_global_stats,json=useGlobalStats" json:"use_global_stats"`
	// How much does the moving average decay each iteration?
	MovingAverageFraction *float32 `protobuf:"fixed32,2,opt,name=moving_average_fraction,json=movingAverageFraction,def=0.999" json:"moving_average_fraction,omitempty"`
	// Small value to add to the variance estimate so that we don't divide by
	// zero.
	Eps *float32 `protobuf:"fixed32,3,opt,name=eps,def=1e-05" json:"eps,omitempty"`
}

func (m *BatchNormParameter) Reset()         { *m = BatchNormParameter{} }
func (m *BatchNormParameter) String() string { return proto.CompactTextString(m) }
func (*BatchNormParameter) ProtoMessage()    {}
func (*BatchNormParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{17}
}
func (m *BatchNormParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchNormParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchNormParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BatchNormParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchNormParameter.Merge(dst, src)
}
func (m *BatchNormParameter) XXX_Size() int {
	return m.Size()
}
func (m *BatchNormParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchNormParameter.DiscardUnknown(m)
}

var xxx_messageInfo_BatchNormParameter proto.InternalMessageInfo

const Default_BatchNormParameter_MovingAverageFraction float32 = 0.999
const Default_BatchNormParameter_Eps float32 = 1e-05

func (m *BatchNormParameter) GetUseGlobalStats() bool {
	if m != nil {
		return m.UseGlobalStats
	}
	return false
}

func (m *BatchNormParameter) GetMovingAverageFraction() float32 {
	if m != nil && m.MovingAverageFraction != nil {
		return *m.MovingAverageFraction
	}
	return Default_BatchNormParameter_MovingAverageFraction
}

func (m *BatchNormParameter) GetEps() float32 {
	if m != nil && m.Eps != nil {
		return *m.Eps
	}
	return Default_BatchNormParameter_Eps
}

type BiasParameter struct {
	// The first axis of bottom[0] (the first input Blob) along which to apply
	// bottom[1] (the second input Blob).  May be negative to index from the end
	// (e.g., -1 for the last axis).
	//
	// For example, if bottom[0] is 4D with shape 100x3x40x60, the output
	// top[0] will have the same shape, and bottom[1] may have any of the
	// following shapes (for the given value of axis):
	//    (axis == 0 == -4) 100; 100x3; 100x3x40; 100x3x40x60
	//    (axis == 1 == -3)          3;     3x40;     3x40x60
	//    (axis == 2 == -2)                   40;       40x60
	//    (axis == 3 == -1)                                60
	// Furthermore, bottom[1] may have the empty shape (regardless of the value of
	// "axis") -- a scalar bias.
	Axis *int32 `protobuf:"varint,1,opt,name=axis,def=1" json:"axis,omitempty"`
	// (num_axes is ignored unless just one bottom is given and the bias is
	// a learned parameter of the layer.  Otherwise, num_axes is determined by the
	// number of axes by the second bottom.)
	// The number of axes of the input (bottom[0]) covered by the bias
	// parameter, or -1 to cover all axes of bottom[0] starting from `axis`.
	// Set num_axes := 0, to add a zero-axis Blob: a scalar.
	NumAxes *int32 `protobuf:"varint,2,opt,name=num_axes,json=numAxes,def=1" json:"num_axes,omitempty"`
	// (filler is ignored unless just one bottom is given and the bias is
	// a learned parameter of the layer.)
	// The initialization for the learned bias parameter.
	// Default is the zero (0) initialization, resulting in the BiasLayer
	// initially performing the identity operation.
	Filler *FillerParameter `protobuf:"bytes,3,opt,name=filler" json:"filler,omitempty"`
}

func (m *BiasParameter) Reset()         { *m = BiasParameter{} }
func (m *BiasParameter) String() string { return proto.CompactTextString(m) }
func (*BiasParameter) ProtoMessage()    {}
func (*BiasParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{18}
}
func (m *BiasParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BiasParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BiasParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BiasParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BiasParameter.Merge(dst, src)
}
func (m *BiasParameter) XXX_Size() int {
	return m.Size()
}
func (m *BiasParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_BiasParameter.DiscardUnknown(m)
}

var xxx_messageInfo_BiasParameter proto.InternalMessageInfo

const Default_BiasParameter_Axis int32 = 1
const Default_BiasParameter_NumAxes int32 = 1

func (m *BiasParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_BiasParameter_Axis
}

func (m *BiasParameter) GetNumAxes() int32 {
	if m != nil && m.NumAxes != nil {
		return *m.NumAxes
	}
	return Default_BiasParameter_NumAxes
}

func (m *BiasParameter) GetFiller() *FillerParameter {
	if m != nil {
		return m.Filler
	}
	return nil
}

type ContrastiveLossParameter struct {
	// margin for dissimilar pair
	Margin *float32 `protobuf:"fixed32,1,opt,name=margin,def=1" json:"margin,omitempty"`
	// The first implementation of this cost did not exactly match the cost of
	// Hadsell et al 2006 -- using (margin - d^2) instead of (margin - d)^2.
	// legacy_version = false (the default) uses (margin - d)^2 as proposed in the
	// Hadsell paper. New models should probably use this version.
	// legacy_version = true uses (margin - d^2). This is kept to support /
	// reproduce existing models and results
	LegacyVersion *bool `protobuf:"varint,2,opt,name=legacy_version,json=legacyVersion,def=0" json:"legacy_version,omitempty"`
}

func (m *ContrastiveLossParameter) Reset()         { *m = ContrastiveLossParameter{} }
func (m *ContrastiveLossParameter) String() string { return proto.CompactTextString(m) }
func (*ContrastiveLossParameter) ProtoMessage()    {}
func (*ContrastiveLossParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{19}
}
func (m *ContrastiveLossParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContrastiveLossParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContrastiveLossParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ContrastiveLossParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContrastiveLossParameter.Merge(dst, src)
}
func (m *ContrastiveLossParameter) XXX_Size() int {
	return m.Size()
}
func (m *ContrastiveLossParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ContrastiveLossParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ContrastiveLossParameter proto.InternalMessageInfo

const Default_ContrastiveLossParameter_Margin float32 = 1
const Default_ContrastiveLossParameter_LegacyVersion bool = false

func (m *ContrastiveLossParameter) GetMargin() float32 {
	if m != nil && m.Margin != nil {
		return *m.Margin
	}
	return Default_ContrastiveLossParameter_Margin
}

func (m *ContrastiveLossParameter) GetLegacyVersion() bool {
	if m != nil && m.LegacyVersion != nil {
		return *m.LegacyVersion
	}
	return Default_ContrastiveLossParameter_LegacyVersion
}

type ConvolutionParameter struct {
	NumOutput uint32 `protobuf:"varint,1,opt,name=num_output,json=numOutput" json:"num_output"`
	BiasTerm  *bool  `protobuf:"varint,2,opt,name=bias_term,json=biasTerm,def=1" json:"bias_term,omitempty"`
	// Pad, kernel size, and stride are all given as a single value for equal
	// dimensions in all spatial dimensions, or once per spatial dimension.
	Pad        []uint32 `protobuf:"varint,3,rep,name=pad" json:"pad,omitempty"`
	KernelSize []uint32 `protobuf:"varint,4,rep,name=kernel_size,json=kernelSize" json:"kernel_size,omitempty"`
	Stride     []uint32 `protobuf:"varint,6,rep,name=stride" json:"stride,omitempty"`
	// Factor used to dilate the kernel, (implicitly) zero-filling the resulting
	// holes. (Kernel dilation is sometimes referred to by its use in the
	// algorithme à trous from Holschneider et al. 1987.)
	Dilation []uint32 `protobuf:"varint,18,rep,name=dilation" json:"dilation,omitempty"`
	// For 2D convolution only, the *_h and *_w versions may also be used to
	// specify both spatial dimensions.
	PadH         *uint32                      `protobuf:"varint,9,opt,name=pad_h,json=padH,def=0" json:"pad_h,omitempty"`
	PadW         *uint32                      `protobuf:"varint,10,opt,name=pad_w,json=padW,def=0" json:"pad_w,omitempty"`
	KernelH      uint32                       `protobuf:"varint,11,opt,name=kernel_h,json=kernelH" json:"kernel_h"`
	KernelW      uint32                       `protobuf:"varint,12,opt,name=kernel_w,json=kernelW" json:"kernel_w"`
	StrideH      uint32                       `protobuf:"varint,13,opt,name=stride_h,json=strideH" json:"stride_h"`
	StrideW      uint32                       `protobuf:"varint,14,opt,name=stride_w,json=strideW" json:"stride_w"`
	Group        *uint32                      `protobuf:"varint,5,opt,name=group,def=1" json:"group,omitempty"`
	WeightFiller *FillerParameter             `protobuf:"bytes,7,opt,name=weight_filler,json=weightFiller" json:"weight_filler,omitempty"`
	BiasFiller   *FillerParameter             `protobuf:"bytes,8,opt,name=bias_filler,json=biasFiller" json:"bias_filler,omitempty"`
	Engine       *ConvolutionParameter_Engine `protobuf:"varint,15,opt,name=engine,enum=caffe.ConvolutionParameter_Engine,def=0" json:"engine,omitempty"`
	// The axis to interpret as "channels" when performing convolution.
	// Preceding dimensions are treated as independent inputs;
	// succeeding dimensions are treated as "spatial".
	// With (N, C, H, W) inputs, and axis == 1 (the default), we perform
	// N independent 2D convolutions, sliding C-channel (or (C/g)-channels, for
	// groups g>1) filters across the spatial axes (H, W) of the input.
	// With (N, C, D, H, W) inputs, and axis == 1, we perform
	// N independent 3D convolutions, sliding (C/g)-channels
	// filters across the spatial axes (D, H, W) of the input.
	Axis *int32 `protobuf:"varint,16,opt,name=axis,def=1" json:"axis,omitempty"`
	// Whether to force use of the general ND convolution, even if a specific
	// implementation for blobs of the appropriate number of spatial dimensions
	// is available. (Currently, there is only a 2D-specific convolution
	// implementation; for input blobs with num_axes != 2, this option is
	// ignored and the ND implementation will be used.)
	ForceNdIm2Col *bool `protobuf:"varint,17,opt,name=force_nd_im2col,json=forceNdIm2col,def=0" json:"force_nd_im2col,omitempty"`
}

func (m *ConvolutionParameter) Reset()         { *m = ConvolutionParameter{} }
func (m *ConvolutionParameter) String() string { return proto.CompactTextString(m) }
func (*ConvolutionParameter) ProtoMessage()    {}
func (*ConvolutionParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{20}
}
func (m *ConvolutionParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvolutionParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvolutionParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConvolutionParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvolutionParameter.Merge(dst, src)
}
func (m *ConvolutionParameter) XXX_Size() int {
	return m.Size()
}
func (m *ConvolutionParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvolutionParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ConvolutionParameter proto.InternalMessageInfo

const Default_ConvolutionParameter_BiasTerm bool = true
const Default_ConvolutionParameter_PadH uint32 = 0
const Default_ConvolutionParameter_PadW uint32 = 0
const Default_ConvolutionParameter_Group uint32 = 1
const Default_ConvolutionParameter_Engine ConvolutionParameter_Engine = ConvolutionParameter_DEFAULT
const Default_ConvolutionParameter_Axis int32 = 1
const Default_ConvolutionParameter_ForceNdIm2Col bool = false

func (m *ConvolutionParameter) GetNumOutput() uint32 {
	if m != nil {
		return m.NumOutput
	}
	return 0
}

func (m *ConvolutionParameter) GetBiasTerm() bool {
	if m != nil && m.BiasTerm != nil {
		return *m.BiasTerm
	}
	return Default_ConvolutionParameter_BiasTerm
}

func (m *ConvolutionParameter) GetPad() []uint32 {
	if m != nil {
		return m.Pad
	}
	return nil
}

func (m *ConvolutionParameter) GetKernelSize() []uint32 {
	if m != nil {
		return m.KernelSize
	}
	return nil
}

func (m *ConvolutionParameter) GetStride() []uint32 {
	if m != nil {
		return m.Stride
	}
	return nil
}

func (m *ConvolutionParameter) GetDilation() []uint32 {
	if m != nil {
		return m.Dilation
	}
	return nil
}

func (m *ConvolutionParameter) GetPadH() uint32 {
	if m != nil && m.PadH != nil {
		return *m.PadH
	}
	return Default_ConvolutionParameter_PadH
}

func (m *ConvolutionParameter) GetPadW() uint32 {
	if m != nil && m.PadW != nil {
		return *m.PadW
	}
	return Default_ConvolutionParameter_PadW
}

func (m *ConvolutionParameter) GetKernelH() uint32 {
	if m != nil {
		return m.KernelH
	}
	return 0
}

func (m *ConvolutionParameter) GetKernelW() uint32 {
	if m != nil {
		return m.KernelW
	}
	return 0
}

func (m *ConvolutionParameter) GetStrideH() uint32 {
	if m != nil {
		return m.StrideH
	}
	return 0
}

func (m *ConvolutionParameter) GetStrideW() uint32 {
	if m != nil {
		return m.StrideW
	}
	return 0
}

func (m *ConvolutionParameter) GetGroup() uint32 {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return Default_ConvolutionParameter_Group
}

func (m *ConvolutionParameter) GetWeightFiller() *FillerParameter {
	if m != nil {
		return m.WeightFiller
	}
	return nil
}

func (m *ConvolutionParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

func (m *ConvolutionParameter) GetEngine() ConvolutionParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_ConvolutionParameter_Engine
}

func (m *ConvolutionParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_ConvolutionParameter_Axis
}

func (m *ConvolutionParameter) GetForceNdIm2Col() bool {
	if m != nil && m.ForceNdIm2Col != nil {
		return *m.ForceNdIm2Col
	}
	return Default_ConvolutionParameter_ForceNdIm2Col
}

type CropParameter struct {
	// To crop, elements of the first bottom are selected to fit the dimensions
	// of the second, reference bottom. The crop is configured by
	// - the crop `axis` to pick the dimensions for cropping
	// - the crop `offset` to set the shift for all/each dimension
	// to align the cropped bottom with the reference bottom.
	// All dimensions up to but excluding `axis` are preserved, while
	// the dimensions including and trailing `axis` are cropped.
	// If only one `offset` is set, then all dimensions are offset by this amount.
	// Otherwise, the number of offsets must equal the number of cropped axes to
	// shift the crop in each dimension accordingly.
	// Note: standard dimensions are N,C,H,W so the default is a spatial crop,
	// and `axis` may be negative to index from the end (e.g., -1 for the last
	// axis).
	Axis   *int32   `protobuf:"varint,1,opt,name=axis,def=2" json:"axis,omitempty"`
	Offset []uint32 `protobuf:"varint,2,rep,name=offset" json:"offset,omitempty"`
}

func (m *CropParameter) Reset()         { *m = CropParameter{} }
func (m *CropParameter) String() string { return proto.CompactTextString(m) }
func (*CropParameter) ProtoMessage()    {}
func (*CropParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{21}
}
func (m *CropParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CropParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CropParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CropParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CropParameter.Merge(dst, src)
}
func (m *CropParameter) XXX_Size() int {
	return m.Size()
}
func (m *CropParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_CropParameter.DiscardUnknown(m)
}

var xxx_messageInfo_CropParameter proto.InternalMessageInfo

const Default_CropParameter_Axis int32 = 2

func (m *CropParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_CropParameter_Axis
}

func (m *CropParameter) GetOffset() []uint32 {
	if m != nil {
		return m.Offset
	}
	return nil
}

type DataParameter struct {
	// Specify the data source.
	Source string `protobuf:"bytes,1,opt,name=source" json:"source"`
	// Specify the batch size.
	BatchSize uint32 `protobuf:"varint,4,opt,name=batch_size,json=batchSize" json:"batch_size"`
	// The rand_skip variable is for the data layer to skip a few data points
	// to avoid all asynchronous sgd clients to start at the same point. The skip
	// point would be set as rand_skip * rand(0,1). Note that rand_skip should not
	// be larger than the number of keys in the database.
	// DEPRECATED. Each solver accesses a different subset of the database.
	RandSkip *uint32           `protobuf:"varint,7,opt,name=rand_skip,json=randSkip,def=0" json:"rand_skip,omitempty"`
	Backend  *DataParameter_DB `protobuf:"varint,8,opt,name=backend,enum=caffe.DataParameter_DB,def=0" json:"backend,omitempty"`
	// DEPRECATED. See TransformationParameter. For data pre-processing, we can do
	// simple scaling and subtracting the data mean, if provided. Note that the
	// mean subtraction is always carried out before scaling.
	Scale    *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	MeanFile string   `protobuf:"bytes,3,opt,name=mean_file,json=meanFile" json:"mean_file"`
	// DEPRECATED. See TransformationParameter. Specify if we would like to randomly
	// crop an image.
	CropSize *uint32 `protobuf:"varint,5,opt,name=crop_size,json=cropSize,def=0" json:"crop_size,omitempty"`
	// DEPRECATED. See TransformationParameter. Specify if we want to randomly mirror
	// data.
	Mirror *bool `protobuf:"varint,6,opt,name=mirror,def=0" json:"mirror,omitempty"`
	// Force the encoded image to have 3 color channels
	ForceEncodedColor *bool `protobuf:"varint,9,opt,name=force_encoded_color,json=forceEncodedColor,def=0" json:"force_encoded_color,omitempty"`
	// Prefetch queue (Number of batches to prefetch to host memory, increase if
	// data access bandwidth varies).
	Prefetch *uint32 `protobuf:"varint,10,opt,name=prefetch,def=4" json:"prefetch,omitempty"`
}

func (m *DataParameter) Reset()         { *m = DataParameter{} }
func (m *DataParameter) String() string { return proto.CompactTextString(m) }
func (*DataParameter) ProtoMessage()    {}
func (*DataParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{22}
}
func (m *DataParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DataParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataParameter.Merge(dst, src)
}
func (m *DataParameter) XXX_Size() int {
	return m.Size()
}
func (m *DataParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_DataParameter.DiscardUnknown(m)
}

var xxx_messageInfo_DataParameter proto.InternalMessageInfo

const Default_DataParameter_RandSkip uint32 = 0
const Default_DataParameter_Backend DataParameter_DB = DataParameter_LEVELDB
const Default_DataParameter_Scale float32 = 1
const Default_DataParameter_CropSize uint32 = 0
const Default_DataParameter_Mirror bool = false
const Default_DataParameter_ForceEncodedColor bool = false
const Default_DataParameter_Prefetch uint32 = 4

func (m *DataParameter) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *DataParameter) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *DataParameter) GetRandSkip() uint32 {
	if m != nil && m.RandSkip != nil {
		return *m.RandSkip
	}
	return Default_DataParameter_RandSkip
}

func (m *DataParameter) GetBackend() DataParameter_DB {
	if m != nil && m.Backend != nil {
		return *m.Backend
	}
	return Default_DataParameter_Backend
}

func (m *DataParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_DataParameter_Scale
}

func (m *DataParameter) GetMeanFile() string {
	if m != nil {
		return m.MeanFile
	}
	return ""
}

func (m *DataParameter) GetCropSize() uint32 {
	if m != nil && m.CropSize != nil {
		return *m.CropSize
	}
	return Default_DataParameter_CropSize
}

func (m *DataParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_DataParameter_Mirror
}

func (m *DataParameter) GetForceEncodedColor() bool {
	if m != nil && m.ForceEncodedColor != nil {
		return *m.ForceEncodedColor
	}
	return Default_DataParameter_ForceEncodedColor
}

func (m *DataParameter) GetPrefetch() uint32 {
	if m != nil && m.Prefetch != nil {
		return *m.Prefetch
	}
	return Default_DataParameter_Prefetch
}

type DropoutParameter struct {
	DropoutRatio *float32 `protobuf:"fixed32,1,opt,name=dropout_ratio,json=dropoutRatio,def=0.5" json:"dropout_ratio,omitempty"`
}

func (m *DropoutParameter) Reset()         { *m = DropoutParameter{} }
func (m *DropoutParameter) String() string { return proto.CompactTextString(m) }
func (*DropoutParameter) ProtoMessage()    {}
func (*DropoutParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{23}
}
func (m *DropoutParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropoutParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropoutParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DropoutParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropoutParameter.Merge(dst, src)
}
func (m *DropoutParameter) XXX_Size() int {
	return m.Size()
}
func (m *DropoutParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_DropoutParameter.DiscardUnknown(m)
}

var xxx_messageInfo_DropoutParameter proto.InternalMessageInfo

const Default_DropoutParameter_DropoutRatio float32 = 0.5

func (m *DropoutParameter) GetDropoutRatio() float32 {
	if m != nil && m.DropoutRatio != nil {
		return *m.DropoutRatio
	}
	return Default_DropoutParameter_DropoutRatio
}

// DummyDataLayer fills any number of arbitrarily shaped blobs with random
// (or constant) data generated by "Fillers" (see "message FillerParameter").
type DummyDataParameter struct {
	// This layer produces N >= 1 top blobs.  DummyDataParameter must specify 1 or N
	// shape fields, and 0, 1 or N data_fillers.
	//
	// If 0 data_fillers are specified, ConstantFiller with a value of 0 is used.
	// If 1 data_filler is specified, it is applied to all top blobs.  If N are
	// specified, the ith is applied to the ith top blob.
	DataFiller []*FillerParameter `protobuf:"bytes,1,rep,name=data_filler,json=dataFiller" json:"data_filler,omitempty"`
	Shape      []*BlobShape       `protobuf:"bytes,6,rep,name=shape" json:"shape,omitempty"`
	// 4D dimensions -- deprecated.  Use "shape" instead.
	Num      []uint32 `protobuf:"varint,2,rep,name=num" json:"num,omitempty"`
	Channels []uint32 `protobuf:"varint,3,rep,name=channels" json:"channels,omitempty"`
	Height   []uint32 `protobuf:"varint,4,rep,name=height" json:"height,omitempty"`
	Width    []uint32 `protobuf:"varint,5,rep,name=width" json:"width,omitempty"`
}

func (m *DummyDataParameter) Reset()         { *m = DummyDataParameter{} }
func (m *DummyDataParameter) String() string { return proto.CompactTextString(m) }
func (*DummyDataParameter) ProtoMessage()    {}
func (*DummyDataParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{24}
}
func (m *DummyDataParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DummyDataParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DummyDataParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DummyDataParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DummyDataParameter.Merge(dst, src)
}
func (m *DummyDataParameter) XXX_Size() int {
	return m.Size()
}
func (m *DummyDataParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_DummyDataParameter.DiscardUnknown(m)
}

var xxx_messageInfo_DummyDataParameter proto.InternalMessageInfo

func (m *DummyDataParameter) GetDataFiller() []*FillerParameter {
	if m != nil {
		return m.DataFiller
	}
	return nil
}

func (m *DummyDataParameter) GetShape() []*BlobShape {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *DummyDataParameter) GetNum() []uint32 {
	if m != nil {
		return m.Num
	}
	return nil
}

func (m *DummyDataParameter) GetChannels() []uint32 {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *DummyDataParameter) GetHeight() []uint32 {
	if m != nil {
		return m.Height
	}
	return nil
}

func (m *DummyDataParameter) GetWidth() []uint32 {
	if m != nil {
		return m.Width
	}
	return nil
}

type EltwiseParameter struct {
	Operation *EltwiseParameter_EltwiseOp `protobuf:"varint,1,opt,name=operation,enum=caffe.EltwiseParameter_EltwiseOp,def=1" json:"operation,omitempty"`
	Coeff     []float32                   `protobuf:"fixed32,2,rep,name=coeff" json:"coeff,omitempty"`
	// Whether to use an asymptotically slower (for >2 inputs) but stabler method
	// of computing the gradient for the PROD operation. (No effect for SUM op.)
	StableProdGrad *bool `protobuf:"varint,3,opt,name=stable_prod_grad,json=stableProdGrad,def=1" json:"stable_prod_grad,omitempty"`
}

func (m *EltwiseParameter) Reset()         { *m = EltwiseParameter{} }
func (m *EltwiseParameter) String() string { return proto.CompactTextString(m) }
func (*EltwiseParameter) ProtoMessage()    {}
func (*EltwiseParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{25}
}
func (m *EltwiseParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EltwiseParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EltwiseParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EltwiseParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EltwiseParameter.Merge(dst, src)
}
func (m *EltwiseParameter) XXX_Size() int {
	return m.Size()
}
func (m *EltwiseParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_EltwiseParameter.DiscardUnknown(m)
}

var xxx_messageInfo_EltwiseParameter proto.InternalMessageInfo

const Default_EltwiseParameter_Operation EltwiseParameter_EltwiseOp = EltwiseParameter_SUM
const Default_EltwiseParameter_StableProdGrad bool = true

func (m *EltwiseParameter) GetOperation() EltwiseParameter_EltwiseOp {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return Default_EltwiseParameter_Operation
}

func (m *EltwiseParameter) GetCoeff() []float32 {
	if m != nil {
		return m.Coeff
	}
	return nil
}

func (m *EltwiseParameter) GetStableProdGrad() bool {
	if m != nil && m.StableProdGrad != nil {
		return *m.StableProdGrad
	}
	return Default_EltwiseParameter_StableProdGrad
}

// Message that stores parameters used by ELULayer
type ELUParameter struct {
	// Described in:
	// Clevert, D.-A., Unterthiner, T., & Hochreiter, S. (2015). Fast and Accurate
	// Deep Network Learning by Exponential Linear Units (ELUs). arXiv
	Alpha *float32 `protobuf:"fixed32,1,opt,name=alpha,def=1" json:"alpha,omitempty"`
}

func (m *ELUParameter) Reset()         { *m = ELUParameter{} }
func (m *ELUParameter) String() string { return proto.CompactTextString(m) }
func (*ELUParameter) ProtoMessage()    {}
func (*ELUParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{26}
}
func (m *ELUParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ELUParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ELUParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ELUParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ELUParameter.Merge(dst, src)
}
func (m *ELUParameter) XXX_Size() int {
	return m.Size()
}
func (m *ELUParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ELUParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ELUParameter proto.InternalMessageInfo

const Default_ELUParameter_Alpha float32 = 1

func (m *ELUParameter) GetAlpha() float32 {
	if m != nil && m.Alpha != nil {
		return *m.Alpha
	}
	return Default_ELUParameter_Alpha
}

// Message that stores parameters used by EmbedLayer
type EmbedParameter struct {
	NumOutput uint32 `protobuf:"varint,1,opt,name=num_output,json=numOutput" json:"num_output"`
	// The input is given as integers to be interpreted as one-hot
	// vector indices with dimension num_input.  Hence num_input should be
	// 1 greater than the maximum possible input value.
	InputDim     uint32           `protobuf:"varint,2,opt,name=input_dim,json=inputDim" json:"input_dim"`
	BiasTerm     *bool            `protobuf:"varint,3,opt,name=bias_term,json=biasTerm,def=1" json:"bias_term,omitempty"`
	WeightFiller *FillerParameter `protobuf:"bytes,4,opt,name=weight_filler,json=weightFiller" json:"weight_filler,omitempty"`
	BiasFiller   *FillerParameter `protobuf:"bytes,5,opt,name=bias_filler,json=biasFiller" json:"bias_filler,omitempty"`
}

func (m *EmbedParameter) Reset()         { *m = EmbedParameter{} }
func (m *EmbedParameter) String() string { return proto.CompactTextString(m) }
func (*EmbedParameter) ProtoMessage()    {}
func (*EmbedParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{27}
}
func (m *EmbedParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmbedParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmbedParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EmbedParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmbedParameter.Merge(dst, src)
}
func (m *EmbedParameter) XXX_Size() int {
	return m.Size()
}
func (m *EmbedParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_EmbedParameter.DiscardUnknown(m)
}

var xxx_messageInfo_EmbedParameter proto.InternalMessageInfo

const Default_EmbedParameter_BiasTerm bool = true

func (m *EmbedParameter) GetNumOutput() uint32 {
	if m != nil {
		return m.NumOutput
	}
	return 0
}

func (m *EmbedParameter) GetInputDim() uint32 {
	if m != nil {
		return m.InputDim
	}
	return 0
}

func (m *EmbedParameter) GetBiasTerm() bool {
	if m != nil && m.BiasTerm != nil {
		return *m.BiasTerm
	}
	return Default_EmbedParameter_BiasTerm
}

func (m *EmbedParameter) GetWeightFiller() *FillerParameter {
	if m != nil {
		return m.WeightFiller
	}
	return nil
}

func (m *EmbedParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

// Message that stores parameters used by ExpLayer
type ExpParameter struct {
	// ExpLayer computes outputs y = base ^ (shift + scale * x), for base > 0.
	// Or if base is set to the default (-1), base is set to e,
	// so y = exp(shift + scale * x).
	Base  *float32 `protobuf:"fixed32,1,opt,name=base,def=-1" json:"base,omitempty"`
	Scale *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	Shift *float32 `protobuf:"fixed32,3,opt,name=shift,def=0" json:"shift,omitempty"`
}

func (m *ExpParameter) Reset()         { *m = ExpParameter{} }
func (m *ExpParameter) String() string { return proto.CompactTextString(m) }
func (*ExpParameter) ProtoMessage()    {}
func (*ExpParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{28}
}
func (m *ExpParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExpParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExpParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ExpParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExpParameter.Merge(dst, src)
}
func (m *ExpParameter) XXX_Size() int {
	return m.Size()
}
func (m *ExpParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ExpParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ExpParameter proto.InternalMessageInfo

const Default_ExpParameter_Base float32 = -1
const Default_ExpParameter_Scale float32 = 1
const Default_ExpParameter_Shift float32 = 0

func (m *ExpParameter) GetBase() float32 {
	if m != nil && m.Base != nil {
		return *m.Base
	}
	return Default_ExpParameter_Base
}

func (m *ExpParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_ExpParameter_Scale
}

func (m *ExpParameter) GetShift() float32 {
	if m != nil && m.Shift != nil {
		return *m.Shift
	}
	return Default_ExpParameter_Shift
}

// / Message that stores parameters used by FlattenLayer
type FlattenParameter struct {
	// The first axis to flatten: all preceding axes are retained in the output.
	// May be negative to index from the end (e.g., -1 for the last axis).
	Axis *int32 `protobuf:"varint,1,opt,name=axis,def=1" json:"axis,omitempty"`
	// The last axis to flatten: all following axes are retained in the output.
	// May be negative to index from the end (e.g., the default -1 for the last
	// axis).
	EndAxis *int32 `protobuf:"varint,2,opt,name=end_axis,json=endAxis,def=-1" json:"end_axis,omitempty"`
}

func (m *FlattenParameter) Reset()         { *m = FlattenParameter{} }
func (m *FlattenParameter) String() string { return proto.CompactTextString(m) }
func (*FlattenParameter) ProtoMessage()    {}
func (*FlattenParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{29}
}
func (m *FlattenParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlattenParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlattenParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FlattenParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlattenParameter.Merge(dst, src)
}
func (m *FlattenParameter) XXX_Size() int {
	return m.Size()
}
func (m *FlattenParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_FlattenParameter.DiscardUnknown(m)
}

var xxx_messageInfo_FlattenParameter proto.InternalMessageInfo

const Default_FlattenParameter_Axis int32 = 1
const Default_FlattenParameter_EndAxis int32 = -1

func (m *FlattenParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_FlattenParameter_Axis
}

func (m *FlattenParameter) GetEndAxis() int32 {
	if m != nil && m.EndAxis != nil {
		return *m.EndAxis
	}
	return Default_FlattenParameter_EndAxis
}

// Message that stores parameters used by HDF5DataLayer
type HDF5DataParameter struct {
	// Specify the data source.
	Source string `protobuf:"bytes,1,opt,name=source" json:"source"`
	// Specify the batch size.
	BatchSize uint32 `protobuf:"varint,2,opt,name=batch_size,json=batchSize" json:"batch_size"`
	// Specify whether to shuffle the data.
	// If shuffle == true, the ordering of the HDF5 files is shuffled,
	// and the ordering of data within any given HDF5 file is shuffled,
	// but data between different files are not interleaved; all of a file's
	// data are output (in a random order) before moving onto another file.
	Shuffle *bool `protobuf:"varint,3,opt,name=shuffle,def=0" json:"shuffle,omitempty"`
}

func (m *HDF5DataParameter) Reset()         { *m = HDF5DataParameter{} }
func (m *HDF5DataParameter) String() string { return proto.CompactTextString(m) }
func (*HDF5DataParameter) ProtoMessage()    {}
func (*HDF5DataParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{30}
}
func (m *HDF5DataParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HDF5DataParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HDF5DataParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HDF5DataParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HDF5DataParameter.Merge(dst, src)
}
func (m *HDF5DataParameter) XXX_Size() int {
	return m.Size()
}
func (m *HDF5DataParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_HDF5DataParameter.DiscardUnknown(m)
}

var xxx_messageInfo_HDF5DataParameter proto.InternalMessageInfo

const Default_HDF5DataParameter_Shuffle bool = false

func (m *HDF5DataParameter) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *HDF5DataParameter) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *HDF5DataParameter) GetShuffle() bool {
	if m != nil && m.Shuffle != nil {
		return *m.Shuffle
	}
	return Default_HDF5DataParameter_Shuffle
}

type HDF5OutputParameter struct {
	FileName string `protobuf:"bytes,1,opt,name=file_name,json=fileName" json:"file_name"`
}

func (m *HDF5OutputParameter) Reset()         { *m = HDF5OutputParameter{} }
func (m *HDF5OutputParameter) String() string { return proto.CompactTextString(m) }
func (*HDF5OutputParameter) ProtoMessage()    {}
func (*HDF5OutputParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{31}
}
func (m *HDF5OutputParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HDF5OutputParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HDF5OutputParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HDF5OutputParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HDF5OutputParameter.Merge(dst, src)
}
func (m *HDF5OutputParameter) XXX_Size() int {
	return m.Size()
}
func (m *HDF5OutputParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_HDF5OutputParameter.DiscardUnknown(m)
}

var xxx_messageInfo_HDF5OutputParameter proto.InternalMessageInfo

func (m *HDF5OutputParameter) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

type HingeLossParameter struct {
	// Specify the Norm to use L1 or L2
	Norm *HingeLossParameter_Norm `protobuf:"varint,1,opt,name=norm,enum=caffe.HingeLossParameter_Norm,def=1" json:"norm,omitempty"`
}

func (m *HingeLossParameter) Reset()         { *m = HingeLossParameter{} }
func (m *HingeLossParameter) String() string { return proto.CompactTextString(m) }
func (*HingeLossParameter) ProtoMessage()    {}
func (*HingeLossParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{32}
}
func (m *HingeLossParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HingeLossParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HingeLossParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HingeLossParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HingeLossParameter.Merge(dst, src)
}
func (m *HingeLossParameter) XXX_Size() int {
	return m.Size()
}
func (m *HingeLossParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_HingeLossParameter.DiscardUnknown(m)
}

var xxx_messageInfo_HingeLossParameter proto.InternalMessageInfo

const Default_HingeLossParameter_Norm HingeLossParameter_Norm = HingeLossParameter_L1

func (m *HingeLossParameter) GetNorm() HingeLossParameter_Norm {
	if m != nil && m.Norm != nil {
		return *m.Norm
	}
	return Default_HingeLossParameter_Norm
}

type ImageDataParameter struct {
	// Specify the data source.
	Source string `protobuf:"bytes,1,opt,name=source" json:"source"`
	// Specify the batch size.
	BatchSize *uint32 `protobuf:"varint,4,opt,name=batch_size,json=batchSize,def=1" json:"batch_size,omitempty"`
	// The rand_skip variable is for the data layer to skip a few data points
	// to avoid all asynchronous sgd clients to start at the same point. The skip
	// point would be set as rand_skip * rand(0,1). Note that rand_skip should not
	// be larger than the number of keys in the database.
	RandSkip *uint32 `protobuf:"varint,7,opt,name=rand_skip,json=randSkip,def=0" json:"rand_skip,omitempty"`
	// Whether or not ImageLayer should shuffle the list of files at every epoch.
	Shuffle *bool `protobuf:"varint,8,opt,name=shuffle,def=0" json:"shuffle,omitempty"`
	// It will also resize images if new_height or new_width are not zero.
	NewHeight *uint32 `protobuf:"varint,9,opt,name=new_height,json=newHeight,def=0" json:"new_height,omitempty"`
	NewWidth  *uint32 `protobuf:"varint,10,opt,name=new_width,json=newWidth,def=0" json:"new_width,omitempty"`
	// Specify if the images are color or gray
	IsColor *bool `protobuf:"varint,11,opt,name=is_color,json=isColor,def=1" json:"is_color,omitempty"`
	// DEPRECATED. See TransformationParameter. For data pre-processing, we can do
	// simple scaling and subtracting the data mean, if provided. Note that the
	// mean subtraction is always carried out before scaling.
	Scale    *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	MeanFile string   `protobuf:"bytes,3,opt,name=mean_file,json=meanFile" json:"mean_file"`
	// DEPRECATED. See TransformationParameter. Specify if we would like to randomly
	// crop an image.
	CropSize *uint32 `protobuf:"varint,5,opt,name=crop_size,json=cropSize,def=0" json:"crop_size,omitempty"`
	// DEPRECATED. See TransformationParameter. Specify if we want to randomly mirror
	// data.
	Mirror     *bool   `protobuf:"varint,6,opt,name=mirror,def=0" json:"mirror,omitempty"`
	RootFolder *string `protobuf:"bytes,12,opt,name=root_folder,json=rootFolder,def=" json:"root_folder,omitempty"`
}

func (m *ImageDataParameter) Reset()         { *m = ImageDataParameter{} }
func (m *ImageDataParameter) String() string { return proto.CompactTextString(m) }
func (*ImageDataParameter) ProtoMessage()    {}
func (*ImageDataParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{33}
}
func (m *ImageDataParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImageDataParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImageDataParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ImageDataParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageDataParameter.Merge(dst, src)
}
func (m *ImageDataParameter) XXX_Size() int {
	return m.Size()
}
func (m *ImageDataParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageDataParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ImageDataParameter proto.InternalMessageInfo

const Default_ImageDataParameter_BatchSize uint32 = 1
const Default_ImageDataParameter_RandSkip uint32 = 0
const Default_ImageDataParameter_Shuffle bool = false
const Default_ImageDataParameter_NewHeight uint32 = 0
const Default_ImageDataParameter_NewWidth uint32 = 0
const Default_ImageDataParameter_IsColor bool = true
const Default_ImageDataParameter_Scale float32 = 1
const Default_ImageDataParameter_CropSize uint32 = 0
const Default_ImageDataParameter_Mirror bool = false

func (m *ImageDataParameter) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *ImageDataParameter) GetBatchSize() uint32 {
	if m != nil && m.BatchSize != nil {
		return *m.BatchSize
	}
	return Default_ImageDataParameter_BatchSize
}

func (m *ImageDataParameter) GetRandSkip() uint32 {
	if m != nil && m.RandSkip != nil {
		return *m.RandSkip
	}
	return Default_ImageDataParameter_RandSkip
}

func (m *ImageDataParameter) GetShuffle() bool {
	if m != nil && m.Shuffle != nil {
		return *m.Shuffle
	}
	return Default_ImageDataParameter_Shuffle
}

func (m *ImageDataParameter) GetNewHeight() uint32 {
	if m != nil && m.NewHeight != nil {
		return *m.NewHeight
	}
	return Default_ImageDataParameter_NewHeight
}

func (m *ImageDataParameter) GetNewWidth() uint32 {
	if m != nil && m.NewWidth != nil {
		return *m.NewWidth
	}
	return Default_ImageDataParameter_NewWidth
}

func (m *ImageDataParameter) GetIsColor() bool {
	if m != nil && m.IsColor != nil {
		return *m.IsColor
	}
	return Default_ImageDataParameter_IsColor
}

func (m *ImageDataParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_ImageDataParameter_Scale
}

func (m *ImageDataParameter) GetMeanFile() string {
	if m != nil {
		return m.MeanFile
	}
	return ""
}

func (m *ImageDataParameter) GetCropSize() uint32 {
	if m != nil && m.CropSize != nil {
		return *m.CropSize
	}
	return Default_ImageDataParameter_CropSize
}

func (m *ImageDataParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_ImageDataParameter_Mirror
}

func (m *ImageDataParameter) GetRootFolder() string {
	if m != nil && m.RootFolder != nil {
		return *m.RootFolder
	}
	return ""
}

type InfogainLossParameter struct {
	// Specify the infogain matrix source.
	Source string `protobuf:"bytes,1,opt,name=source" json:"source"`
}

func (m *InfogainLossParameter) Reset()         { *m = InfogainLossParameter{} }
func (m *InfogainLossParameter) String() string { return proto.CompactTextString(m) }
func (*InfogainLossParameter) ProtoMessage()    {}
func (*InfogainLossParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{34}
}
func (m *InfogainLossParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfogainLossParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfogainLossParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InfogainLossParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfogainLossParameter.Merge(dst, src)
}
func (m *InfogainLossParameter) XXX_Size() int {
	return m.Size()
}
func (m *InfogainLossParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_InfogainLossParameter.DiscardUnknown(m)
}

var xxx_messageInfo_InfogainLossParameter proto.InternalMessageInfo

func (m *InfogainLossParameter) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

type InnerProductParameter struct {
	NumOutput    uint32           `protobuf:"varint,1,opt,name=num_output,json=numOutput" json:"num_output"`
	BiasTerm     *bool            `protobuf:"varint,2,opt,name=bias_term,json=biasTerm,def=1" json:"bias_term,omitempty"`
	WeightFiller *FillerParameter `protobuf:"bytes,3,opt,name=weight_filler,json=weightFiller" json:"weight_filler,omitempty"`
	BiasFiller   *FillerParameter `protobuf:"bytes,4,opt,name=bias_filler,json=biasFiller" json:"bias_filler,omitempty"`
	// The first axis to be lumped into a single inner product computation;
	// all preceding axes are retained in the output.
	// May be negative to index from the end (e.g., -1 for the last axis).
	Axis *int32 `protobuf:"varint,5,opt,name=axis,def=1" json:"axis,omitempty"`
	// Specify whether to transpose the weight matrix or not.
	// If transpose == true, any operations will be performed on the transpose
	// of the weight matrix. The weight matrix itself is not going to be transposed
	// but rather the transfer flag of operations will be toggled accordingly.
	Transpose *bool `protobuf:"varint,6,opt,name=transpose,def=0" json:"transpose,omitempty"`
}

func (m *InnerProductParameter) Reset()         { *m = InnerProductParameter{} }
func (m *InnerProductParameter) String() string { return proto.CompactTextString(m) }
func (*InnerProductParameter) ProtoMessage()    {}
func (*InnerProductParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{35}
}
func (m *InnerProductParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InnerProductParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InnerProductParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InnerProductParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InnerProductParameter.Merge(dst, src)
}
func (m *InnerProductParameter) XXX_Size() int {
	return m.Size()
}
func (m *InnerProductParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_InnerProductParameter.DiscardUnknown(m)
}

var xxx_messageInfo_InnerProductParameter proto.InternalMessageInfo

const Default_InnerProductParameter_BiasTerm bool = true
const Default_InnerProductParameter_Axis int32 = 1
const Default_InnerProductParameter_Transpose bool = false

func (m *InnerProductParameter) GetNumOutput() uint32 {
	if m != nil {
		return m.NumOutput
	}
	return 0
}

func (m *InnerProductParameter) GetBiasTerm() bool {
	if m != nil && m.BiasTerm != nil {
		return *m.BiasTerm
	}
	return Default_InnerProductParameter_BiasTerm
}

func (m *InnerProductParameter) GetWeightFiller() *FillerParameter {
	if m != nil {
		return m.WeightFiller
	}
	return nil
}

func (m *InnerProductParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

func (m *InnerProductParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_InnerProductParameter_Axis
}

func (m *InnerProductParameter) GetTranspose() bool {
	if m != nil && m.Transpose != nil {
		return *m.Transpose
	}
	return Default_InnerProductParameter_Transpose
}

type InputParameter struct {
	// This layer produces N >= 1 top blob(s) to be assigned manually.
	// Define N shapes to set a shape for each top.
	// Define 1 shape to set the same shape for every top.
	// Define no shape to defer to reshaping manually.
	Shape []*BlobShape `protobuf:"bytes,1,rep,name=shape" json:"shape,omitempty"`
}

func (m *InputParameter) Reset()         { *m = InputParameter{} }
func (m *InputParameter) String() string { return proto.CompactTextString(m) }
func (*InputParameter) ProtoMessage()    {}
func (*InputParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{36}
}
func (m *InputParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InputParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputParameter.Merge(dst, src)
}
func (m *InputParameter) XXX_Size() int {
	return m.Size()
}
func (m *InputParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_InputParameter.DiscardUnknown(m)
}

var xxx_messageInfo_InputParameter proto.InternalMessageInfo

func (m *InputParameter) GetShape() []*BlobShape {
	if m != nil {
		return m.Shape
	}
	return nil
}

// Message that stores parameters used by LogLayer
type LogParameter struct {
	// LogLayer computes outputs y = log_base(shift + scale * x), for base > 0.
	// Or if base is set to the default (-1), base is set to e,
	// so y = ln(shift + scale * x) = log_e(shift + scale * x)
	Base  *float32 `protobuf:"fixed32,1,opt,name=base,def=-1" json:"base,omitempty"`
	Scale *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	Shift *float32 `protobuf:"fixed32,3,opt,name=shift,def=0" json:"shift,omitempty"`
}

func (m *LogParameter) Reset()         { *m = LogParameter{} }
func (m *LogParameter) String() string { return proto.CompactTextString(m) }
func (*LogParameter) ProtoMessage()    {}
func (*LogParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{37}
}
func (m *LogParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LogParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogParameter.Merge(dst, src)
}
func (m *LogParameter) XXX_Size() int {
	return m.Size()
}
func (m *LogParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_LogParameter.DiscardUnknown(m)
}

var xxx_messageInfo_LogParameter proto.InternalMessageInfo

const Default_LogParameter_Base float32 = -1
const Default_LogParameter_Scale float32 = 1
const Default_LogParameter_Shift float32 = 0

func (m *LogParameter) GetBase() float32 {
	if m != nil && m.Base != nil {
		return *m.Base
	}
	return Default_LogParameter_Base
}

func (m *LogParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_LogParameter_Scale
}

func (m *LogParameter) GetShift() float32 {
	if m != nil && m.Shift != nil {
		return *m.Shift
	}
	return Default_LogParameter_Shift
}

// Message that stores parameters used by LRNLayer
type LRNParameter struct {
	LocalSize  *uint32                  `protobuf:"varint,1,opt,name=local_size,json=localSize,def=5" json:"local_size,omitempty"`
	Alpha      *float32                 `protobuf:"fixed32,2,opt,name=alpha,def=1" json:"alpha,omitempty"`
	Beta       *float32                 `protobuf:"fixed32,3,opt,name=beta,def=0.75" json:"beta,omitempty"`
	NormRegion *LRNParameter_NormRegion `protobuf:"varint,4,opt,name=norm_region,json=normRegion,enum=caffe.LRNParameter_NormRegion,def=0" json:"norm_region,omitempty"`
	K          *float32                 `protobuf:"fixed32,5,opt,name=k,def=1" json:"k,omitempty"`
	Engine     *LRNParameter_Engine     `protobuf:"varint,6,opt,name=engine,enum=caffe.LRNParameter_Engine,def=0" json:"engine,omitempty"`
}

func (m *LRNParameter) Reset()         { *m = LRNParameter{} }
func (m *LRNParameter) String() string { return proto.CompactTextString(m) }
func (*LRNParameter) ProtoMessage()    {}
func (*LRNParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{38}
}
func (m *LRNParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LRNParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LRNParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LRNParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LRNParameter.Merge(dst, src)
}
func (m *LRNParameter) XXX_Size() int {
	return m.Size()
}
func (m *LRNParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_LRNParameter.DiscardUnknown(m)
}

var xxx_messageInfo_LRNParameter proto.InternalMessageInfo

const Default_LRNParameter_LocalSize uint32 = 5
const Default_LRNParameter_Alpha float32 = 1
const Default_LRNParameter_Beta float32 = 0.75
const Default_LRNParameter_NormRegion LRNParameter_NormRegion = LRNParameter_ACROSS_CHANNELS
const Default_LRNParameter_K float32 = 1
const Default_LRNParameter_Engine LRNParameter_Engine = LRNParameter_DEFAULT

func (m *LRNParameter) GetLocalSize() uint32 {
	if m != nil && m.LocalSize != nil {
		return *m.LocalSize
	}
	return Default_LRNParameter_LocalSize
}

func (m *LRNParameter) GetAlpha() float32 {
	if m != nil && m.Alpha != nil {
		return *m.Alpha
	}
	return Default_LRNParameter_Alpha
}

func (m *LRNParameter) GetBeta() float32 {
	if m != nil && m.Beta != nil {
		return *m.Beta
	}
	return Default_LRNParameter_Beta
}

func (m *LRNParameter) GetNormRegion() LRNParameter_NormRegion {
	if m != nil && m.NormRegion != nil {
		return *m.NormRegion
	}
	return Default_LRNParameter_NormRegion
}

func (m *LRNParameter) GetK() float32 {
	if m != nil && m.K != nil {
		return *m.K
	}
	return Default_LRNParameter_K
}

func (m *LRNParameter) GetEngine() LRNParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_LRNParameter_Engine
}

type MemoryDataParameter struct {
	BatchSize uint32 `protobuf:"varint,1,opt,name=batch_size,json=batchSize" json:"batch_size"`
	Channels  uint32 `protobuf:"varint,2,opt,name=channels" json:"channels"`
	Height    uint32 `protobuf:"varint,3,opt,name=height" json:"height"`
	Width     uint32 `protobuf:"varint,4,opt,name=width" json:"width"`
}

func (m *MemoryDataParameter) Reset()         { *m = MemoryDataParameter{} }
func (m *MemoryDataParameter) String() string { return proto.CompactTextString(m) }
func (*MemoryDataParameter) ProtoMessage()    {}
func (*MemoryDataParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{39}
}
func (m *MemoryDataParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryDataParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryDataParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MemoryDataParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryDataParameter.Merge(dst, src)
}
func (m *MemoryDataParameter) XXX_Size() int {
	return m.Size()
}
func (m *MemoryDataParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryDataParameter.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryDataParameter proto.InternalMessageInfo

func (m *MemoryDataParameter) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *MemoryDataParameter) GetChannels() uint32 {
	if m != nil {
		return m.Channels
	}
	return 0
}

func (m *MemoryDataParameter) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *MemoryDataParameter) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type MVNParameter struct {
	// This parameter can be set to false to normalize mean only
	NormalizeVariance *bool `protobuf:"varint,1,opt,name=normalize_variance,json=normalizeVariance,def=1" json:"normalize_variance,omitempty"`
	// This parameter can be set to true to perform DNN-like MVN
	AcrossChannels *bool `protobuf:"varint,2,opt,name=across_channels,json=acrossChannels,def=0" json:"across_channels,omitempty"`
	// Epsilon for not dividing by zero while normalizing variance
	Eps *float32 `protobuf:"fixed32,3,opt,name=eps,def=1e-09" json:"eps,omitempty"`
}

func (m *MVNParameter) Reset()         { *m = MVNParameter{} }
func (m *MVNParameter) String() string { return proto.CompactTextString(m) }
func (*MVNParameter) ProtoMessage()    {}
func (*MVNParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{40}
}
func (m *MVNParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MVNParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MVNParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MVNParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVNParameter.Merge(dst, src)
}
func (m *MVNParameter) XXX_Size() int {
	return m.Size()
}
func (m *MVNParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_MVNParameter.DiscardUnknown(m)
}

var xxx_messageInfo_MVNParameter proto.InternalMessageInfo

const Default_MVNParameter_NormalizeVariance bool = true
const Default_MVNParameter_AcrossChannels bool = false
const Default_MVNParameter_Eps float32 = 1e-09

func (m *MVNParameter) GetNormalizeVariance() bool {
	if m != nil && m.NormalizeVariance != nil {
		return *m.NormalizeVariance
	}
	return Default_MVNParameter_NormalizeVariance
}

func (m *MVNParameter) GetAcrossChannels() bool {
	if m != nil && m.AcrossChannels != nil {
		return *m.AcrossChannels
	}
	return Default_MVNParameter_AcrossChannels
}

func (m *MVNParameter) GetEps() float32 {
	if m != nil && m.Eps != nil {
		return *m.Eps
	}
	return Default_MVNParameter_Eps
}

type ParameterParameter struct {
	Shape *BlobShape `protobuf:"bytes,1,opt,name=shape" json:"shape,omitempty"`
}

func (m *ParameterParameter) Reset()         { *m = ParameterParameter{} }
func (m *ParameterParameter) String() string { return proto.CompactTextString(m) }
func (*ParameterParameter) ProtoMessage()    {}
func (*ParameterParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{41}
}
func (m *ParameterParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParameterParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParameterParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ParameterParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParameterParameter.Merge(dst, src)
}
func (m *ParameterParameter) XXX_Size() int {
	return m.Size()
}
func (m *ParameterParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ParameterParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ParameterParameter proto.InternalMessageInfo

func (m *ParameterParameter) GetShape() *BlobShape {
	if m != nil {
		return m.Shape
	}
	return nil
}

type PoolingParameter struct {
	Pool *PoolingParameter_PoolMethod `protobuf:"varint,1,opt,name=pool,enum=caffe.PoolingParameter_PoolMethod,def=0" json:"pool,omitempty"`
	// Pad, kernel size, and stride are all given as a single value for equal
	// dimensions in height and width or as Y, X pairs.
	Pad        *uint32                  `protobuf:"varint,4,opt,name=pad,def=0" json:"pad,omitempty"`
	PadH       *uint32                  `protobuf:"varint,9,opt,name=pad_h,json=padH,def=0" json:"pad_h,omitempty"`
	PadW       *uint32                  `protobuf:"varint,10,opt,name=pad_w,json=padW,def=0" json:"pad_w,omitempty"`
	KernelSize uint32                   `protobuf:"varint,2,opt,name=kernel_size,json=kernelSize" json:"kernel_size"`
	KernelH    uint32                   `protobuf:"varint,5,opt,name=kernel_h,json=kernelH" json:"kernel_h"`
	KernelW    uint32                   `protobuf:"varint,6,opt,name=kernel_w,json=kernelW" json:"kernel_w"`
	Stride     *uint32                  `protobuf:"varint,3,opt,name=stride,def=1" json:"stride,omitempty"`
	StrideH    uint32                   `protobuf:"varint,7,opt,name=stride_h,json=strideH" json:"stride_h"`
	StrideW    uint32                   `protobuf:"varint,8,opt,name=stride_w,json=strideW" json:"stride_w"`
	Engine     *PoolingParameter_Engine `protobuf:"varint,11,opt,name=engine,enum=caffe.PoolingParameter_Engine,def=0" json:"engine,omitempty"`
	// If global_pooling then it will pool over the size of the bottom by doing
	// kernel_h = bottom->height and kernel_w = bottom->width
	GlobalPooling *bool `protobuf:"varint,12,opt,name=global_pooling,json=globalPooling,def=0" json:"global_pooling,omitempty"`
}

func (m *PoolingParameter) Reset()         { *m = PoolingParameter{} }
func (m *PoolingParameter) String() string { return proto.CompactTextString(m) }
func (*PoolingParameter) ProtoMessage()    {}
func (*PoolingParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{42}
}
func (m *PoolingParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolingParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolingParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PoolingParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolingParameter.Merge(dst, src)
}
func (m *PoolingParameter) XXX_Size() int {
	return m.Size()
}
func (m *PoolingParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolingParameter.DiscardUnknown(m)
}

var xxx_messageInfo_PoolingParameter proto.InternalMessageInfo

const Default_PoolingParameter_Pool PoolingParameter_PoolMethod = PoolingParameter_MAX
const Default_PoolingParameter_Pad uint32 = 0
const Default_PoolingParameter_PadH uint32 = 0
const Default_PoolingParameter_PadW uint32 = 0
const Default_PoolingParameter_Stride uint32 = 1
const Default_PoolingParameter_Engine PoolingParameter_Engine = PoolingParameter_DEFAULT
const Default_PoolingParameter_GlobalPooling bool = false

func (m *PoolingParameter) GetPool() PoolingParameter_PoolMethod {
	if m != nil && m.Pool != nil {
		return *m.Pool
	}
	return Default_PoolingParameter_Pool
}

func (m *PoolingParameter) GetPad() uint32 {
	if m != nil && m.Pad != nil {
		return *m.Pad
	}
	return Default_PoolingParameter_Pad
}

func (m *PoolingParameter) GetPadH() uint32 {
	if m != nil && m.PadH != nil {
		return *m.PadH
	}
	return Default_PoolingParameter_PadH
}

func (m *PoolingParameter) GetPadW() uint32 {
	if m != nil && m.PadW != nil {
		return *m.PadW
	}
	return Default_PoolingParameter_PadW
}

func (m *PoolingParameter) GetKernelSize() uint32 {
	if m != nil {
		return m.KernelSize
	}
	return 0
}

func (m *PoolingParameter) GetKernelH() uint32 {
	if m != nil {
		return m.KernelH
	}
	return 0
}

func (m *PoolingParameter) GetKernelW() uint32 {
	if m != nil {
		return m.KernelW
	}
	return 0
}

func (m *PoolingParameter) GetStride() uint32 {
	if m != nil && m.Stride != nil {
		return *m.Stride
	}
	return Default_PoolingParameter_Stride
}

func (m *PoolingParameter) GetStrideH() uint32 {
	if m != nil {
		return m.StrideH
	}
	return 0
}

func (m *PoolingParameter) GetStrideW() uint32 {
	if m != nil {
		return m.StrideW
	}
	return 0
}

func (m *PoolingParameter) GetEngine() PoolingParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_PoolingParameter_Engine
}

func (m *PoolingParameter) GetGlobalPooling() bool {
	if m != nil && m.GlobalPooling != nil {
		return *m.GlobalPooling
	}
	return Default_PoolingParameter_GlobalPooling
}

type PowerParameter struct {
	// PowerLayer computes outputs y = (shift + scale * x) ^ power.
	Power *float32 `protobuf:"fixed32,1,opt,name=power,def=1" json:"power,omitempty"`
	Scale *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	Shift *float32 `protobuf:"fixed32,3,opt,name=shift,def=0" json:"shift,omitempty"`
}

func (m *PowerParameter) Reset()         { *m = PowerParameter{} }
func (m *PowerParameter) String() string { return proto.CompactTextString(m) }
func (*PowerParameter) ProtoMessage()    {}
func (*PowerParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{43}
}
func (m *PowerParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PowerParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PowerParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PowerParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PowerParameter.Merge(dst, src)
}
func (m *PowerParameter) XXX_Size() int {
	return m.Size()
}
func (m *PowerParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_PowerParameter.DiscardUnknown(m)
}

var xxx_messageInfo_PowerParameter proto.InternalMessageInfo

const Default_PowerParameter_Power float32 = 1
const Default_PowerParameter_Scale float32 = 1
const Default_PowerParameter_Shift float32 = 0

func (m *PowerParameter) GetPower() float32 {
	if m != nil && m.Power != nil {
		return *m.Power
	}
	return Default_PowerParameter_Power
}

func (m *PowerParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_PowerParameter_Scale
}

func (m *PowerParameter) GetShift() float32 {
	if m != nil && m.Shift != nil {
		return *m.Shift
	}
	return Default_PowerParameter_Shift
}

type PythonParameter struct {
	Module string `protobuf:"bytes,1,opt,name=module" json:"module"`
	Layer  string `protobuf:"bytes,2,opt,name=layer" json:"layer"`
	// This value is set to the attribute `param_str` of the `PythonLayer` object
	// in Python before calling the `setup()` method. This could be a number,
	// string, dictionary in Python dict format, JSON, etc. You may parse this
	// string in `setup` method and use it in `forward` and `backward`.
	ParamStr *string `protobuf:"bytes,3,opt,name=param_str,json=paramStr,def=" json:"param_str,omitempty"`
	// Whether this PythonLayer is shared among worker solvers during data parallelism.
	// If true, each worker solver sequentially run forward from this layer.
	// This value should be set true if you are using it as a data layer.
	ShareInParallel *bool `protobuf:"varint,4,opt,name=share_in_parallel,json=shareInParallel,def=0" json:"share_in_parallel,omitempty"`
}

func (m *PythonParameter) Reset()         { *m = PythonParameter{} }
func (m *PythonParameter) String() string { return proto.CompactTextString(m) }
func (*PythonParameter) ProtoMessage()    {}
func (*PythonParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{44}
}
func (m *PythonParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PythonParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PythonParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PythonParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PythonParameter.Merge(dst, src)
}
func (m *PythonParameter) XXX_Size() int {
	return m.Size()
}
func (m *PythonParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_PythonParameter.DiscardUnknown(m)
}

var xxx_messageInfo_PythonParameter proto.InternalMessageInfo

const Default_PythonParameter_ShareInParallel bool = false

func (m *PythonParameter) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *PythonParameter) GetLayer() string {
	if m != nil {
		return m.Layer
	}
	return ""
}

func (m *PythonParameter) GetParamStr() string {
	if m != nil && m.ParamStr != nil {
		return *m.ParamStr
	}
	return ""
}

func (m *PythonParameter) GetShareInParallel() bool {
	if m != nil && m.ShareInParallel != nil {
		return *m.ShareInParallel
	}
	return Default_PythonParameter_ShareInParallel
}

// Message that stores parameters used by RecurrentLayer
type RecurrentParameter struct {
	// The dimension of the output (and usually hidden state) representation --
	// must be explicitly set to non-zero.
	NumOutput    *uint32          `protobuf:"varint,1,opt,name=num_output,json=numOutput,def=0" json:"num_output,omitempty"`
	WeightFiller *FillerParameter `protobuf:"bytes,2,opt,name=weight_filler,json=weightFiller" json:"weight_filler,omitempty"`
	BiasFiller   *FillerParameter `protobuf:"bytes,3,opt,name=bias_filler,json=biasFiller" json:"bias_filler,omitempty"`
	// Whether to enable displaying debug_info in the unrolled recurrent net.
	DebugInfo *bool `protobuf:"varint,4,opt,name=debug_info,json=debugInfo,def=0" json:"debug_info,omitempty"`
	// Whether to add as additional inputs (bottoms) the initial hidden state
	// blobs, and add as additional outputs (tops) the final timestep hidden state
	// blobs.  The number of additional bottom/top blobs required depends on the
	// recurrent architecture -- e.g., 1 for RNNs, 2 for LSTMs.
	ExposeHidden *bool `protobuf:"varint,5,opt,name=expose_hidden,json=exposeHidden,def=0" json:"expose_hidden,omitempty"`
}

func (m *RecurrentParameter) Reset()         { *m = RecurrentParameter{} }
func (m *RecurrentParameter) String() string { return proto.CompactTextString(m) }
func (*RecurrentParameter) ProtoMessage()    {}
func (*RecurrentParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{45}
}
func (m *RecurrentParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecurrentParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecurrentParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecurrentParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecurrentParameter.Merge(dst, src)
}
func (m *RecurrentParameter) XXX_Size() int {
	return m.Size()
}
func (m *RecurrentParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_RecurrentParameter.DiscardUnknown(m)
}

var xxx_messageInfo_RecurrentParameter proto.InternalMessageInfo

const Default_RecurrentParameter_NumOutput uint32 = 0
const Default_RecurrentParameter_DebugInfo bool = false
const Default_RecurrentParameter_ExposeHidden bool = false

func (m *RecurrentParameter) GetNumOutput() uint32 {
	if m != nil && m.NumOutput != nil {
		return *m.NumOutput
	}
	return Default_RecurrentParameter_NumOutput
}

func (m *RecurrentParameter) GetWeightFiller() *FillerParameter {
	if m != nil {
		return m.WeightFiller
	}
	return nil
}

func (m *RecurrentParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

func (m *RecurrentParameter) GetDebugInfo() bool {
	if m != nil && m.DebugInfo != nil {
		return *m.DebugInfo
	}
	return Default_RecurrentParameter_DebugInfo
}

func (m *RecurrentParameter) GetExposeHidden() bool {
	if m != nil && m.ExposeHidden != nil {
		return *m.ExposeHidden
	}
	return Default_RecurrentParameter_ExposeHidden
}

// Message that stores parameters used by ReductionLayer
type ReductionParameter struct {
	Operation *ReductionParameter_ReductionOp `protobuf:"varint,1,opt,name=operation,enum=caffe.ReductionParameter_ReductionOp,def=1" json:"operation,omitempty"`
	// The first axis to reduce to a scalar -- may be negative to index from the
	// end (e.g., -1 for the last axis).
	// (Currently, only reduction along ALL "tail" axes is supported; reduction
	// of axis M through N, where N < num_axes - 1, is unsupported.)
	// Suppose we have an n-axis bottom Blob with shape:
	//     (d0, d1, d2, ..., d(m-1), dm, d(m+1), ..., d(n-1)).
	// If axis == m, the output Blob will have shape
	//     (d0, d1, d2, ..., d(m-1)),
	// and the ReductionOp operation is performed (d0 * d1 * d2 * ... * d(m-1))
	// times, each including (dm * d(m+1) * ... * d(n-1)) individual data.
	// If axis == 0 (the default), the output Blob always has the empty shape
	// (count 1), performing reduction across the entire input --
	// often useful for creating new loss functions.
	Axis  *int32   `protobuf:"varint,2,opt,name=axis,def=0" json:"axis,omitempty"`
	Coeff *float32 `protobuf:"fixed32,3,opt,name=coeff,def=1" json:"coeff,omitempty"`
}

func (m *ReductionParameter) Reset()         { *m = ReductionParameter{} }
func (m *ReductionParameter) String() string { return proto.CompactTextString(m) }
func (*ReductionParameter) ProtoMessage()    {}
func (*ReductionParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{46}
}
func (m *ReductionParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReductionParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReductionParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReductionParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReductionParameter.Merge(dst, src)
}
func (m *ReductionParameter) XXX_Size() int {
	return m.Size()
}
func (m *ReductionParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ReductionParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ReductionParameter proto.InternalMessageInfo

const Default_ReductionParameter_Operation ReductionParameter_ReductionOp = ReductionParameter_SUM
const Default_ReductionParameter_Axis int32 = 0
const Default_ReductionParameter_Coeff float32 = 1

func (m *ReductionParameter) GetOperation() ReductionParameter_ReductionOp {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return Default_ReductionParameter_Operation
}

func (m *ReductionParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_ReductionParameter_Axis
}

func (m *ReductionParameter) GetCoeff() float32 {
	if m != nil && m.Coeff != nil {
		return *m.Coeff
	}
	return Default_ReductionParameter_Coeff
}

// Message that stores parameters used by ReLULayer
type ReLUParameter struct {
	// Allow non-zero slope for negative inputs to speed up optimization
	// Described in:
	// Maas, A. L., Hannun, A. Y., & Ng, A. Y. (2013). Rectifier nonlinearities
	// improve neural network acoustic models. In ICML Workshop on Deep Learning
	// for Audio, Speech, and Language Processing.
	NegativeSlope *float32              `protobuf:"fixed32,1,opt,name=negative_slope,json=negativeSlope,def=0" json:"negative_slope,omitempty"`
	Engine        *ReLUParameter_Engine `protobuf:"varint,2,opt,name=engine,enum=caffe.ReLUParameter_Engine,def=0" json:"engine,omitempty"`
}

func (m *ReLUParameter) Reset()         { *m = ReLUParameter{} }
func (m *ReLUParameter) String() string { return proto.CompactTextString(m) }
func (*ReLUParameter) ProtoMessage()    {}
func (*ReLUParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{47}
}
func (m *ReLUParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReLUParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReLUParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReLUParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReLUParameter.Merge(dst, src)
}
func (m *ReLUParameter) XXX_Size() int {
	return m.Size()
}
func (m *ReLUParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ReLUParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ReLUParameter proto.InternalMessageInfo

const Default_ReLUParameter_NegativeSlope float32 = 0
const Default_ReLUParameter_Engine ReLUParameter_Engine = ReLUParameter_DEFAULT

func (m *ReLUParameter) GetNegativeSlope() float32 {
	if m != nil && m.NegativeSlope != nil {
		return *m.NegativeSlope
	}
	return Default_ReLUParameter_NegativeSlope
}

func (m *ReLUParameter) GetEngine() ReLUParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_ReLUParameter_Engine
}

type ReshapeParameter struct {
	// Specify the output dimensions. If some of the dimensions are set to 0,
	// the corresponding dimension from the bottom layer is used (unchanged).
	// Exactly one dimension may be set to -1, in which case its value is
	// inferred from the count of the bottom blob and the remaining dimensions.
	// For example, suppose we want to reshape a 2D blob "input" with shape 2 x 8:
	//
	//   layer {
	//     type: "Reshape" bottom: "input" top: "output"
	//     reshape_param { ... }
	//   }
	//
	// If "input" is 2D with shape 2 x 8, then the following reshape_param
	// specifications are all equivalent, producing a 3D blob "output" with shape
	// 2 x 2 x 4:
	//
	//   reshape_param { shape { dim:  2  dim: 2  dim:  4 } }
	//   reshape_param { shape { dim:  0  dim: 2  dim:  4 } }
	//   reshape_param { shape { dim:  0  dim: 2  dim: -1 } }
	//   reshape_param { shape { dim:  0  dim:-1  dim:  4 } }
	//
	Shape *BlobShape `protobuf:"bytes,1,opt,name=shape" json:"shape,omitempty"`
	// axis and num_axes control the portion of the bottom blob's shape that are
	// replaced by (included in) the reshape. By default (axis == 0 and
	// num_axes == -1), the entire bottom blob shape is included in the reshape,
	// and hence the shape field must specify the entire output shape.
	//
	// axis may be non-zero to retain some portion of the beginning of the input
	// shape (and may be negative to index from the end; e.g., -1 to begin the
	// reshape after the last axis, including nothing in the reshape,
	// -2 to include only the last axis, etc.).
	//
	// For example, suppose "input" is a 2D blob with shape 2 x 8.
	// Then the following ReshapeLayer specifications are all equivalent,
	// producing a blob "output" with shape 2 x 2 x 4:
	//
	//   reshape_param { shape { dim: 2  dim: 2  dim: 4 } }
	//   reshape_param { shape { dim: 2  dim: 4 } axis:  1 }
	//   reshape_param { shape { dim: 2  dim: 4 } axis: -3 }
	//
	// num_axes specifies the extent of the reshape.
	// If num_axes >= 0 (and axis >= 0), the reshape will be performed only on
	// input axes in the range [axis, axis+num_axes].
	// num_axes may also be -1, the default, to include all remaining axes
	// (starting from axis).
	//
	// For example, suppose "input" is a 2D blob with shape 2 x 8.
	// Then the following ReshapeLayer specifications are equivalent,
	// producing a blob "output" with shape 1 x 2 x 8.
	//
	//   reshape_param { shape { dim:  1  dim: 2  dim:  8 } }
	//   reshape_param { shape { dim:  1  dim: 2  }  num_axes: 1 }
	//   reshape_param { shape { dim:  1  }  num_axes: 0 }
	//
	// On the other hand, these would produce output blob shape 2 x 1 x 8:
	//
	//   reshape_param { shape { dim: 2  dim: 1  dim: 8  }  }
	//   reshape_param { shape { dim: 1 }  axis: 1  num_axes: 0 }
	//
	Axis    *int32 `protobuf:"varint,2,opt,name=axis,def=0" json:"axis,omitempty"`
	NumAxes *int32 `protobuf:"varint,3,opt,name=num_axes,json=numAxes,def=-1" json:"num_axes,omitempty"`
}

func (m *ReshapeParameter) Reset()         { *m = ReshapeParameter{} }
func (m *ReshapeParameter) String() string { return proto.CompactTextString(m) }
func (*ReshapeParameter) ProtoMessage()    {}
func (*ReshapeParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{48}
}
func (m *ReshapeParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReshapeParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReshapeParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReshapeParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReshapeParameter.Merge(dst, src)
}
func (m *ReshapeParameter) XXX_Size() int {
	return m.Size()
}
func (m *ReshapeParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ReshapeParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ReshapeParameter proto.InternalMessageInfo

const Default_ReshapeParameter_Axis int32 = 0
const Default_ReshapeParameter_NumAxes int32 = -1

func (m *ReshapeParameter) GetShape() *BlobShape {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *ReshapeParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_ReshapeParameter_Axis
}

func (m *ReshapeParameter) GetNumAxes() int32 {
	if m != nil && m.NumAxes != nil {
		return *m.NumAxes
	}
	return Default_ReshapeParameter_NumAxes
}

type ScaleParameter struct {
	// The first axis of bottom[0] (the first input Blob) along which to apply
	// bottom[1] (the second input Blob).  May be negative to index from the end
	// (e.g., -1 for the last axis).
	//
	// For example, if bottom[0] is 4D with shape 100x3x40x60, the output
	// top[0] will have the same shape, and bottom[1] may have any of the
	// following shapes (for the given value of axis):
	//    (axis == 0 == -4) 100; 100x3; 100x3x40; 100x3x40x60
	//    (axis == 1 == -3)          3;     3x40;     3x40x60
	//    (axis == 2 == -2)                   40;       40x60
	//    (axis == 3 == -1)                                60
	// Furthermore, bottom[1] may have the empty shape (regardless of the value of
	// "axis") -- a scalar multiplier.
	Axis *int32 `protobuf:"varint,1,opt,name=axis,def=1" json:"axis,omitempty"`
	// (num_axes is ignored unless just one bottom is given and the scale is
	// a learned parameter of the layer.  Otherwise, num_axes is determined by the
	// number of axes by the second bottom.)
	// The number of axes of the input (bottom[0]) covered by the scale
	// parameter, or -1 to cover all axes of bottom[0] starting from `axis`.
	// Set num_axes := 0, to multiply with a zero-axis Blob: a scalar.
	NumAxes *int32 `protobuf:"varint,2,opt,name=num_axes,json=numAxes,def=1" json:"num_axes,omitempty"`
	// (filler is ignored unless just one bottom is given and the scale is
	// a learned parameter of the layer.)
	// The initialization for the learned scale parameter.
	// Default is the unit (1) initialization, resulting in the ScaleLayer
	// initially performing the identity operation.
	Filler *FillerParameter `protobuf:"bytes,3,opt,name=filler" json:"filler,omitempty"`
	// Whether to also learn a bias (equivalent to a ScaleLayer+BiasLayer, but
	// may be more efficient).  Initialized with bias_filler (defaults to 0).
	BiasTerm   *bool            `protobuf:"varint,4,opt,name=bias_term,json=biasTerm,def=0" json:"bias_term,omitempty"`
	BiasFiller *FillerParameter `protobuf:"bytes,5,opt,name=bias_filler,json=biasFiller" json:"bias_filler,omitempty"`
}

func (m *ScaleParameter) Reset()         { *m = ScaleParameter{} }
func (m *ScaleParameter) String() string { return proto.CompactTextString(m) }
func (*ScaleParameter) ProtoMessage()    {}
func (*ScaleParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{49}
}
func (m *ScaleParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScaleParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScaleParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ScaleParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScaleParameter.Merge(dst, src)
}
func (m *ScaleParameter) XXX_Size() int {
	return m.Size()
}
func (m *ScaleParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ScaleParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ScaleParameter proto.InternalMessageInfo

const Default_ScaleParameter_Axis int32 = 1
const Default_ScaleParameter_NumAxes int32 = 1
const Default_ScaleParameter_BiasTerm bool = false

func (m *ScaleParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_ScaleParameter_Axis
}

func (m *ScaleParameter) GetNumAxes() int32 {
	if m != nil && m.NumAxes != nil {
		return *m.NumAxes
	}
	return Default_ScaleParameter_NumAxes
}

func (m *ScaleParameter) GetFiller() *FillerParameter {
	if m != nil {
		return m.Filler
	}
	return nil
}

func (m *ScaleParameter) GetBiasTerm() bool {
	if m != nil && m.BiasTerm != nil {
		return *m.BiasTerm
	}
	return Default_ScaleParameter_BiasTerm
}

func (m *ScaleParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

type SigmoidParameter struct {
	Engine *SigmoidParameter_Engine `protobuf:"varint,1,opt,name=engine,enum=caffe.SigmoidParameter_Engine,def=0" json:"engine,omitempty"`
}

func (m *SigmoidParameter) Reset()         { *m = SigmoidParameter{} }
func (m *SigmoidParameter) String() string { return proto.CompactTextString(m) }
func (*SigmoidParameter) ProtoMessage()    {}
func (*SigmoidParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{50}
}
func (m *SigmoidParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigmoidParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigmoidParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SigmoidParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigmoidParameter.Merge(dst, src)
}
func (m *SigmoidParameter) XXX_Size() int {
	return m.Size()
}
func (m *SigmoidParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_SigmoidParameter.DiscardUnknown(m)
}

var xxx_messageInfo_SigmoidParameter proto.InternalMessageInfo

const Default_SigmoidParameter_Engine SigmoidParameter_Engine = SigmoidParameter_DEFAULT

func (m *SigmoidParameter) GetEngine() SigmoidParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_SigmoidParameter_Engine
}

type SliceParameter struct {
	// The axis along which to slice -- may be negative to index from the end
	// (e.g., -1 for the last axis).
	// By default, SliceLayer concatenates blobs along the "channels" axis (1).
	Axis       *int32   `protobuf:"varint,3,opt,name=axis,def=1" json:"axis,omitempty"`
	SlicePoint []uint32 `protobuf:"varint,2,rep,name=slice_point,json=slicePoint" json:"slice_point,omitempty"`
	// DEPRECATED: alias for "axis" -- does not support negative indexing.
	SliceDim *uint32 `protobuf:"varint,1,opt,name=slice_dim,json=sliceDim,def=1" json:"slice_dim,omitempty"`
}

func (m *SliceParameter) Reset()         { *m = SliceParameter{} }
func (m *SliceParameter) String() string { return proto.CompactTextString(m) }
func (*SliceParameter) ProtoMessage()    {}
func (*SliceParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{51}
}
func (m *SliceParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SliceParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SliceParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SliceParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SliceParameter.Merge(dst, src)
}
func (m *SliceParameter) XXX_Size() int {
	return m.Size()
}
func (m *SliceParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_SliceParameter.DiscardUnknown(m)
}

var xxx_messageInfo_SliceParameter proto.InternalMessageInfo

const Default_SliceParameter_Axis int32 = 1
const Default_SliceParameter_SliceDim uint32 = 1

func (m *SliceParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_SliceParameter_Axis
}

func (m *SliceParameter) GetSlicePoint() []uint32 {
	if m != nil {
		return m.SlicePoint
	}
	return nil
}

func (m *SliceParameter) GetSliceDim() uint32 {
	if m != nil && m.SliceDim != nil {
		return *m.SliceDim
	}
	return Default_SliceParameter_SliceDim
}

// Message that stores parameters used by SoftmaxLayer, SoftmaxWithLossLayer
type SoftmaxParameter struct {
	Engine *SoftmaxParameter_Engine `protobuf:"varint,1,opt,name=engine,enum=caffe.SoftmaxParameter_Engine,def=0" json:"engine,omitempty"`
	// The axis along which to perform the softmax -- may be negative to index
	// from the end (e.g., -1 for the last axis).
	// Any other axes will be evaluated as independent softmaxes.
	Axis *int32 `protobuf:"varint,2,opt,name=axis,def=1" json:"axis,omitempty"`
}

func (m *SoftmaxParameter) Reset()         { *m = SoftmaxParameter{} }
func (m *SoftmaxParameter) String() string { return proto.CompactTextString(m) }
func (*SoftmaxParameter) ProtoMessage()    {}
func (*SoftmaxParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{52}
}
func (m *SoftmaxParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SoftmaxParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SoftmaxParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SoftmaxParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SoftmaxParameter.Merge(dst, src)
}
func (m *SoftmaxParameter) XXX_Size() int {
	return m.Size()
}
func (m *SoftmaxParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_SoftmaxParameter.DiscardUnknown(m)
}

var xxx_messageInfo_SoftmaxParameter proto.InternalMessageInfo

const Default_SoftmaxParameter_Engine SoftmaxParameter_Engine = SoftmaxParameter_DEFAULT
const Default_SoftmaxParameter_Axis int32 = 1

func (m *SoftmaxParameter) GetEngine() SoftmaxParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_SoftmaxParameter_Engine
}

func (m *SoftmaxParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_SoftmaxParameter_Axis
}

type TanHParameter struct {
	Engine *TanHParameter_Engine `protobuf:"varint,1,opt,name=engine,enum=caffe.TanHParameter_Engine,def=0" json:"engine,omitempty"`
}

func (m *TanHParameter) Reset()         { *m = TanHParameter{} }
func (m *TanHParameter) String() string { return proto.CompactTextString(m) }
func (*TanHParameter) ProtoMessage()    {}
func (*TanHParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{53}
}
func (m *TanHParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TanHParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TanHParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TanHParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TanHParameter.Merge(dst, src)
}
func (m *TanHParameter) XXX_Size() int {
	return m.Size()
}
func (m *TanHParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_TanHParameter.DiscardUnknown(m)
}

var xxx_messageInfo_TanHParameter proto.InternalMessageInfo

const Default_TanHParameter_Engine TanHParameter_Engine = TanHParameter_DEFAULT

func (m *TanHParameter) GetEngine() TanHParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_TanHParameter_Engine
}

// Message that stores parameters used by TileLayer
type TileParameter struct {
	// The index of the axis to tile.
	Axis *int32 `protobuf:"varint,1,opt,name=axis,def=1" json:"axis,omitempty"`
	// The number of copies (tiles) of the blob to output.
	Tiles int32 `protobuf:"varint,2,opt,name=tiles" json:"tiles"`
}

func (m *TileParameter) Reset()         { *m = TileParameter{} }
func (m *TileParameter) String() string { return proto.CompactTextString(m) }
func (*TileParameter) ProtoMessage()    {}
func (*TileParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{54}
}
func (m *TileParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TileParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TileParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TileParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TileParameter.Merge(dst, src)
}
func (m *TileParameter) XXX_Size() int {
	return m.Size()
}
func (m *TileParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_TileParameter.DiscardUnknown(m)
}

var xxx_messageInfo_TileParameter proto.InternalMessageInfo

const Default_TileParameter_Axis int32 = 1

func (m *TileParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_TileParameter_Axis
}

func (m *TileParameter) GetTiles() int32 {
	if m != nil {
		return m.Tiles
	}
	return 0
}

// Message that stores parameters used by ThresholdLayer
type ThresholdParameter struct {
	Threshold *float32 `protobuf:"fixed32,1,opt,name=threshold,def=0" json:"threshold,omitempty"`
}

func (m *ThresholdParameter) Reset()         { *m = ThresholdParameter{} }
func (m *ThresholdParameter) String() string { return proto.CompactTextString(m) }
func (*ThresholdParameter) ProtoMessage()    {}
func (*ThresholdParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{55}
}
func (m *ThresholdParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThresholdParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThresholdParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ThresholdParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdParameter.Merge(dst, src)
}
func (m *ThresholdParameter) XXX_Size() int {
	return m.Size()
}
func (m *ThresholdParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdParameter proto.InternalMessageInfo

const Default_ThresholdParameter_Threshold float32 = 0

func (m *ThresholdParameter) GetThreshold() float32 {
	if m != nil && m.Threshold != nil {
		return *m.Threshold
	}
	return Default_ThresholdParameter_Threshold
}

type WindowDataParameter struct {
	// Specify the data source.
	Source string `protobuf:"bytes,1,opt,name=source" json:"source"`
	// For data pre-processing, we can do simple scaling and subtracting the
	// data mean, if provided. Note that the mean subtraction is always carried
	// out before scaling.
	Scale    *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	MeanFile string   `protobuf:"bytes,3,opt,name=mean_file,json=meanFile" json:"mean_file"`
	// Specify the batch size.
	BatchSize uint32 `protobuf:"varint,4,opt,name=batch_size,json=batchSize" json:"batch_size"`
	// Specify if we would like to randomly crop an image.
	CropSize *uint32 `protobuf:"varint,5,opt,name=crop_size,json=cropSize,def=0" json:"crop_size,omitempty"`
	// Specify if we want to randomly mirror data.
	Mirror *bool `protobuf:"varint,6,opt,name=mirror,def=0" json:"mirror,omitempty"`
	// Foreground (object) overlap threshold
	FgThreshold *float32 `protobuf:"fixed32,7,opt,name=fg_threshold,json=fgThreshold,def=0.5" json:"fg_threshold,omitempty"`
	// Background (non-object) overlap threshold
	BgThreshold *float32 `protobuf:"fixed32,8,opt,name=bg_threshold,json=bgThreshold,def=0.5" json:"bg_threshold,omitempty"`
	// Fraction of batch that should be foreground objects
	FgFraction *float32 `protobuf:"fixed32,9,opt,name=fg_fraction,json=fgFraction,def=0.25" json:"fg_fraction,omitempty"`
	// Amount of contextual padding to add around a window
	// (used only by the window_data_layer)
	ContextPad *uint32 `protobuf:"varint,10,opt,name=context_pad,json=contextPad,def=0" json:"context_pad,omitempty"`
	// Mode for cropping out a detection window
	// warp: cropped window is warped to a fixed size and aspect ratio
	// square: the tightest square around the window is cropped
	CropMode *string `protobuf:"bytes,11,opt,name=crop_mode,json=cropMode,def=warp" json:"crop_mode,omitempty"`
	// cache_images: will load all images in memory for faster access
	CacheImages *bool `protobuf:"varint,12,opt,name=cache_images,json=cacheImages,def=0" json:"cache_images,omitempty"`
	// append root_folder to locate images
	RootFolder *string `protobuf:"bytes,13,opt,name=root_folder,json=rootFolder,def=" json:"root_folder,omitempty"`
}

func (m *WindowDataParameter) Reset()         { *m = WindowDataParameter{} }
func (m *WindowDataParameter) String() string { return proto.CompactTextString(m) }
func (*WindowDataParameter) ProtoMessage()    {}
func (*WindowDataParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{56}
}
func (m *WindowDataParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowDataParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowDataParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WindowDataParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowDataParameter.Merge(dst, src)
}
func (m *WindowDataParameter) XXX_Size() int {
	return m.Size()
}
func (m *WindowDataParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowDataParameter.DiscardUnknown(m)
}

var xxx_messageInfo_WindowDataParameter proto.InternalMessageInfo

const Default_WindowDataParameter_Scale float32 = 1
const Default_WindowDataParameter_CropSize uint32 = 0
const Default_WindowDataParameter_Mirror bool = false
const Default_WindowDataParameter_FgThreshold float32 = 0.5
const Default_WindowDataParameter_BgThreshold float32 = 0.5
const Default_WindowDataParameter_FgFraction float32 = 0.25
const Default_WindowDataParameter_ContextPad uint32 = 0
const Default_WindowDataParameter_CropMode string = "warp"
const Default_WindowDataParameter_CacheImages bool = false

func (m *WindowDataParameter) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *WindowDataParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_WindowDataParameter_Scale
}

func (m *WindowDataParameter) GetMeanFile() string {
	if m != nil {
		return m.MeanFile
	}
	return ""
}

func (m *WindowDataParameter) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *WindowDataParameter) GetCropSize() uint32 {
	if m != nil && m.CropSize != nil {
		return *m.CropSize
	}
	return Default_WindowDataParameter_CropSize
}

func (m *WindowDataParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_WindowDataParameter_Mirror
}

func (m *WindowDataParameter) GetFgThreshold() float32 {
	if m != nil && m.FgThreshold != nil {
		return *m.FgThreshold
	}
	return Default_WindowDataParameter_FgThreshold
}

func (m *WindowDataParameter) GetBgThreshold() float32 {
	if m != nil && m.BgThreshold != nil {
		return *m.BgThreshold
	}
	return Default_WindowDataParameter_BgThreshold
}

func (m *WindowDataParameter) GetFgFraction() float32 {
	if m != nil && m.FgFraction != nil {
		return *m.FgFraction
	}
	return Default_WindowDataParameter_FgFraction
}

func (m *WindowDataParameter) GetContextPad() uint32 {
	if m != nil && m.ContextPad != nil {
		return *m.ContextPad
	}
	return Default_WindowDataParameter_ContextPad
}

func (m *WindowDataParameter) GetCropMode() string {
	if m != nil && m.CropMode != nil {
		return *m.CropMode
	}
	return Default_WindowDataParameter_CropMode
}

func (m *WindowDataParameter) GetCacheImages() bool {
	if m != nil && m.CacheImages != nil {
		return *m.CacheImages
	}
	return Default_WindowDataParameter_CacheImages
}

func (m *WindowDataParameter) GetRootFolder() string {
	if m != nil && m.RootFolder != nil {
		return *m.RootFolder
	}
	return ""
}

type SPPParameter struct {
	PyramidHeight uint32                   `protobuf:"varint,1,opt,name=pyramid_height,json=pyramidHeight" json:"pyramid_height"`
	Pool          *SPPParameter_PoolMethod `protobuf:"varint,2,opt,name=pool,enum=caffe.SPPParameter_PoolMethod,def=0" json:"pool,omitempty"`
	Engine        *SPPParameter_Engine     `protobuf:"varint,6,opt,name=engine,enum=caffe.SPPParameter_Engine,def=0" json:"engine,omitempty"`
}

func (m *SPPParameter) Reset()         { *m = SPPParameter{} }
func (m *SPPParameter) String() string { return proto.CompactTextString(m) }
func (*SPPParameter) ProtoMessage()    {}
func (*SPPParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{57}
}
func (m *SPPParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SPPParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SPPParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SPPParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SPPParameter.Merge(dst, src)
}
func (m *SPPParameter) XXX_Size() int {
	return m.Size()
}
func (m *SPPParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_SPPParameter.DiscardUnknown(m)
}

var xxx_messageInfo_SPPParameter proto.InternalMessageInfo

const Default_SPPParameter_Pool SPPParameter_PoolMethod = SPPParameter_MAX
const Default_SPPParameter_Engine SPPParameter_Engine = SPPParameter_DEFAULT

func (m *SPPParameter) GetPyramidHeight() uint32 {
	if m != nil {
		return m.PyramidHeight
	}
	return 0
}

func (m *SPPParameter) GetPool() SPPParameter_PoolMethod {
	if m != nil && m.Pool != nil {
		return *m.Pool
	}
	return Default_SPPParameter_Pool
}

func (m *SPPParameter) GetEngine() SPPParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_SPPParameter_Engine
}

// DEPRECATED: use LayerParameter.
type V1LayerParameter struct {
	Bottom               []string                        `protobuf:"bytes,2,rep,name=bottom" json:"bottom,omitempty"`
	Top                  []string                        `protobuf:"bytes,3,rep,name=top" json:"top,omitempty"`
	Name                 string                          `protobuf:"bytes,4,opt,name=name" json:"name"`
	Include              []*NetStateRule                 `protobuf:"bytes,32,rep,name=include" json:"include,omitempty"`
	Exclude              []*NetStateRule                 `protobuf:"bytes,33,rep,name=exclude" json:"exclude,omitempty"`
	Type                 V1LayerParameter_LayerType      `protobuf:"varint,5,opt,name=type,enum=caffe.V1LayerParameter_LayerType" json:"type"`
	Blobs                []*BlobProto                    `protobuf:"bytes,6,rep,name=blobs" json:"blobs,omitempty"`
	Param                []string                        `protobuf:"bytes,1001,rep,name=param" json:"param,omitempty"`
	BlobShareMode        []V1LayerParameter_DimCheckMode `protobuf:"varint,1002,rep,name=blob_share_mode,json=blobShareMode,enum=caffe.V1LayerParameter_DimCheckMode" json:"blob_share_mode,omitempty"`
	BlobsLr              []float32                       `protobuf:"fixed32,7,rep,name=blobs_lr,json=blobsLr" json:"blobs_lr,omitempty"`
	WeightDecay          []float32                       `protobuf:"fixed32,8,rep,name=weight_decay,json=weightDecay" json:"weight_decay,omitempty"`
	LossWeight           []float32                       `protobuf:"fixed32,35,rep,name=loss_weight,json=lossWeight" json:"loss_weight,omitempty"`
	AccuracyParam        *AccuracyParameter              `protobuf:"bytes,27,opt,name=accuracy_param,json=accuracyParam" json:"accuracy_param,omitempty"`
	ArgmaxParam          *ArgMaxParameter                `protobuf:"bytes,23,opt,name=argmax_param,json=argmaxParam" json:"argmax_param,omitempty"`
	ConcatParam          *ConcatParameter                `protobuf:"bytes,9,opt,name=concat_param,json=concatParam" json:"concat_param,omitempty"`
	ContrastiveLossParam *ContrastiveLossParameter       `protobuf:"bytes,40,opt,name=contrastive_loss_param,json=contrastiveLossParam" json:"contrastive_loss_param,omitempty"`
	ConvolutionParam     *ConvolutionParameter           `protobuf:"bytes,10,opt,name=convolution_param,json=convolutionParam" json:"convolution_param,omitempty"`
	DataParam            *DataParameter                  `protobuf:"bytes,11,opt,name=data_param,json=dataParam" json:"data_param,omitempty"`
	DropoutParam         *DropoutParameter               `protobuf:"bytes,12,opt,name=dropout_param,json=dropoutParam" json:"dropout_param,omitempty"`
	DummyDataParam       *DummyDataParameter             `protobuf:"bytes,26,opt,name=dummy_data_param,json=dummyDataParam" json:"dummy_data_param,omitempty"`
	EltwiseParam         *EltwiseParameter               `protobuf:"bytes,24,opt,name=eltwise_param,json=eltwiseParam" json:"eltwise_param,omitempty"`
	ExpParam             *ExpParameter                   `protobuf:"bytes,41,opt,name=exp_param,json=expParam" json:"exp_param,omitempty"`
	Hdf5DataParam        *HDF5DataParameter              `protobuf:"bytes,13,opt,name=hdf5_data_param,json=hdf5DataParam" json:"hdf5_data_param,omitempty"`
	Hdf5OutputParam      *HDF5OutputParameter            `protobuf:"bytes,14,opt,name=hdf5_output_param,json=hdf5OutputParam" json:"hdf5_output_param,omitempty"`
	HingeLossParam       *HingeLossParameter             `protobuf:"bytes,29,opt,name=hinge_loss_param,json=hingeLossParam" json:"hinge_loss_param,omitempty"`
	ImageDataParam       *ImageDataParameter             `protobuf:"bytes,15,opt,name=image_data_param,json=imageDataParam" json:"image_data_param,omitempty"`
	InfogainLossParam    *InfogainLossParameter          `protobuf:"bytes,16,opt,name=infogain_loss_param,json=infogainLossParam" json:"infogain_loss_param,omitempty"`
	InnerProductParam    *InnerProductParameter          `protobuf:"bytes,17,opt,name=inner_product_param,json=innerProductParam" json:"inner_product_param,omitempty"`
	LrnParam             *LRNParameter                   `protobuf:"bytes,18,opt,name=lrn_param,json=lrnParam" json:"lrn_param,omitempty"`
	MemoryDataParam      *MemoryDataParameter            `protobuf:"bytes,22,opt,name=memory_data_param,json=memoryDataParam" json:"memory_data_param,omitempty"`
	MvnParam             *MVNParameter                   `protobuf:"bytes,34,opt,name=mvn_param,json=mvnParam" json:"mvn_param,omitempty"`
	PoolingParam         *PoolingParameter               `protobuf:"bytes,19,opt,name=pooling_param,json=poolingParam" json:"pooling_param,omitempty"`
	PowerParam           *PowerParameter                 `protobuf:"bytes,21,opt,name=power_param,json=powerParam" json:"power_param,omitempty"`
	ReluParam            *ReLUParameter                  `protobuf:"bytes,30,opt,name=relu_param,json=reluParam" json:"relu_param,omitempty"`
	SigmoidParam         *SigmoidParameter               `protobuf:"bytes,38,opt,name=sigmoid_param,json=sigmoidParam" json:"sigmoid_param,omitempty"`
	SoftmaxParam         *SoftmaxParameter               `protobuf:"bytes,39,opt,name=softmax_param,json=softmaxParam" json:"softmax_param,omitempty"`
	SliceParam           *SliceParameter                 `protobuf:"bytes,31,opt,name=slice_param,json=sliceParam" json:"slice_param,omitempty"`
	TanhParam            *TanHParameter                  `protobuf:"bytes,37,opt,name=tanh_param,json=tanhParam" json:"tanh_param,omitempty"`
	ThresholdParam       *ThresholdParameter             `protobuf:"bytes,25,opt,name=threshold_param,json=thresholdParam" json:"threshold_param,omitempty"`
	WindowDataParam      *WindowDataParameter            `protobuf:"bytes,20,opt,name=window_data_param,json=windowDataParam" json:"window_data_param,omitempty"`
	TransformParam       *TransformationParameter        `protobuf:"bytes,36,opt,name=transform_param,json=transformParam" json:"transform_param,omitempty"`
	LossParam            *LossParameter                  `protobuf:"bytes,42,opt,name=loss_param,json=lossParam" json:"loss_param,omitempty"`
	Layer                *V0LayerParameter               `protobuf:"bytes,1,opt,name=layer" json:"layer,omitempty"`
}

func (m *V1LayerParameter) Reset()         { *m = V1LayerParameter{} }
func (m *V1LayerParameter) String() string { return proto.CompactTextString(m) }
func (*V1LayerParameter) ProtoMessage()    {}
func (*V1LayerParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{58}
}
func (m *V1LayerParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *V1LayerParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_V1LayerParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *V1LayerParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_V1LayerParameter.Merge(dst, src)
}
func (m *V1LayerParameter) XXX_Size() int {
	return m.Size()
}
func (m *V1LayerParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_V1LayerParameter.DiscardUnknown(m)
}

var xxx_messageInfo_V1LayerParameter proto.InternalMessageInfo

func (m *V1LayerParameter) GetBottom() []string {
	if m != nil {
		return m.Bottom
	}
	return nil
}

func (m *V1LayerParameter) GetTop() []string {
	if m != nil {
		return m.Top
	}
	return nil
}

func (m *V1LayerParameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *V1LayerParameter) GetInclude() []*NetStateRule {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *V1LayerParameter) GetExclude() []*NetStateRule {
	if m != nil {
		return m.Exclude
	}
	return nil
}

func (m *V1LayerParameter) GetType() V1LayerParameter_LayerType {
	if m != nil {
		return m.Type
	}
	return V1LayerParameter_NONE
}

func (m *V1LayerParameter) GetBlobs() []*BlobProto {
	if m != nil {
		return m.Blobs
	}
	return nil
}

func (m *V1LayerParameter) GetParam() []string {
	if m != nil {
		return m.Param
	}
	return nil
}

func (m *V1LayerParameter) GetBlobShareMode() []V1LayerParameter_DimCheckMode {
	if m != nil {
		return m.BlobShareMode
	}
	return nil
}

func (m *V1LayerParameter) GetBlobsLr() []float32 {
	if m != nil {
		return m.BlobsLr
	}
	return nil
}

func (m *V1LayerParameter) GetWeightDecay() []float32 {
	if m != nil {
		return m.WeightDecay
	}
	return nil
}

func (m *V1LayerParameter) GetLossWeight() []float32 {
	if m != nil {
		return m.LossWeight
	}
	return nil
}

func (m *V1LayerParameter) GetAccuracyParam() *AccuracyParameter {
	if m != nil {
		return m.AccuracyParam
	}
	return nil
}

func (m *V1LayerParameter) GetArgmaxParam() *ArgMaxParameter {
	if m != nil {
		return m.ArgmaxParam
	}
	return nil
}

func (m *V1LayerParameter) GetConcatParam() *ConcatParameter {
	if m != nil {
		return m.ConcatParam
	}
	return nil
}

func (m *V1LayerParameter) GetContrastiveLossParam() *ContrastiveLossParameter {
	if m != nil {
		return m.ContrastiveLossParam
	}
	return nil
}

func (m *V1LayerParameter) GetConvolutionParam() *ConvolutionParameter {
	if m != nil {
		return m.ConvolutionParam
	}
	return nil
}

func (m *V1LayerParameter) GetDataParam() *DataParameter {
	if m != nil {
		return m.DataParam
	}
	return nil
}

func (m *V1LayerParameter) GetDropoutParam() *DropoutParameter {
	if m != nil {
		return m.DropoutParam
	}
	return nil
}

func (m *V1LayerParameter) GetDummyDataParam() *DummyDataParameter {
	if m != nil {
		return m.DummyDataParam
	}
	return nil
}

func (m *V1LayerParameter) GetEltwiseParam() *EltwiseParameter {
	if m != nil {
		return m.EltwiseParam
	}
	return nil
}

func (m *V1LayerParameter) GetExpParam() *ExpParameter {
	if m != nil {
		return m.ExpParam
	}
	return nil
}

func (m *V1LayerParameter) GetHdf5DataParam() *HDF5DataParameter {
	if m != nil {
		return m.Hdf5DataParam
	}
	return nil
}

func (m *V1LayerParameter) GetHdf5OutputParam() *HDF5OutputParameter {
	if m != nil {
		return m.Hdf5OutputParam
	}
	return nil
}

func (m *V1LayerParameter) GetHingeLossParam() *HingeLossParameter {
	if m != nil {
		return m.HingeLossParam
	}
	return nil
}

func (m *V1LayerParameter) GetImageDataParam() *ImageDataParameter {
	if m != nil {
		return m.ImageDataParam
	}
	return nil
}

func (m *V1LayerParameter) GetInfogainLossParam() *InfogainLossParameter {
	if m != nil {
		return m.InfogainLossParam
	}
	return nil
}

func (m *V1LayerParameter) GetInnerProductParam() *InnerProductParameter {
	if m != nil {
		return m.InnerProductParam
	}
	return nil
}

func (m *V1LayerParameter) GetLrnParam() *LRNParameter {
	if m != nil {
		return m.LrnParam
	}
	return nil
}

func (m *V1LayerParameter) GetMemoryDataParam() *MemoryDataParameter {
	if m != nil {
		return m.MemoryDataParam
	}
	return nil
}

func (m *V1LayerParameter) GetMvnParam() *MVNParameter {
	if m != nil {
		return m.MvnParam
	}
	return nil
}

func (m *V1LayerParameter) GetPoolingParam() *PoolingParameter {
	if m != nil {
		return m.PoolingParam
	}
	return nil
}

func (m *V1LayerParameter) GetPowerParam() *PowerParameter {
	if m != nil {
		return m.PowerParam
	}
	return nil
}

func (m *V1LayerParameter) GetReluParam() *ReLUParameter {
	if m != nil {
		return m.ReluParam
	}
	return nil
}

func (m *V1LayerParameter) GetSigmoidParam() *SigmoidParameter {
	if m != nil {
		return m.SigmoidParam
	}
	return nil
}

func (m *V1LayerParameter) GetSoftmaxParam() *SoftmaxParameter {
	if m != nil {
		return m.SoftmaxParam
	}
	return nil
}

func (m *V1LayerParameter) GetSliceParam() *SliceParameter {
	if m != nil {
		return m.SliceParam
	}
	return nil
}

func (m *V1LayerParameter) GetTanhParam() *TanHParameter {
	if m != nil {
		return m.TanhParam
	}
	return nil
}

func (m *V1LayerParameter) GetThresholdParam() *ThresholdParameter {
	if m != nil {
		return m.ThresholdParam
	}
	return nil
}

func (m *V1LayerParameter) GetWindowDataParam() *WindowDataParameter {
	if m != nil {
		return m.WindowDataParam
	}
	return nil
}

func (m *V1LayerParameter) GetTransformParam() *TransformationParameter {
	if m != nil {
		return m.TransformParam
	}
	return nil
}

func (m *V1LayerParameter) GetLossParam() *LossParameter {
	if m != nil {
		return m.LossParam
	}
	return nil
}

func (m *V1LayerParameter) GetLayer() *V0LayerParameter {
	if m != nil {
		return m.Layer
	}
	return nil
}

// DEPRECATED: V0LayerParameter is the old way of specifying layer parameters
// in Caffe.  We keep this message type around for legacy support.
type V0LayerParameter struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Type string `protobuf:"bytes,2,opt,name=type" json:"type"`
	// Parameters to specify layers with inner products.
	NumOutput    uint32                       `protobuf:"varint,3,opt,name=num_output,json=numOutput" json:"num_output"`
	Biasterm     *bool                        `protobuf:"varint,4,opt,name=biasterm,def=1" json:"biasterm,omitempty"`
	WeightFiller *FillerParameter             `protobuf:"bytes,5,opt,name=weight_filler,json=weightFiller" json:"weight_filler,omitempty"`
	BiasFiller   *FillerParameter             `protobuf:"bytes,6,opt,name=bias_filler,json=biasFiller" json:"bias_filler,omitempty"`
	Pad          *uint32                      `protobuf:"varint,7,opt,name=pad,def=0" json:"pad,omitempty"`
	Kernelsize   uint32                       `protobuf:"varint,8,opt,name=kernelsize" json:"kernelsize"`
	Group        *uint32                      `protobuf:"varint,9,opt,name=group,def=1" json:"group,omitempty"`
	Stride       *uint32                      `protobuf:"varint,10,opt,name=stride,def=1" json:"stride,omitempty"`
	Pool         *V0LayerParameter_PoolMethod `protobuf:"varint,11,opt,name=pool,enum=caffe.V0LayerParameter_PoolMethod,def=0" json:"pool,omitempty"`
	DropoutRatio *float32                     `protobuf:"fixed32,12,opt,name=dropout_ratio,json=dropoutRatio,def=0.5" json:"dropout_ratio,omitempty"`
	LocalSize    *uint32                      `protobuf:"varint,13,opt,name=local_size,json=localSize,def=5" json:"local_size,omitempty"`
	Alpha        *float32                     `protobuf:"fixed32,14,opt,name=alpha,def=1" json:"alpha,omitempty"`
	Beta         *float32                     `protobuf:"fixed32,15,opt,name=beta,def=0.75" json:"beta,omitempty"`
	K            *float32                     `protobuf:"fixed32,22,opt,name=k,def=1" json:"k,omitempty"`
	// For data layers, specify the data source
	Source string `protobuf:"bytes,16,opt,name=source" json:"source"`
	// For data pre-processing, we can do simple scaling and subtracting the
	// data mean, if provided. Note that the mean subtraction is always carried
	// out before scaling.
	Scale    *float32 `protobuf:"fixed32,17,opt,name=scale,def=1" json:"scale,omitempty"`
	Meanfile string   `protobuf:"bytes,18,opt,name=meanfile" json:"meanfile"`
	// For data layers, specify the batch size.
	Batchsize uint32 `protobuf:"varint,19,opt,name=batchsize" json:"batchsize"`
	// For data layers, specify if we would like to randomly crop an image.
	Cropsize *uint32 `protobuf:"varint,20,opt,name=cropsize,def=0" json:"cropsize,omitempty"`
	// For data layers, specify if we want to randomly mirror data.
	Mirror *bool `protobuf:"varint,21,opt,name=mirror,def=0" json:"mirror,omitempty"`
	// The blobs containing the numeric parameters of the layer
	Blobs []*BlobProto `protobuf:"bytes,50,rep,name=blobs" json:"blobs,omitempty"`
	// The ratio that is multiplied on the global learning rate. If you want to
	// set the learning ratio for one blob, you need to set it for all blobs.
	BlobsLr []float32 `protobuf:"fixed32,51,rep,name=blobs_lr,json=blobsLr" json:"blobs_lr,omitempty"`
	// The weight decay that is multiplied on the global weight decay.
	WeightDecay []float32 `protobuf:"fixed32,52,rep,name=weight_decay,json=weightDecay" json:"weight_decay,omitempty"`
	// The rand_skip variable is for the data layer to skip a few data points
	// to avoid all asynchronous sgd clients to start at the same point. The skip
	// point would be set as rand_skip * rand(0,1). Note that rand_skip should not
	// be larger than the number of keys in the database.
	RandSkip *uint32 `protobuf:"varint,53,opt,name=rand_skip,json=randSkip,def=0" json:"rand_skip,omitempty"`
	// Fields related to detection (det_*)
	// foreground (object) overlap threshold
	DetFgThreshold *float32 `protobuf:"fixed32,54,opt,name=det_fg_threshold,json=detFgThreshold,def=0.5" json:"det_fg_threshold,omitempty"`
	// background (non-object) overlap threshold
	DetBgThreshold *float32 `protobuf:"fixed32,55,opt,name=det_bg_threshold,json=detBgThreshold,def=0.5" json:"det_bg_threshold,omitempty"`
	// Fraction of batch that should be foreground objects
	DetFgFraction *float32 `protobuf:"fixed32,56,opt,name=det_fg_fraction,json=detFgFraction,def=0.25" json:"det_fg_fraction,omitempty"`
	// Amount of contextual padding to add around a window
	// (used only by the window_data_layer)
	DetContextPad *uint32 `protobuf:"varint,58,opt,name=det_context_pad,json=detContextPad,def=0" json:"det_context_pad,omitempty"`
	// Mode for cropping out a detection window
	// warp: cropped window is warped to a fixed size and aspect ratio
	// square: the tightest square around the window is cropped
	DetCropMode *string `protobuf:"bytes,59,opt,name=det_crop_mode,json=detCropMode,def=warp" json:"det_crop_mode,omitempty"`
	// For ReshapeLayer, one needs to specify the new dimensions.
	NewNum      *int32 `protobuf:"varint,60,opt,name=new_num,json=newNum,def=0" json:"new_num,omitempty"`
	NewChannels *int32 `protobuf:"varint,61,opt,name=new_channels,json=newChannels,def=0" json:"new_channels,omitempty"`
	NewHeight   *int32 `protobuf:"varint,62,opt,name=new_height,json=newHeight,def=0" json:"new_height,omitempty"`
	NewWidth    *int32 `protobuf:"varint,63,opt,name=new_width,json=newWidth,def=0" json:"new_width,omitempty"`
	// Whether or not ImageLayer should shuffle the list of files at every epoch.
	// It will also resize images if new_height or new_width are not zero.
	ShuffleImages *bool `protobuf:"varint,64,opt,name=shuffle_images,json=shuffleImages,def=0" json:"shuffle_images,omitempty"`
	// For ConcatLayer, one needs to specify the dimension for concatenation, and
	// the other dimensions must be the same for all the bottom blobs.
	// By default it will concatenate blobs along the channels dimension.
	ConcatDim       *uint32              `protobuf:"varint,65,opt,name=concat_dim,json=concatDim,def=1" json:"concat_dim,omitempty"`
	Hdf5OutputParam *HDF5OutputParameter `protobuf:"bytes,1001,opt,name=hdf5_output_param,json=hdf5OutputParam" json:"hdf5_output_param,omitempty"`
}

func (m *V0LayerParameter) Reset()         { *m = V0LayerParameter{} }
func (m *V0LayerParameter) String() string { return proto.CompactTextString(m) }
func (*V0LayerParameter) ProtoMessage()    {}
func (*V0LayerParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{59}
}
func (m *V0LayerParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *V0LayerParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_V0LayerParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *V0LayerParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_V0LayerParameter.Merge(dst, src)
}
func (m *V0LayerParameter) XXX_Size() int {
	return m.Size()
}
func (m *V0LayerParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_V0LayerParameter.DiscardUnknown(m)
}

var xxx_messageInfo_V0LayerParameter proto.InternalMessageInfo

const Default_V0LayerParameter_Biasterm bool = true
const Default_V0LayerParameter_Pad uint32 = 0
const Default_V0LayerParameter_Group uint32 = 1
const Default_V0LayerParameter_Stride uint32 = 1
const Default_V0LayerParameter_Pool V0LayerParameter_PoolMethod = V0LayerParameter_MAX
const Default_V0LayerParameter_DropoutRatio float32 = 0.5
const Default_V0LayerParameter_LocalSize uint32 = 5
const Default_V0LayerParameter_Alpha float32 = 1
const Default_V0LayerParameter_Beta float32 = 0.75
const Default_V0LayerParameter_K float32 = 1
const Default_V0LayerParameter_Scale float32 = 1
const Default_V0LayerParameter_Cropsize uint32 = 0
const Default_V0LayerParameter_Mirror bool = false
const Default_V0LayerParameter_RandSkip uint32 = 0
const Default_V0LayerParameter_DetFgThreshold float32 = 0.5
const Default_V0LayerParameter_DetBgThreshold float32 = 0.5
const Default_V0LayerParameter_DetFgFraction float32 = 0.25
const Default_V0LayerParameter_DetContextPad uint32 = 0
const Default_V0LayerParameter_DetCropMode string = "warp"
const Default_V0LayerParameter_NewNum int32 = 0
const Default_V0LayerParameter_NewChannels int32 = 0
const Default_V0LayerParameter_NewHeight int32 = 0
const Default_V0LayerParameter_NewWidth int32 = 0
const Default_V0LayerParameter_ShuffleImages bool = false
const Default_V0LayerParameter_ConcatDim uint32 = 1

func (m *V0LayerParameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *V0LayerParameter) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *V0LayerParameter) GetNumOutput() uint32 {
	if m != nil {
		return m.NumOutput
	}
	return 0
}

func (m *V0LayerParameter) GetBiasterm() bool {
	if m != nil && m.Biasterm != nil {
		return *m.Biasterm
	}
	return Default_V0LayerParameter_Biasterm
}

func (m *V0LayerParameter) GetWeightFiller() *FillerParameter {
	if m != nil {
		return m.WeightFiller
	}
	return nil
}

func (m *V0LayerParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

func (m *V0LayerParameter) GetPad() uint32 {
	if m != nil && m.Pad != nil {
		return *m.Pad
	}
	return Default_V0LayerParameter_Pad
}

func (m *V0LayerParameter) GetKernelsize() uint32 {
	if m != nil {
		return m.Kernelsize
	}
	return 0
}

func (m *V0LayerParameter) GetGroup() uint32 {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return Default_V0LayerParameter_Group
}

func (m *V0LayerParameter) GetStride() uint32 {
	if m != nil && m.Stride != nil {
		return *m.Stride
	}
	return Default_V0LayerParameter_Stride
}

func (m *V0LayerParameter) GetPool() V0LayerParameter_PoolMethod {
	if m != nil && m.Pool != nil {
		return *m.Pool
	}
	return Default_V0LayerParameter_Pool
}

func (m *V0LayerParameter) GetDropoutRatio() float32 {
	if m != nil && m.DropoutRatio != nil {
		return *m.DropoutRatio
	}
	return Default_V0LayerParameter_DropoutRatio
}

func (m *V0LayerParameter) GetLocalSize() uint32 {
	if m != nil && m.LocalSize != nil {
		return *m.LocalSize
	}
	return Default_V0LayerParameter_LocalSize
}

func (m *V0LayerParameter) GetAlpha() float32 {
	if m != nil && m.Alpha != nil {
		return *m.Alpha
	}
	return Default_V0LayerParameter_Alpha
}

func (m *V0LayerParameter) GetBeta() float32 {
	if m != nil && m.Beta != nil {
		return *m.Beta
	}
	return Default_V0LayerParameter_Beta
}

func (m *V0LayerParameter) GetK() float32 {
	if m != nil && m.K != nil {
		return *m.K
	}
	return Default_V0LayerParameter_K
}

func (m *V0LayerParameter) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *V0LayerParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_V0LayerParameter_Scale
}

func (m *V0LayerParameter) GetMeanfile() string {
	if m != nil {
		return m.Meanfile
	}
	return ""
}

func (m *V0LayerParameter) GetBatchsize() uint32 {
	if m != nil {
		return m.Batchsize
	}
	return 0
}

func (m *V0LayerParameter) GetCropsize() uint32 {
	if m != nil && m.Cropsize != nil {
		return *m.Cropsize
	}
	return Default_V0LayerParameter_Cropsize
}

func (m *V0LayerParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_V0LayerParameter_Mirror
}

func (m *V0LayerParameter) GetBlobs() []*BlobProto {
	if m != nil {
		return m.Blobs
	}
	return nil
}

func (m *V0LayerParameter) GetBlobsLr() []float32 {
	if m != nil {
		return m.BlobsLr
	}
	return nil
}

func (m *V0LayerParameter) GetWeightDecay() []float32 {
	if m != nil {
		return m.WeightDecay
	}
	return nil
}

func (m *V0LayerParameter) GetRandSkip() uint32 {
	if m != nil && m.RandSkip != nil {
		return *m.RandSkip
	}
	return Default_V0LayerParameter_RandSkip
}

func (m *V0LayerParameter) GetDetFgThreshold() float32 {
	if m != nil && m.DetFgThreshold != nil {
		return *m.DetFgThreshold
	}
	return Default_V0LayerParameter_DetFgThreshold
}

func (m *V0LayerParameter) GetDetBgThreshold() float32 {
	if m != nil && m.DetBgThreshold != nil {
		return *m.DetBgThreshold
	}
	return Default_V0LayerParameter_DetBgThreshold
}

func (m *V0LayerParameter) GetDetFgFraction() float32 {
	if m != nil && m.DetFgFraction != nil {
		return *m.DetFgFraction
	}
	return Default_V0LayerParameter_DetFgFraction
}

func (m *V0LayerParameter) GetDetContextPad() uint32 {
	if m != nil && m.DetContextPad != nil {
		return *m.DetContextPad
	}
	return Default_V0LayerParameter_DetContextPad
}

func (m *V0LayerParameter) GetDetCropMode() string {
	if m != nil && m.DetCropMode != nil {
		return *m.DetCropMode
	}
	return Default_V0LayerParameter_DetCropMode
}

func (m *V0LayerParameter) GetNewNum() int32 {
	if m != nil && m.NewNum != nil {
		return *m.NewNum
	}
	return Default_V0LayerParameter_NewNum
}

func (m *V0LayerParameter) GetNewChannels() int32 {
	if m != nil && m.NewChannels != nil {
		return *m.NewChannels
	}
	return Default_V0LayerParameter_NewChannels
}

func (m *V0LayerParameter) GetNewHeight() int32 {
	if m != nil && m.NewHeight != nil {
		return *m.NewHeight
	}
	return Default_V0LayerParameter_NewHeight
}

func (m *V0LayerParameter) GetNewWidth() int32 {
	if m != nil && m.NewWidth != nil {
		return *m.NewWidth
	}
	return Default_V0LayerParameter_NewWidth
}

func (m *V0LayerParameter) GetShuffleImages() bool {
	if m != nil && m.ShuffleImages != nil {
		return *m.ShuffleImages
	}
	return Default_V0LayerParameter_ShuffleImages
}

func (m *V0LayerParameter) GetConcatDim() uint32 {
	if m != nil && m.ConcatDim != nil {
		return *m.ConcatDim
	}
	return Default_V0LayerParameter_ConcatDim
}

func (m *V0LayerParameter) GetHdf5OutputParam() *HDF5OutputParameter {
	if m != nil {
		return m.Hdf5OutputParam
	}
	return nil
}

type PReLUParameter struct {
	// Initial value of a_i. Default is a_i=0.25 for all i.
	Filler *FillerParameter `protobuf:"bytes,1,opt,name=filler" json:"filler,omitempty"`
	// Whether or not slope paramters are shared across channels.
	ChannelShared *bool `protobuf:"varint,2,opt,name=channel_shared,json=channelShared,def=0" json:"channel_shared,omitempty"`
}

func (m *PReLUParameter) Reset()         { *m = PReLUParameter{} }
func (m *PReLUParameter) String() string { return proto.CompactTextString(m) }
func (*PReLUParameter) ProtoMessage()    {}
func (*PReLUParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_caffe_1be6848cf218e0b1, []int{60}
}
func (m *PReLUParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PReLUParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PReLUParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PReLUParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PReLUParameter.Merge(dst, src)
}
func (m *PReLUParameter) XXX_Size() int {
	return m.Size()
}
func (m *PReLUParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_PReLUParameter.DiscardUnknown(m)
}

var xxx_messageInfo_PReLUParameter proto.InternalMessageInfo

const Default_PReLUParameter_ChannelShared bool = false

func (m *PReLUParameter) GetFiller() *FillerParameter {
	if m != nil {
		return m.Filler
	}
	return nil
}

func (m *PReLUParameter) GetChannelShared() bool {
	if m != nil && m.ChannelShared != nil {
		return *m.ChannelShared
	}
	return Default_PReLUParameter_ChannelShared
}

func disabled_init1() {
	proto.RegisterType((*BlobShape)(nil), "caffe.BlobShape")
	proto.RegisterType((*BlobProto)(nil), "caffe.BlobProto")
	proto.RegisterType((*BlobProtoVector)(nil), "caffe.BlobProtoVector")
	proto.RegisterType((*Datum)(nil), "caffe.Datum")
	proto.RegisterType((*FillerParameter)(nil), "caffe.FillerParameter")
	proto.RegisterType((*NetParameter)(nil), "caffe.NetParameter")
	proto.RegisterType((*SolverParameter)(nil), "caffe.SolverParameter")
	proto.RegisterType((*SolverState)(nil), "caffe.SolverState")
	proto.RegisterType((*NetState)(nil), "caffe.NetState")
	proto.RegisterType((*NetStateRule)(nil), "caffe.NetStateRule")
	proto.RegisterType((*ParamSpec)(nil), "caffe.ParamSpec")
	proto.RegisterType((*LayerParameter)(nil), "caffe.LayerParameter")
	proto.RegisterType((*TransformationParameter)(nil), "caffe.TransformationParameter")
	proto.RegisterType((*LossParameter)(nil), "caffe.LossParameter")
	proto.RegisterType((*AccuracyParameter)(nil), "caffe.AccuracyParameter")
	proto.RegisterType((*ArgMaxParameter)(nil), "caffe.ArgMaxParameter")
	proto.RegisterType((*ConcatParameter)(nil), "caffe.ConcatParameter")
	proto.RegisterType((*BatchNormParameter)(nil), "caffe.BatchNormParameter")
	proto.RegisterType((*BiasParameter)(nil), "caffe.BiasParameter")
	proto.RegisterType((*ContrastiveLossParameter)(nil), "caffe.ContrastiveLossParameter")
	proto.RegisterType((*ConvolutionParameter)(nil), "caffe.ConvolutionParameter")
	proto.RegisterType((*CropParameter)(nil), "caffe.CropParameter")
	proto.RegisterType((*DataParameter)(nil), "caffe.DataParameter")
	proto.RegisterType((*DropoutParameter)(nil), "caffe.DropoutParameter")
	proto.RegisterType((*DummyDataParameter)(nil), "caffe.DummyDataParameter")
	proto.RegisterType((*EltwiseParameter)(nil), "caffe.EltwiseParameter")
	proto.RegisterType((*ELUParameter)(nil), "caffe.ELUParameter")
	proto.RegisterType((*EmbedParameter)(nil), "caffe.EmbedParameter")
	proto.RegisterType((*ExpParameter)(nil), "caffe.ExpParameter")
	proto.RegisterType((*FlattenParameter)(nil), "caffe.FlattenParameter")
	proto.RegisterType((*HDF5DataParameter)(nil), "caffe.HDF5DataParameter")
	proto.RegisterType((*HDF5OutputParameter)(nil), "caffe.HDF5OutputParameter")
	proto.RegisterType((*HingeLossParameter)(nil), "caffe.HingeLossParameter")
	proto.RegisterType((*ImageDataParameter)(nil), "caffe.ImageDataParameter")
	proto.RegisterType((*InfogainLossParameter)(nil), "caffe.InfogainLossParameter")
	proto.RegisterType((*InnerProductParameter)(nil), "caffe.InnerProductParameter")
	proto.RegisterType((*InputParameter)(nil), "caffe.InputParameter")
	proto.RegisterType((*LogParameter)(nil), "caffe.LogParameter")
	proto.RegisterType((*LRNParameter)(nil), "caffe.LRNParameter")
	proto.RegisterType((*MemoryDataParameter)(nil), "caffe.MemoryDataParameter")
	proto.RegisterType((*MVNParameter)(nil), "caffe.MVNParameter")
	proto.RegisterType((*ParameterParameter)(nil), "caffe.ParameterParameter")
	proto.RegisterType((*PoolingParameter)(nil), "caffe.PoolingParameter")
	proto.RegisterType((*PowerParameter)(nil), "caffe.PowerParameter")
	proto.RegisterType((*PythonParameter)(nil), "caffe.PythonParameter")
	proto.RegisterType((*RecurrentParameter)(nil), "caffe.RecurrentParameter")
	proto.RegisterType((*ReductionParameter)(nil), "caffe.ReductionParameter")
	proto.RegisterType((*ReLUParameter)(nil), "caffe.ReLUParameter")
	proto.RegisterType((*ReshapeParameter)(nil), "caffe.ReshapeParameter")
	proto.RegisterType((*ScaleParameter)(nil), "caffe.ScaleParameter")
	proto.RegisterType((*SigmoidParameter)(nil), "caffe.SigmoidParameter")
	proto.RegisterType((*SliceParameter)(nil), "caffe.SliceParameter")
	proto.RegisterType((*SoftmaxParameter)(nil), "caffe.SoftmaxParameter")
	proto.RegisterType((*TanHParameter)(nil), "caffe.TanHParameter")
	proto.RegisterType((*TileParameter)(nil), "caffe.TileParameter")
	proto.RegisterType((*ThresholdParameter)(nil), "caffe.ThresholdParameter")
	proto.RegisterType((*WindowDataParameter)(nil), "caffe.WindowDataParameter")
	proto.RegisterType((*SPPParameter)(nil), "caffe.SPPParameter")
	proto.RegisterType((*V1LayerParameter)(nil), "caffe.V1LayerParameter")
	proto.RegisterType((*V0LayerParameter)(nil), "caffe.V0LayerParameter")
	proto.RegisterType((*PReLUParameter)(nil), "caffe.PReLUParameter")
	proto.RegisterEnum("caffe.Phase", Phase_name, Phase_value)
	proto.RegisterEnum("caffe.FillerParameter_VarianceNorm", FillerParameter_VarianceNorm_name, FillerParameter_VarianceNorm_value)
	proto.RegisterEnum("caffe.SolverParameter_SnapshotFormat", SolverParameter_SnapshotFormat_name, SolverParameter_SnapshotFormat_value)
	proto.RegisterEnum("caffe.SolverParameter_SolverMode", SolverParameter_SolverMode_name, SolverParameter_SolverMode_value)
	proto.RegisterEnum("caffe.SolverParameter_SolverType", SolverParameter_SolverType_name, SolverParameter_SolverType_value)
	proto.RegisterEnum("caffe.ParamSpec_DimCheckMode", ParamSpec_DimCheckMode_name, ParamSpec_DimCheckMode_value)
	proto.RegisterEnum("caffe.LossParameter_NormalizationMode", LossParameter_NormalizationMode_name, LossParameter_NormalizationMode_value)
	proto.RegisterEnum("caffe.ConvolutionParameter_Engine", ConvolutionParameter_Engine_name, ConvolutionParameter_Engine_value)
	proto.RegisterEnum("caffe.DataParameter_DB", DataParameter_DB_name, DataParameter_DB_value)
	proto.RegisterEnum("caffe.EltwiseParameter_EltwiseOp", EltwiseParameter_EltwiseOp_name, EltwiseParameter_EltwiseOp_value)
	proto.RegisterEnum("caffe.HingeLossParameter_Norm", HingeLossParameter_Norm_name, HingeLossParameter_Norm_value)
	proto.RegisterEnum("caffe.LRNParameter_NormRegion", LRNParameter_NormRegion_name, LRNParameter_NormRegion_value)
	proto.RegisterEnum("caffe.LRNParameter_Engine", LRNParameter_Engine_name, LRNParameter_Engine_value)
	proto.RegisterEnum("caffe.PoolingParameter_PoolMethod", PoolingParameter_PoolMethod_name, PoolingParameter_PoolMethod_value)
	proto.RegisterEnum("caffe.PoolingParameter_Engine", PoolingParameter_Engine_name, PoolingParameter_Engine_value)
	proto.RegisterEnum("caffe.ReductionParameter_ReductionOp", ReductionParameter_ReductionOp_name, ReductionParameter_ReductionOp_value)
	proto.RegisterEnum("caffe.ReLUParameter_Engine", ReLUParameter_Engine_name, ReLUParameter_Engine_value)
	proto.RegisterEnum("caffe.SigmoidParameter_Engine", SigmoidParameter_Engine_name, SigmoidParameter_Engine_value)
	proto.RegisterEnum("caffe.SoftmaxParameter_Engine", SoftmaxParameter_Engine_name, SoftmaxParameter_Engine_value)
	proto.RegisterEnum("caffe.TanHParameter_Engine", TanHParameter_Engine_name, TanHParameter_Engine_value)
	proto.RegisterEnum("caffe.SPPParameter_PoolMethod", SPPParameter_PoolMethod_name, SPPParameter_PoolMethod_value)
	proto.RegisterEnum("caffe.SPPParameter_Engine", SPPParameter_Engine_name, SPPParameter_Engine_value)
	proto.RegisterEnum("caffe.V1LayerParameter_LayerType", V1LayerParameter_LayerType_name, V1LayerParameter_LayerType_value)
	proto.RegisterEnum("caffe.V1LayerParameter_DimCheckMode", V1LayerParameter_DimCheckMode_name, V1LayerParameter_DimCheckMode_value)
	proto.RegisterEnum("caffe.V0LayerParameter_PoolMethod", V0LayerParameter_PoolMethod_name, V0LayerParameter_PoolMethod_value)
}
func (m *BlobShape) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobShape) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dim) > 0 {
		dAtA2 := make([]byte, len(m.Dim)*10)
		var j1 int
		for _, num1 := range m.Dim {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *BlobProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Num != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Num))
	}
	if m.Channels != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Channels))
	}
	if m.Height != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Height))
	}
	if m.Width != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Width))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(len(m.Data)*4))
		for _, num := range m.Data {
			f3 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f3))
			i += 4
		}
	}
	if len(m.Diff) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(len(m.Diff)*4))
		for _, num := range m.Diff {
			f4 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f4))
			i += 4
		}
	}
	if m.Shape != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.Shape.Size()))
		n5, err := m.Shape.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.DoubleData) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(len(m.DoubleData)*8))
		for _, num := range m.DoubleData {
			f6 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f6))
			i += 8
		}
	}
	if len(m.DoubleDiff) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(len(m.DoubleDiff)*8))
		for _, num := range m.DoubleDiff {
			f7 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f7))
			i += 8
		}
	}
	return i, nil
}

func (m *BlobProtoVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobProtoVector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Blobs) > 0 {
		for _, msg := range m.Blobs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Datum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Datum) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Channels))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Height))
	dAtA[i] = 0x18
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Width))
	if m.Data != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Label))
	if len(m.FloatData) > 0 {
		for _, num := range m.FloatData {
			dAtA[i] = 0x35
			i++
			f8 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f8))
			i += 4
		}
	}
	if m.Encoded != nil {
		dAtA[i] = 0x38
		i++
		if *m.Encoded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FillerParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FillerParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(len(*m.Type)))
		i += copy(dAtA[i:], *m.Type)
	}
	if m.Value != nil {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Value))))
		i += 4
	}
	if m.Min != nil {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Min))))
		i += 4
	}
	if m.Max != nil {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Max))))
		i += 4
	}
	if m.Mean != nil {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Mean))))
		i += 4
	}
	if m.Std != nil {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Std))))
		i += 4
	}
	if m.Sparse != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Sparse))
	}
	if m.VarianceNorm != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.VarianceNorm))
	}
	return i, nil
}

func (m *NetParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if len(m.Layers) > 0 {
		for _, msg := range m.Layers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Input) > 0 {
		for _, s := range m.Input {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.InputDim) > 0 {
		for _, num := range m.InputDim {
			dAtA[i] = 0x20
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	if m.ForceBackward != nil {
		dAtA[i] = 0x28
		i++
		if *m.ForceBackward {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.State != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.State.Size()))
		n9, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.DebugInfo != nil {
		dAtA[i] = 0x38
		i++
		if *m.DebugInfo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.InputShape) > 0 {
		for _, msg := range m.InputShape {
			dAtA[i] = 0x42
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Layer) > 0 {
		for _, msg := range m.Layer {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SolverParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SolverParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.TrainNet)))
	i += copy(dAtA[i:], m.TrainNet)
	if len(m.TestNet) > 0 {
		for _, s := range m.TestNet {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.TestIter) > 0 {
		for _, num := range m.TestIter {
			dAtA[i] = 0x18
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	if m.TestInterval != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.TestInterval))
	}
	dAtA[i] = 0x2d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BaseLr))))
	i += 4
	dAtA[i] = 0x30
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Display))
	dAtA[i] = 0x38
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.MaxIter))
	dAtA[i] = 0x42
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.LrPolicy)))
	i += copy(dAtA[i:], m.LrPolicy)
	dAtA[i] = 0x4d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Gamma))))
	i += 4
	dAtA[i] = 0x55
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Power))))
	i += 4
	dAtA[i] = 0x5d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Momentum))))
	i += 4
	dAtA[i] = 0x65
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WeightDecay))))
	i += 4
	dAtA[i] = 0x68
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Stepsize))
	if m.Snapshot != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Snapshot))
	}
	dAtA[i] = 0x7a
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.SnapshotPrefix)))
	i += copy(dAtA[i:], m.SnapshotPrefix)
	if m.SnapshotDiff != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if *m.SnapshotDiff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SolverMode != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.SolverMode))
	}
	if m.DeviceId != nil {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.DeviceId))
	}
	if m.TestComputeLoss != nil {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if *m.TestComputeLoss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RandomSeed != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.RandomSeed))
	}
	if m.TrainNetParam != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.TrainNetParam.Size()))
		n10, err := m.TrainNetParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.TestNetParam) > 0 {
		for _, msg := range m.TestNetParam {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DebugInfo != nil {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if *m.DebugInfo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0xc2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Net)))
	i += copy(dAtA[i:], m.Net)
	if m.NetParam != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.NetParam.Size()))
		n11, err := m.NetParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.TrainState != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.TrainState.Size()))
		n12, err := m.TrainState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.TestState) > 0 {
		for _, msg := range m.TestState {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SnapshotAfterTrain != nil {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		if *m.SnapshotAfterTrain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RegularizationType != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(len(*m.RegularizationType)))
		i += copy(dAtA[i:], *m.RegularizationType)
	}
	if m.SolverType != nil {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.SolverType))
	}
	if m.Delta != nil {
		dAtA[i] = 0xfd
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Delta))))
		i += 4
	}
	if m.TestInitialization != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		if *m.TestInitialization {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AverageLoss != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.AverageLoss))
	}
	if len(m.Stepvalue) > 0 {
		for _, num := range m.Stepvalue {
			dAtA[i] = 0x90
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	if m.ClipGradients != nil {
		dAtA[i] = 0x9d
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.ClipGradients))))
		i += 4
	}
	if m.IterSize != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.IterSize))
	}
	if m.SnapshotFormat != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.SnapshotFormat))
	}
	dAtA[i] = 0xb5
	i++
	dAtA[i] = 0x2
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RmsDecay))))
	i += 4
	if m.Momentum2 != nil {
		dAtA[i] = 0xbd
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Momentum2))))
		i += 4
	}
	if m.Type != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(len(*m.Type)))
		i += copy(dAtA[i:], *m.Type)
	}
	return i, nil
}

func (m *SolverState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SolverState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Iter))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.LearnedNet)))
	i += copy(dAtA[i:], m.LearnedNet)
	if len(m.History) > 0 {
		for _, msg := range m.History {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CurrentStep != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.CurrentStep))
	}
	return i, nil
}

func (m *NetState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Phase != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Phase))
	}
	if m.Level != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Level))
	}
	if len(m.Stage) > 0 {
		for _, s := range m.Stage {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *NetStateRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetStateRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Phase))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.MinLevel))
	dAtA[i] = 0x18
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.MaxLevel))
	if len(m.Stage) > 0 {
		for _, s := range m.Stage {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.NotStage) > 0 {
		for _, s := range m.NotStage {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ParamSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParamSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.ShareMode))
	if m.LrMult != nil {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LrMult))))
		i += 4
	}
	if m.DecayMult != nil {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DecayMult))))
		i += 4
	}
	return i, nil
}

func (m *LayerParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LayerParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Type)))
	i += copy(dAtA[i:], m.Type)
	if len(m.Bottom) > 0 {
		for _, s := range m.Bottom {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Top) > 0 {
		for _, s := range m.Top {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.LossWeight) > 0 {
		for _, num := range m.LossWeight {
			dAtA[i] = 0x2d
			i++
			f13 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f13))
			i += 4
		}
	}
	if len(m.Param) > 0 {
		for _, msg := range m.Param {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Blobs) > 0 {
		for _, msg := range m.Blobs {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Include) > 0 {
		for _, msg := range m.Include {
			dAtA[i] = 0x42
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Exclude) > 0 {
		for _, msg := range m.Exclude {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x50
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Phase))
	if len(m.PropagateDown) > 0 {
		for _, b := range m.PropagateDown {
			dAtA[i] = 0x58
			i++
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.TransformParam != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.TransformParam.Size()))
		n14, err := m.TransformParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.LossParam != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.LossParam.Size()))
		n15, err := m.LossParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.AccuracyParam != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.AccuracyParam.Size()))
		n16, err := m.AccuracyParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.ArgmaxParam != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ArgmaxParam.Size()))
		n17, err := m.ArgmaxParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.ConcatParam != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ConcatParam.Size()))
		n18, err := m.ConcatParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.ContrastiveLossParam != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ContrastiveLossParam.Size()))
		n19, err := m.ContrastiveLossParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.ConvolutionParam != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ConvolutionParam.Size()))
		n20, err := m.ConvolutionParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.DataParam != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.DataParam.Size()))
		n21, err := m.DataParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.DropoutParam != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.DropoutParam.Size()))
		n22, err := m.DropoutParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.DummyDataParam != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.DummyDataParam.Size()))
		n23, err := m.DummyDataParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.EltwiseParam != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.EltwiseParam.Size()))
		n24, err := m.EltwiseParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.ExpParam != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ExpParam.Size()))
		n25, err := m.ExpParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Hdf5DataParam != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.Hdf5DataParam.Size()))
		n26, err := m.Hdf5DataParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Hdf5OutputParam != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.Hdf5OutputParam.Size()))
		n27, err := m.Hdf5OutputParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.HingeLossParam != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.HingeLossParam.Size()))
		n28, err := m.HingeLossParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.ImageDataParam != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ImageDataParam.Size()))
		n29, err := m.ImageDataParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.InfogainLossParam != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.InfogainLossParam.Size()))
		n30, err := m.InfogainLossParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.InnerProductParam != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.InnerProductParam.Size()))
		n31, err := m.InnerProductParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.LrnParam != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.LrnParam.Size()))
		n32, err := m.LrnParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.MemoryDataParam != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.MemoryDataParam.Size()))
		n33, err := m.MemoryDataParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.MvnParam != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.MvnParam.Size()))
		n34, err := m.MvnParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.PoolingParam != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.PoolingParam.Size()))
		n35, err := m.PoolingParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.PowerParam != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.PowerParam.Size()))
		n36, err := m.PowerParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.ReluParam != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ReluParam.Size()))
		n37, err := m.ReluParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.SigmoidParam != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.SigmoidParam.Size()))
		n38, err := m.SigmoidParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.SoftmaxParam != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.SoftmaxParam.Size()))
		n39, err := m.SoftmaxParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.SliceParam != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.SliceParam.Size()))
		n40, err := m.SliceParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.TanhParam != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.TanhParam.Size()))
		n41, err := m.TanhParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.ThresholdParam != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ThresholdParam.Size()))
		n42, err := m.ThresholdParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.WindowDataParam != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.WindowDataParam.Size()))
		n43, err := m.WindowDataParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.PythonParam != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.PythonParam.Size()))
		n44, err := m.PythonParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.PreluParam != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.PreluParam.Size()))
		n45, err := m.PreluParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.SppParam != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.SppParam.Size()))
		n46, err := m.SppParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.ReshapeParam != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ReshapeParam.Size()))
		n47, err := m.ReshapeParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.LogParam != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.LogParam.Size()))
		n48, err := m.LogParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.FlattenParam != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.FlattenParam.Size()))
		n49, err := m.FlattenParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.ReductionParam != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ReductionParam.Size()))
		n50, err := m.ReductionParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.EmbedParam != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.EmbedParam.Size()))
		n51, err := m.EmbedParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.TileParam != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.TileParam.Size()))
		n52, err := m.TileParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.BatchNormParam != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.BatchNormParam.Size()))
		n53, err := m.BatchNormParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.EluParam != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.EluParam.Size()))
		n54, err := m.EluParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.BiasParam != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.BiasParam.Size()))
		n55, err := m.BiasParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.ScaleParam != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ScaleParam.Size()))
		n56, err := m.ScaleParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.InputParam != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.InputParam.Size()))
		n57, err := m.InputParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.CropParam != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x9
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.CropParam.Size()))
		n58, err := m.CropParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.ParameterParam != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x9
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ParameterParam.Size()))
		n59, err := m.ParameterParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.RecurrentParam != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x9
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.RecurrentParam.Size()))
		n60, err := m.RecurrentParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	return i, nil
}

func (m *TransformationParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransformationParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Scale != nil {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Scale))))
		i += 4
	}
	if m.Mirror != nil {
		dAtA[i] = 0x10
		i++
		if *m.Mirror {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CropSize != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.CropSize))
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.MeanFile)))
	i += copy(dAtA[i:], m.MeanFile)
	if len(m.MeanValue) > 0 {
		for _, num := range m.MeanValue {
			dAtA[i] = 0x2d
			i++
			f61 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f61))
			i += 4
		}
	}
	if m.ForceColor != nil {
		dAtA[i] = 0x30
		i++
		if *m.ForceColor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ForceGray != nil {
		dAtA[i] = 0x38
		i++
		if *m.ForceGray {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LossParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LossParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.IgnoreLabel))
	dAtA[i] = 0x10
	i++
	if m.Normalize {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Normalization != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Normalization))
	}
	return i, nil
}

func (m *AccuracyParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccuracyParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopK != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.TopK))
	}
	if m.Axis != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Axis))
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.IgnoreLabel))
	return i, nil
}

func (m *ArgMaxParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgMaxParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OutMaxVal != nil {
		dAtA[i] = 0x8
		i++
		if *m.OutMaxVal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TopK != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.TopK))
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Axis))
	return i, nil
}

func (m *ConcatParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConcatParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConcatDim != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.ConcatDim))
	}
	if m.Axis != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Axis))
	}
	return i, nil
}

func (m *BatchNormParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchNormParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.UseGlobalStats {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.MovingAverageFraction != nil {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MovingAverageFraction))))
		i += 4
	}
	if m.Eps != nil {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Eps))))
		i += 4
	}
	return i, nil
}

func (m *BiasParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BiasParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Axis != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Axis))
	}
	if m.NumAxes != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.NumAxes))
	}
	if m.Filler != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.Filler.Size()))
		n62, err := m.Filler.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}

func (m *ContrastiveLossParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContrastiveLossParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Margin != nil {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Margin))))
		i += 4
	}
	if m.LegacyVersion != nil {
		dAtA[i] = 0x10
		i++
		if *m.LegacyVersion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ConvolutionParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvolutionParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.NumOutput))
	if m.BiasTerm != nil {
		dAtA[i] = 0x10
		i++
		if *m.BiasTerm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Pad) > 0 {
		for _, num := range m.Pad {
			dAtA[i] = 0x18
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	if len(m.KernelSize) > 0 {
		for _, num := range m.KernelSize {
			dAtA[i] = 0x20
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	if m.Group != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Group))
	}
	if len(m.Stride) > 0 {
		for _, num := range m.Stride {
			dAtA[i] = 0x30
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	if m.WeightFiller != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.WeightFiller.Size()))
		n63, err := m.WeightFiller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.BiasFiller != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.BiasFiller.Size()))
		n64, err := m.BiasFiller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.PadH != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.PadH))
	}
	if m.PadW != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.PadW))
	}
	dAtA[i] = 0x58
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.KernelH))
	dAtA[i] = 0x60
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.KernelW))
	dAtA[i] = 0x68
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.StrideH))
	dAtA[i] = 0x70
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.StrideW))
	if m.Engine != nil {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Engine))
	}
	if m.Axis != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Axis))
	}
	if m.ForceNdIm2Col != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if *m.ForceNdIm2Col {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Dilation) > 0 {
		for _, num := range m.Dilation {
			dAtA[i] = 0x90
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CropParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CropParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Axis != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Axis))
	}
	if len(m.Offset) > 0 {
		for _, num := range m.Offset {
			dAtA[i] = 0x10
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *DataParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Source)))
	i += copy(dAtA[i:], m.Source)
	if m.Scale != nil {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Scale))))
		i += 4
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.MeanFile)))
	i += copy(dAtA[i:], m.MeanFile)
	dAtA[i] = 0x20
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.BatchSize))
	if m.CropSize != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.CropSize))
	}
	if m.Mirror != nil {
		dAtA[i] = 0x30
		i++
		if *m.Mirror {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RandSkip != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.RandSkip))
	}
	if m.Backend != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Backend))
	}
	if m.ForceEncodedColor != nil {
		dAtA[i] = 0x48
		i++
		if *m.ForceEncodedColor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Prefetch != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Prefetch))
	}
	return i, nil
}

func (m *DropoutParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropoutParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DropoutRatio != nil {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DropoutRatio))))
		i += 4
	}
	return i, nil
}

func (m *DummyDataParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DummyDataParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DataFiller) > 0 {
		for _, msg := range m.DataFiller {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Num) > 0 {
		for _, num := range m.Num {
			dAtA[i] = 0x10
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	if len(m.Channels) > 0 {
		for _, num := range m.Channels {
			dAtA[i] = 0x18
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	if len(m.Height) > 0 {
		for _, num := range m.Height {
			dAtA[i] = 0x20
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	if len(m.Width) > 0 {
		for _, num := range m.Width {
			dAtA[i] = 0x28
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	if len(m.Shape) > 0 {
		for _, msg := range m.Shape {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EltwiseParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EltwiseParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Operation != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Operation))
	}
	if len(m.Coeff) > 0 {
		for _, num := range m.Coeff {
			dAtA[i] = 0x15
			i++
			f65 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f65))
			i += 4
		}
	}
	if m.StableProdGrad != nil {
		dAtA[i] = 0x18
		i++
		if *m.StableProdGrad {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ELUParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ELUParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Alpha != nil {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Alpha))))
		i += 4
	}
	return i, nil
}

func (m *EmbedParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmbedParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.NumOutput))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.InputDim))
	if m.BiasTerm != nil {
		dAtA[i] = 0x18
		i++
		if *m.BiasTerm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WeightFiller != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.WeightFiller.Size()))
		n66, err := m.WeightFiller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.BiasFiller != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.BiasFiller.Size()))
		n67, err := m.BiasFiller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}

func (m *ExpParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Base != nil {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Base))))
		i += 4
	}
	if m.Scale != nil {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Scale))))
		i += 4
	}
	if m.Shift != nil {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Shift))))
		i += 4
	}
	return i, nil
}

func (m *FlattenParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlattenParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Axis != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Axis))
	}
	if m.EndAxis != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.EndAxis))
	}
	return i, nil
}

func (m *HDF5DataParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HDF5DataParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Source)))
	i += copy(dAtA[i:], m.Source)
	dAtA[i] = 0x10
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.BatchSize))
	if m.Shuffle != nil {
		dAtA[i] = 0x18
		i++
		if *m.Shuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *HDF5OutputParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HDF5OutputParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.FileName)))
	i += copy(dAtA[i:], m.FileName)
	return i, nil
}

func (m *HingeLossParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HingeLossParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Norm != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Norm))
	}
	return i, nil
}

func (m *ImageDataParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageDataParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Source)))
	i += copy(dAtA[i:], m.Source)
	if m.Scale != nil {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Scale))))
		i += 4
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.MeanFile)))
	i += copy(dAtA[i:], m.MeanFile)
	if m.BatchSize != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.BatchSize))
	}
	if m.CropSize != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.CropSize))
	}
	if m.Mirror != nil {
		dAtA[i] = 0x30
		i++
		if *m.Mirror {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RandSkip != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.RandSkip))
	}
	if m.Shuffle != nil {
		dAtA[i] = 0x40
		i++
		if *m.Shuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NewHeight != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.NewHeight))
	}
	if m.NewWidth != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.NewWidth))
	}
	if m.IsColor != nil {
		dAtA[i] = 0x58
		i++
		if *m.IsColor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RootFolder != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(len(*m.RootFolder)))
		i += copy(dAtA[i:], *m.RootFolder)
	}
	return i, nil
}

func (m *InfogainLossParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfogainLossParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Source)))
	i += copy(dAtA[i:], m.Source)
	return i, nil
}

func (m *InnerProductParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InnerProductParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.NumOutput))
	if m.BiasTerm != nil {
		dAtA[i] = 0x10
		i++
		if *m.BiasTerm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WeightFiller != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.WeightFiller.Size()))
		n68, err := m.WeightFiller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if m.BiasFiller != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.BiasFiller.Size()))
		n69, err := m.BiasFiller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.Axis != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Axis))
	}
	if m.Transpose != nil {
		dAtA[i] = 0x30
		i++
		if *m.Transpose {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InputParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Shape) > 0 {
		for _, msg := range m.Shape {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LogParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Base != nil {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Base))))
		i += 4
	}
	if m.Scale != nil {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Scale))))
		i += 4
	}
	if m.Shift != nil {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Shift))))
		i += 4
	}
	return i, nil
}

func (m *LRNParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LRNParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalSize != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.LocalSize))
	}
	if m.Alpha != nil {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Alpha))))
		i += 4
	}
	if m.Beta != nil {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Beta))))
		i += 4
	}
	if m.NormRegion != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.NormRegion))
	}
	if m.K != nil {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.K))))
		i += 4
	}
	if m.Engine != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Engine))
	}
	return i, nil
}

func (m *MemoryDataParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryDataParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.BatchSize))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Channels))
	dAtA[i] = 0x18
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Height))
	dAtA[i] = 0x20
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Width))
	return i, nil
}

func (m *MVNParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVNParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NormalizeVariance != nil {
		dAtA[i] = 0x8
		i++
		if *m.NormalizeVariance {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AcrossChannels != nil {
		dAtA[i] = 0x10
		i++
		if *m.AcrossChannels {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Eps != nil {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Eps))))
		i += 4
	}
	return i, nil
}

func (m *ParameterParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParameterParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Shape != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.Shape.Size()))
		n70, err := m.Shape.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	return i, nil
}

func (m *PoolingParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolingParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pool != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Pool))
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.KernelSize))
	if m.Stride != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Stride))
	}
	if m.Pad != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Pad))
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.KernelH))
	dAtA[i] = 0x30
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.KernelW))
	dAtA[i] = 0x38
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.StrideH))
	dAtA[i] = 0x40
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.StrideW))
	if m.PadH != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.PadH))
	}
	if m.PadW != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.PadW))
	}
	if m.Engine != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Engine))
	}
	if m.GlobalPooling != nil {
		dAtA[i] = 0x60
		i++
		if *m.GlobalPooling {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PowerParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PowerParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Power != nil {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Power))))
		i += 4
	}
	if m.Scale != nil {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Scale))))
		i += 4
	}
	if m.Shift != nil {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Shift))))
		i += 4
	}
	return i, nil
}

func (m *PythonParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PythonParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Module)))
	i += copy(dAtA[i:], m.Module)
	dAtA[i] = 0x12
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Layer)))
	i += copy(dAtA[i:], m.Layer)
	if m.ParamStr != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(len(*m.ParamStr)))
		i += copy(dAtA[i:], *m.ParamStr)
	}
	if m.ShareInParallel != nil {
		dAtA[i] = 0x20
		i++
		if *m.ShareInParallel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RecurrentParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecurrentParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumOutput != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.NumOutput))
	}
	if m.WeightFiller != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.WeightFiller.Size()))
		n71, err := m.WeightFiller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if m.BiasFiller != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.BiasFiller.Size()))
		n72, err := m.BiasFiller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if m.DebugInfo != nil {
		dAtA[i] = 0x20
		i++
		if *m.DebugInfo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExposeHidden != nil {
		dAtA[i] = 0x28
		i++
		if *m.ExposeHidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReductionParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReductionParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Operation != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Operation))
	}
	if m.Axis != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Axis))
	}
	if m.Coeff != nil {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Coeff))))
		i += 4
	}
	return i, nil
}

func (m *ReLUParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReLUParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NegativeSlope != nil {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.NegativeSlope))))
		i += 4
	}
	if m.Engine != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Engine))
	}
	return i, nil
}

func (m *ReshapeParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReshapeParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Shape != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.Shape.Size()))
		n73, err := m.Shape.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if m.Axis != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Axis))
	}
	if m.NumAxes != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.NumAxes))
	}
	return i, nil
}

func (m *ScaleParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScaleParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Axis != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Axis))
	}
	if m.NumAxes != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.NumAxes))
	}
	if m.Filler != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.Filler.Size()))
		n74, err := m.Filler.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.BiasTerm != nil {
		dAtA[i] = 0x20
		i++
		if *m.BiasTerm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BiasFiller != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.BiasFiller.Size()))
		n75, err := m.BiasFiller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	return i, nil
}

func (m *SigmoidParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigmoidParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Engine != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Engine))
	}
	return i, nil
}

func (m *SliceParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SliceParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SliceDim != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.SliceDim))
	}
	if len(m.SlicePoint) > 0 {
		for _, num := range m.SlicePoint {
			dAtA[i] = 0x10
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	if m.Axis != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Axis))
	}
	return i, nil
}

func (m *SoftmaxParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoftmaxParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Engine != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Engine))
	}
	if m.Axis != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Axis))
	}
	return i, nil
}

func (m *TanHParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TanHParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Engine != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Engine))
	}
	return i, nil
}

func (m *TileParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TileParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Axis != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Axis))
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Tiles))
	return i, nil
}

func (m *ThresholdParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Threshold != nil {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Threshold))))
		i += 4
	}
	return i, nil
}

func (m *WindowDataParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowDataParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Source)))
	i += copy(dAtA[i:], m.Source)
	if m.Scale != nil {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Scale))))
		i += 4
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.MeanFile)))
	i += copy(dAtA[i:], m.MeanFile)
	dAtA[i] = 0x20
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.BatchSize))
	if m.CropSize != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.CropSize))
	}
	if m.Mirror != nil {
		dAtA[i] = 0x30
		i++
		if *m.Mirror {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FgThreshold != nil {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FgThreshold))))
		i += 4
	}
	if m.BgThreshold != nil {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.BgThreshold))))
		i += 4
	}
	if m.FgFraction != nil {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FgFraction))))
		i += 4
	}
	if m.ContextPad != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.ContextPad))
	}
	if m.CropMode != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(len(*m.CropMode)))
		i += copy(dAtA[i:], *m.CropMode)
	}
	if m.CacheImages != nil {
		dAtA[i] = 0x60
		i++
		if *m.CacheImages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RootFolder != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(len(*m.RootFolder)))
		i += copy(dAtA[i:], *m.RootFolder)
	}
	return i, nil
}

func (m *SPPParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SPPParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.PyramidHeight))
	if m.Pool != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Pool))
	}
	if m.Engine != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Engine))
	}
	return i, nil
}

func (m *V1LayerParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *V1LayerParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Layer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.Layer.Size()))
		n76, err := m.Layer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	if len(m.Bottom) > 0 {
		for _, s := range m.Bottom {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Top) > 0 {
		for _, s := range m.Top {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x28
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Type))
	if len(m.Blobs) > 0 {
		for _, msg := range m.Blobs {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BlobsLr) > 0 {
		for _, num := range m.BlobsLr {
			dAtA[i] = 0x3d
			i++
			f77 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f77))
			i += 4
		}
	}
	if len(m.WeightDecay) > 0 {
		for _, num := range m.WeightDecay {
			dAtA[i] = 0x45
			i++
			f78 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f78))
			i += 4
		}
	}
	if m.ConcatParam != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ConcatParam.Size()))
		n79, err := m.ConcatParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	if m.ConvolutionParam != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ConvolutionParam.Size()))
		n80, err := m.ConvolutionParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	if m.DataParam != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.DataParam.Size()))
		n81, err := m.DataParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if m.DropoutParam != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.DropoutParam.Size()))
		n82, err := m.DropoutParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	if m.Hdf5DataParam != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.Hdf5DataParam.Size()))
		n83, err := m.Hdf5DataParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	if m.Hdf5OutputParam != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.Hdf5OutputParam.Size()))
		n84, err := m.Hdf5OutputParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	if m.ImageDataParam != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ImageDataParam.Size()))
		n85, err := m.ImageDataParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	if m.InfogainLossParam != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.InfogainLossParam.Size()))
		n86, err := m.InfogainLossParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	if m.InnerProductParam != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.InnerProductParam.Size()))
		n87, err := m.InnerProductParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	if m.LrnParam != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.LrnParam.Size()))
		n88, err := m.LrnParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	if m.PoolingParam != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.PoolingParam.Size()))
		n89, err := m.PoolingParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	if m.WindowDataParam != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.WindowDataParam.Size()))
		n90, err := m.WindowDataParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	if m.PowerParam != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.PowerParam.Size()))
		n91, err := m.PowerParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	if m.MemoryDataParam != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.MemoryDataParam.Size()))
		n92, err := m.MemoryDataParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	if m.ArgmaxParam != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ArgmaxParam.Size()))
		n93, err := m.ArgmaxParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	if m.EltwiseParam != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.EltwiseParam.Size()))
		n94, err := m.EltwiseParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	if m.ThresholdParam != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ThresholdParam.Size()))
		n95, err := m.ThresholdParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n95
	}
	if m.DummyDataParam != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.DummyDataParam.Size()))
		n96, err := m.DummyDataParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n96
	}
	if m.AccuracyParam != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.AccuracyParam.Size()))
		n97, err := m.AccuracyParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n97
	}
	if m.HingeLossParam != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.HingeLossParam.Size()))
		n98, err := m.HingeLossParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n98
	}
	if m.ReluParam != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ReluParam.Size()))
		n99, err := m.ReluParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n99
	}
	if m.SliceParam != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.SliceParam.Size()))
		n100, err := m.SliceParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n100
	}
	if len(m.Include) > 0 {
		for _, msg := range m.Include {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Exclude) > 0 {
		for _, msg := range m.Exclude {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MvnParam != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.MvnParam.Size()))
		n101, err := m.MvnParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n101
	}
	if len(m.LossWeight) > 0 {
		for _, num := range m.LossWeight {
			dAtA[i] = 0x9d
			i++
			dAtA[i] = 0x2
			i++
			f102 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f102))
			i += 4
		}
	}
	if m.TransformParam != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.TransformParam.Size()))
		n103, err := m.TransformParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n103
	}
	if m.TanhParam != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.TanhParam.Size()))
		n104, err := m.TanhParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n104
	}
	if m.SigmoidParam != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.SigmoidParam.Size()))
		n105, err := m.SigmoidParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n105
	}
	if m.SoftmaxParam != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.SoftmaxParam.Size()))
		n106, err := m.SoftmaxParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n106
	}
	if m.ContrastiveLossParam != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ContrastiveLossParam.Size()))
		n107, err := m.ContrastiveLossParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n107
	}
	if m.ExpParam != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.ExpParam.Size()))
		n108, err := m.ExpParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n108
	}
	if m.LossParam != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.LossParam.Size()))
		n109, err := m.LossParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n109
	}
	if len(m.Param) > 0 {
		for _, s := range m.Param {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x3e
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.BlobShareMode) > 0 {
		for _, num := range m.BlobShareMode {
			dAtA[i] = 0xd0
			i++
			dAtA[i] = 0x3e
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *V0LayerParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *V0LayerParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Type)))
	i += copy(dAtA[i:], m.Type)
	dAtA[i] = 0x18
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.NumOutput))
	if m.Biasterm != nil {
		dAtA[i] = 0x20
		i++
		if *m.Biasterm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WeightFiller != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.WeightFiller.Size()))
		n110, err := m.WeightFiller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n110
	}
	if m.BiasFiller != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.BiasFiller.Size()))
		n111, err := m.BiasFiller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n111
	}
	if m.Pad != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Pad))
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Kernelsize))
	if m.Group != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Group))
	}
	if m.Stride != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Stride))
	}
	if m.Pool != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Pool))
	}
	if m.DropoutRatio != nil {
		dAtA[i] = 0x65
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DropoutRatio))))
		i += 4
	}
	if m.LocalSize != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.LocalSize))
	}
	if m.Alpha != nil {
		dAtA[i] = 0x75
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Alpha))))
		i += 4
	}
	if m.Beta != nil {
		dAtA[i] = 0x7d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Beta))))
		i += 4
	}
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Source)))
	i += copy(dAtA[i:], m.Source)
	if m.Scale != nil {
		dAtA[i] = 0x8d
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Scale))))
		i += 4
	}
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(len(m.Meanfile)))
	i += copy(dAtA[i:], m.Meanfile)
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCaffe(dAtA, i, uint64(m.Batchsize))
	if m.Cropsize != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.Cropsize))
	}
	if m.Mirror != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if *m.Mirror {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.K != nil {
		dAtA[i] = 0xb5
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.K))))
		i += 4
	}
	if len(m.Blobs) > 0 {
		for _, msg := range m.Blobs {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintCaffe(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BlobsLr) > 0 {
		for _, num := range m.BlobsLr {
			dAtA[i] = 0x9d
			i++
			dAtA[i] = 0x3
			i++
			f112 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f112))
			i += 4
		}
	}
	if len(m.WeightDecay) > 0 {
		for _, num := range m.WeightDecay {
			dAtA[i] = 0xa5
			i++
			dAtA[i] = 0x3
			i++
			f113 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f113))
			i += 4
		}
	}
	if m.RandSkip != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.RandSkip))
	}
	if m.DetFgThreshold != nil {
		dAtA[i] = 0xb5
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DetFgThreshold))))
		i += 4
	}
	if m.DetBgThreshold != nil {
		dAtA[i] = 0xbd
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DetBgThreshold))))
		i += 4
	}
	if m.DetFgFraction != nil {
		dAtA[i] = 0xc5
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DetFgFraction))))
		i += 4
	}
	if m.DetContextPad != nil {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.DetContextPad))
	}
	if m.DetCropMode != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(len(*m.DetCropMode)))
		i += copy(dAtA[i:], *m.DetCropMode)
	}
	if m.NewNum != nil {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.NewNum))
	}
	if m.NewChannels != nil {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.NewChannels))
	}
	if m.NewHeight != nil {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.NewHeight))
	}
	if m.NewWidth != nil {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.NewWidth))
	}
	if m.ShuffleImages != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x4
		i++
		if *m.ShuffleImages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ConcatDim != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(*m.ConcatDim))
	}
	if m.Hdf5OutputParam != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.Hdf5OutputParam.Size()))
		n114, err := m.Hdf5OutputParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n114
	}
	return i, nil
}

func (m *PReLUParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PReLUParameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Filler != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCaffe(dAtA, i, uint64(m.Filler.Size()))
		n115, err := m.Filler.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n115
	}
	if m.ChannelShared != nil {
		dAtA[i] = 0x10
		i++
		if *m.ChannelShared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintCaffe(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BlobShape) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dim) > 0 {
		l = 0
		for _, e := range m.Dim {
			l += sovCaffe(uint64(e))
		}
		n += 1 + sovCaffe(uint64(l)) + l
	}
	return n
}

func (m *BlobProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != nil {
		n += 1 + sovCaffe(uint64(*m.Num))
	}
	if m.Channels != nil {
		n += 1 + sovCaffe(uint64(*m.Channels))
	}
	if m.Height != nil {
		n += 1 + sovCaffe(uint64(*m.Height))
	}
	if m.Width != nil {
		n += 1 + sovCaffe(uint64(*m.Width))
	}
	if len(m.Data) > 0 {
		n += 1 + sovCaffe(uint64(len(m.Data)*4)) + len(m.Data)*4
	}
	if len(m.Diff) > 0 {
		n += 1 + sovCaffe(uint64(len(m.Diff)*4)) + len(m.Diff)*4
	}
	if m.Shape != nil {
		l = m.Shape.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if len(m.DoubleData) > 0 {
		n += 1 + sovCaffe(uint64(len(m.DoubleData)*8)) + len(m.DoubleData)*8
	}
	if len(m.DoubleDiff) > 0 {
		n += 1 + sovCaffe(uint64(len(m.DoubleDiff)*8)) + len(m.DoubleDiff)*8
	}
	return n
}

func (m *BlobProtoVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Blobs) > 0 {
		for _, e := range m.Blobs {
			l = e.Size()
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	return n
}

func (m *Datum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCaffe(uint64(m.Channels))
	n += 1 + sovCaffe(uint64(m.Height))
	n += 1 + sovCaffe(uint64(m.Width))
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovCaffe(uint64(l))
	}
	n += 1 + sovCaffe(uint64(m.Label))
	if len(m.FloatData) > 0 {
		n += 5 * len(m.FloatData)
	}
	if m.Encoded != nil {
		n += 2
	}
	return n
}

func (m *FillerParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.Value != nil {
		n += 5
	}
	if m.Min != nil {
		n += 5
	}
	if m.Max != nil {
		n += 5
	}
	if m.Mean != nil {
		n += 5
	}
	if m.Std != nil {
		n += 5
	}
	if m.Sparse != nil {
		n += 1 + sovCaffe(uint64(*m.Sparse))
	}
	if m.VarianceNorm != nil {
		n += 1 + sovCaffe(uint64(*m.VarianceNorm))
	}
	return n
}

func (m *NetParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCaffe(uint64(l))
	if len(m.Layers) > 0 {
		for _, e := range m.Layers {
			l = e.Size()
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.Input) > 0 {
		for _, s := range m.Input {
			l = len(s)
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.InputDim) > 0 {
		for _, e := range m.InputDim {
			n += 1 + sovCaffe(uint64(e))
		}
	}
	if m.ForceBackward != nil {
		n += 2
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.DebugInfo != nil {
		n += 2
	}
	if len(m.InputShape) > 0 {
		for _, e := range m.InputShape {
			l = e.Size()
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.Layer) > 0 {
		for _, e := range m.Layer {
			l = e.Size()
			n += 2 + l + sovCaffe(uint64(l))
		}
	}
	return n
}

func (m *SolverParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TrainNet)
	n += 1 + l + sovCaffe(uint64(l))
	if len(m.TestNet) > 0 {
		for _, s := range m.TestNet {
			l = len(s)
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.TestIter) > 0 {
		for _, e := range m.TestIter {
			n += 1 + sovCaffe(uint64(e))
		}
	}
	if m.TestInterval != nil {
		n += 1 + sovCaffe(uint64(*m.TestInterval))
	}
	n += 5
	n += 1 + sovCaffe(uint64(m.Display))
	n += 1 + sovCaffe(uint64(m.MaxIter))
	l = len(m.LrPolicy)
	n += 1 + l + sovCaffe(uint64(l))
	n += 5
	n += 5
	n += 5
	n += 5
	n += 1 + sovCaffe(uint64(m.Stepsize))
	if m.Snapshot != nil {
		n += 1 + sovCaffe(uint64(*m.Snapshot))
	}
	l = len(m.SnapshotPrefix)
	n += 1 + l + sovCaffe(uint64(l))
	if m.SnapshotDiff != nil {
		n += 3
	}
	if m.SolverMode != nil {
		n += 2 + sovCaffe(uint64(*m.SolverMode))
	}
	if m.DeviceId != nil {
		n += 2 + sovCaffe(uint64(*m.DeviceId))
	}
	if m.TestComputeLoss != nil {
		n += 3
	}
	if m.RandomSeed != nil {
		n += 2 + sovCaffe(uint64(*m.RandomSeed))
	}
	if m.TrainNetParam != nil {
		l = m.TrainNetParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if len(m.TestNetParam) > 0 {
		for _, e := range m.TestNetParam {
			l = e.Size()
			n += 2 + l + sovCaffe(uint64(l))
		}
	}
	if m.DebugInfo != nil {
		n += 3
	}
	l = len(m.Net)
	n += 2 + l + sovCaffe(uint64(l))
	if m.NetParam != nil {
		l = m.NetParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.TrainState != nil {
		l = m.TrainState.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if len(m.TestState) > 0 {
		for _, e := range m.TestState {
			l = e.Size()
			n += 2 + l + sovCaffe(uint64(l))
		}
	}
	if m.SnapshotAfterTrain != nil {
		n += 3
	}
	if m.RegularizationType != nil {
		l = len(*m.RegularizationType)
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.SolverType != nil {
		n += 2 + sovCaffe(uint64(*m.SolverType))
	}
	if m.Delta != nil {
		n += 6
	}
	if m.TestInitialization != nil {
		n += 3
	}
	if m.AverageLoss != nil {
		n += 2 + sovCaffe(uint64(*m.AverageLoss))
	}
	if len(m.Stepvalue) > 0 {
		for _, e := range m.Stepvalue {
			n += 2 + sovCaffe(uint64(e))
		}
	}
	if m.ClipGradients != nil {
		n += 6
	}
	if m.IterSize != nil {
		n += 2 + sovCaffe(uint64(*m.IterSize))
	}
	if m.SnapshotFormat != nil {
		n += 2 + sovCaffe(uint64(*m.SnapshotFormat))
	}
	n += 6
	if m.Momentum2 != nil {
		n += 6
	}
	if m.Type != nil {
		l = len(*m.Type)
		n += 2 + l + sovCaffe(uint64(l))
	}
	return n
}

func (m *SolverState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCaffe(uint64(m.Iter))
	l = len(m.LearnedNet)
	n += 1 + l + sovCaffe(uint64(l))
	if len(m.History) > 0 {
		for _, e := range m.History {
			l = e.Size()
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if m.CurrentStep != nil {
		n += 1 + sovCaffe(uint64(*m.CurrentStep))
	}
	return n
}

func (m *NetState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Phase != nil {
		n += 1 + sovCaffe(uint64(*m.Phase))
	}
	if m.Level != nil {
		n += 1 + sovCaffe(uint64(*m.Level))
	}
	if len(m.Stage) > 0 {
		for _, s := range m.Stage {
			l = len(s)
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	return n
}

func (m *NetStateRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCaffe(uint64(m.Phase))
	n += 1 + sovCaffe(uint64(m.MinLevel))
	n += 1 + sovCaffe(uint64(m.MaxLevel))
	if len(m.Stage) > 0 {
		for _, s := range m.Stage {
			l = len(s)
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.NotStage) > 0 {
		for _, s := range m.NotStage {
			l = len(s)
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	return n
}

func (m *ParamSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCaffe(uint64(l))
	n += 1 + sovCaffe(uint64(m.ShareMode))
	if m.LrMult != nil {
		n += 5
	}
	if m.DecayMult != nil {
		n += 5
	}
	return n
}

func (m *LayerParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCaffe(uint64(l))
	l = len(m.Type)
	n += 1 + l + sovCaffe(uint64(l))
	if len(m.Bottom) > 0 {
		for _, s := range m.Bottom {
			l = len(s)
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.Top) > 0 {
		for _, s := range m.Top {
			l = len(s)
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.LossWeight) > 0 {
		n += 5 * len(m.LossWeight)
	}
	if len(m.Param) > 0 {
		for _, e := range m.Param {
			l = e.Size()
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.Blobs) > 0 {
		for _, e := range m.Blobs {
			l = e.Size()
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.Include) > 0 {
		for _, e := range m.Include {
			l = e.Size()
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.Exclude) > 0 {
		for _, e := range m.Exclude {
			l = e.Size()
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	n += 1 + sovCaffe(uint64(m.Phase))
	if len(m.PropagateDown) > 0 {
		n += 2 * len(m.PropagateDown)
	}
	if m.TransformParam != nil {
		l = m.TransformParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.LossParam != nil {
		l = m.LossParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.AccuracyParam != nil {
		l = m.AccuracyParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ArgmaxParam != nil {
		l = m.ArgmaxParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ConcatParam != nil {
		l = m.ConcatParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ContrastiveLossParam != nil {
		l = m.ContrastiveLossParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ConvolutionParam != nil {
		l = m.ConvolutionParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.DataParam != nil {
		l = m.DataParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.DropoutParam != nil {
		l = m.DropoutParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.DummyDataParam != nil {
		l = m.DummyDataParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.EltwiseParam != nil {
		l = m.EltwiseParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ExpParam != nil {
		l = m.ExpParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.Hdf5DataParam != nil {
		l = m.Hdf5DataParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.Hdf5OutputParam != nil {
		l = m.Hdf5OutputParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.HingeLossParam != nil {
		l = m.HingeLossParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ImageDataParam != nil {
		l = m.ImageDataParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.InfogainLossParam != nil {
		l = m.InfogainLossParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.InnerProductParam != nil {
		l = m.InnerProductParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.LrnParam != nil {
		l = m.LrnParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.MemoryDataParam != nil {
		l = m.MemoryDataParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.MvnParam != nil {
		l = m.MvnParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.PoolingParam != nil {
		l = m.PoolingParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.PowerParam != nil {
		l = m.PowerParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ReluParam != nil {
		l = m.ReluParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.SigmoidParam != nil {
		l = m.SigmoidParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.SoftmaxParam != nil {
		l = m.SoftmaxParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.SliceParam != nil {
		l = m.SliceParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.TanhParam != nil {
		l = m.TanhParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ThresholdParam != nil {
		l = m.ThresholdParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.WindowDataParam != nil {
		l = m.WindowDataParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.PythonParam != nil {
		l = m.PythonParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.PreluParam != nil {
		l = m.PreluParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.SppParam != nil {
		l = m.SppParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ReshapeParam != nil {
		l = m.ReshapeParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.LogParam != nil {
		l = m.LogParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.FlattenParam != nil {
		l = m.FlattenParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ReductionParam != nil {
		l = m.ReductionParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.EmbedParam != nil {
		l = m.EmbedParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.TileParam != nil {
		l = m.TileParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.BatchNormParam != nil {
		l = m.BatchNormParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.EluParam != nil {
		l = m.EluParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.BiasParam != nil {
		l = m.BiasParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ScaleParam != nil {
		l = m.ScaleParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.InputParam != nil {
		l = m.InputParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.CropParam != nil {
		l = m.CropParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ParameterParam != nil {
		l = m.ParameterParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.RecurrentParam != nil {
		l = m.RecurrentParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	return n
}

func (m *TransformationParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scale != nil {
		n += 5
	}
	if m.Mirror != nil {
		n += 2
	}
	if m.CropSize != nil {
		n += 1 + sovCaffe(uint64(*m.CropSize))
	}
	l = len(m.MeanFile)
	n += 1 + l + sovCaffe(uint64(l))
	if len(m.MeanValue) > 0 {
		n += 5 * len(m.MeanValue)
	}
	if m.ForceColor != nil {
		n += 2
	}
	if m.ForceGray != nil {
		n += 2
	}
	return n
}

func (m *LossParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCaffe(uint64(m.IgnoreLabel))
	n += 2
	if m.Normalization != nil {
		n += 1 + sovCaffe(uint64(*m.Normalization))
	}
	return n
}

func (m *AccuracyParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopK != nil {
		n += 1 + sovCaffe(uint64(*m.TopK))
	}
	if m.Axis != nil {
		n += 1 + sovCaffe(uint64(*m.Axis))
	}
	n += 1 + sovCaffe(uint64(m.IgnoreLabel))
	return n
}

func (m *ArgMaxParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutMaxVal != nil {
		n += 2
	}
	if m.TopK != nil {
		n += 1 + sovCaffe(uint64(*m.TopK))
	}
	n += 1 + sovCaffe(uint64(m.Axis))
	return n
}

func (m *ConcatParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConcatDim != nil {
		n += 1 + sovCaffe(uint64(*m.ConcatDim))
	}
	if m.Axis != nil {
		n += 1 + sovCaffe(uint64(*m.Axis))
	}
	return n
}

func (m *BatchNormParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	if m.MovingAverageFraction != nil {
		n += 5
	}
	if m.Eps != nil {
		n += 5
	}
	return n
}

func (m *BiasParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Axis != nil {
		n += 1 + sovCaffe(uint64(*m.Axis))
	}
	if m.NumAxes != nil {
		n += 1 + sovCaffe(uint64(*m.NumAxes))
	}
	if m.Filler != nil {
		l = m.Filler.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	return n
}

func (m *ContrastiveLossParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Margin != nil {
		n += 5
	}
	if m.LegacyVersion != nil {
		n += 2
	}
	return n
}

func (m *ConvolutionParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCaffe(uint64(m.NumOutput))
	if m.BiasTerm != nil {
		n += 2
	}
	if len(m.Pad) > 0 {
		for _, e := range m.Pad {
			n += 1 + sovCaffe(uint64(e))
		}
	}
	if len(m.KernelSize) > 0 {
		for _, e := range m.KernelSize {
			n += 1 + sovCaffe(uint64(e))
		}
	}
	if m.Group != nil {
		n += 1 + sovCaffe(uint64(*m.Group))
	}
	if len(m.Stride) > 0 {
		for _, e := range m.Stride {
			n += 1 + sovCaffe(uint64(e))
		}
	}
	if m.WeightFiller != nil {
		l = m.WeightFiller.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.BiasFiller != nil {
		l = m.BiasFiller.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.PadH != nil {
		n += 1 + sovCaffe(uint64(*m.PadH))
	}
	if m.PadW != nil {
		n += 1 + sovCaffe(uint64(*m.PadW))
	}
	n += 1 + sovCaffe(uint64(m.KernelH))
	n += 1 + sovCaffe(uint64(m.KernelW))
	n += 1 + sovCaffe(uint64(m.StrideH))
	n += 1 + sovCaffe(uint64(m.StrideW))
	if m.Engine != nil {
		n += 1 + sovCaffe(uint64(*m.Engine))
	}
	if m.Axis != nil {
		n += 2 + sovCaffe(uint64(*m.Axis))
	}
	if m.ForceNdIm2Col != nil {
		n += 3
	}
	if len(m.Dilation) > 0 {
		for _, e := range m.Dilation {
			n += 2 + sovCaffe(uint64(e))
		}
	}
	return n
}

func (m *CropParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Axis != nil {
		n += 1 + sovCaffe(uint64(*m.Axis))
	}
	if len(m.Offset) > 0 {
		for _, e := range m.Offset {
			n += 1 + sovCaffe(uint64(e))
		}
	}
	return n
}

func (m *DataParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	n += 1 + l + sovCaffe(uint64(l))
	if m.Scale != nil {
		n += 5
	}
	l = len(m.MeanFile)
	n += 1 + l + sovCaffe(uint64(l))
	n += 1 + sovCaffe(uint64(m.BatchSize))
	if m.CropSize != nil {
		n += 1 + sovCaffe(uint64(*m.CropSize))
	}
	if m.Mirror != nil {
		n += 2
	}
	if m.RandSkip != nil {
		n += 1 + sovCaffe(uint64(*m.RandSkip))
	}
	if m.Backend != nil {
		n += 1 + sovCaffe(uint64(*m.Backend))
	}
	if m.ForceEncodedColor != nil {
		n += 2
	}
	if m.Prefetch != nil {
		n += 1 + sovCaffe(uint64(*m.Prefetch))
	}
	return n
}

func (m *DropoutParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropoutRatio != nil {
		n += 5
	}
	return n
}

func (m *DummyDataParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DataFiller) > 0 {
		for _, e := range m.DataFiller {
			l = e.Size()
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.Num) > 0 {
		for _, e := range m.Num {
			n += 1 + sovCaffe(uint64(e))
		}
	}
	if len(m.Channels) > 0 {
		for _, e := range m.Channels {
			n += 1 + sovCaffe(uint64(e))
		}
	}
	if len(m.Height) > 0 {
		for _, e := range m.Height {
			n += 1 + sovCaffe(uint64(e))
		}
	}
	if len(m.Width) > 0 {
		for _, e := range m.Width {
			n += 1 + sovCaffe(uint64(e))
		}
	}
	if len(m.Shape) > 0 {
		for _, e := range m.Shape {
			l = e.Size()
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	return n
}

func (m *EltwiseParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		n += 1 + sovCaffe(uint64(*m.Operation))
	}
	if len(m.Coeff) > 0 {
		n += 5 * len(m.Coeff)
	}
	if m.StableProdGrad != nil {
		n += 2
	}
	return n
}

func (m *ELUParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Alpha != nil {
		n += 5
	}
	return n
}

func (m *EmbedParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCaffe(uint64(m.NumOutput))
	n += 1 + sovCaffe(uint64(m.InputDim))
	if m.BiasTerm != nil {
		n += 2
	}
	if m.WeightFiller != nil {
		l = m.WeightFiller.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.BiasFiller != nil {
		l = m.BiasFiller.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	return n
}

func (m *ExpParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		n += 5
	}
	if m.Scale != nil {
		n += 5
	}
	if m.Shift != nil {
		n += 5
	}
	return n
}

func (m *FlattenParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Axis != nil {
		n += 1 + sovCaffe(uint64(*m.Axis))
	}
	if m.EndAxis != nil {
		n += 1 + sovCaffe(uint64(*m.EndAxis))
	}
	return n
}

func (m *HDF5DataParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	n += 1 + l + sovCaffe(uint64(l))
	n += 1 + sovCaffe(uint64(m.BatchSize))
	if m.Shuffle != nil {
		n += 2
	}
	return n
}

func (m *HDF5OutputParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileName)
	n += 1 + l + sovCaffe(uint64(l))
	return n
}

func (m *HingeLossParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Norm != nil {
		n += 1 + sovCaffe(uint64(*m.Norm))
	}
	return n
}

func (m *ImageDataParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	n += 1 + l + sovCaffe(uint64(l))
	if m.Scale != nil {
		n += 5
	}
	l = len(m.MeanFile)
	n += 1 + l + sovCaffe(uint64(l))
	if m.BatchSize != nil {
		n += 1 + sovCaffe(uint64(*m.BatchSize))
	}
	if m.CropSize != nil {
		n += 1 + sovCaffe(uint64(*m.CropSize))
	}
	if m.Mirror != nil {
		n += 2
	}
	if m.RandSkip != nil {
		n += 1 + sovCaffe(uint64(*m.RandSkip))
	}
	if m.Shuffle != nil {
		n += 2
	}
	if m.NewHeight != nil {
		n += 1 + sovCaffe(uint64(*m.NewHeight))
	}
	if m.NewWidth != nil {
		n += 1 + sovCaffe(uint64(*m.NewWidth))
	}
	if m.IsColor != nil {
		n += 2
	}
	if m.RootFolder != nil {
		l = len(*m.RootFolder)
		n += 1 + l + sovCaffe(uint64(l))
	}
	return n
}

func (m *InfogainLossParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	n += 1 + l + sovCaffe(uint64(l))
	return n
}

func (m *InnerProductParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCaffe(uint64(m.NumOutput))
	if m.BiasTerm != nil {
		n += 2
	}
	if m.WeightFiller != nil {
		l = m.WeightFiller.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.BiasFiller != nil {
		l = m.BiasFiller.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.Axis != nil {
		n += 1 + sovCaffe(uint64(*m.Axis))
	}
	if m.Transpose != nil {
		n += 2
	}
	return n
}

func (m *InputParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shape) > 0 {
		for _, e := range m.Shape {
			l = e.Size()
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	return n
}

func (m *LogParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		n += 5
	}
	if m.Scale != nil {
		n += 5
	}
	if m.Shift != nil {
		n += 5
	}
	return n
}

func (m *LRNParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LocalSize != nil {
		n += 1 + sovCaffe(uint64(*m.LocalSize))
	}
	if m.Alpha != nil {
		n += 5
	}
	if m.Beta != nil {
		n += 5
	}
	if m.NormRegion != nil {
		n += 1 + sovCaffe(uint64(*m.NormRegion))
	}
	if m.K != nil {
		n += 5
	}
	if m.Engine != nil {
		n += 1 + sovCaffe(uint64(*m.Engine))
	}
	return n
}

func (m *MemoryDataParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCaffe(uint64(m.BatchSize))
	n += 1 + sovCaffe(uint64(m.Channels))
	n += 1 + sovCaffe(uint64(m.Height))
	n += 1 + sovCaffe(uint64(m.Width))
	return n
}

func (m *MVNParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NormalizeVariance != nil {
		n += 2
	}
	if m.AcrossChannels != nil {
		n += 2
	}
	if m.Eps != nil {
		n += 5
	}
	return n
}

func (m *ParameterParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shape != nil {
		l = m.Shape.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	return n
}

func (m *PoolingParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pool != nil {
		n += 1 + sovCaffe(uint64(*m.Pool))
	}
	n += 1 + sovCaffe(uint64(m.KernelSize))
	if m.Stride != nil {
		n += 1 + sovCaffe(uint64(*m.Stride))
	}
	if m.Pad != nil {
		n += 1 + sovCaffe(uint64(*m.Pad))
	}
	n += 1 + sovCaffe(uint64(m.KernelH))
	n += 1 + sovCaffe(uint64(m.KernelW))
	n += 1 + sovCaffe(uint64(m.StrideH))
	n += 1 + sovCaffe(uint64(m.StrideW))
	if m.PadH != nil {
		n += 1 + sovCaffe(uint64(*m.PadH))
	}
	if m.PadW != nil {
		n += 1 + sovCaffe(uint64(*m.PadW))
	}
	if m.Engine != nil {
		n += 1 + sovCaffe(uint64(*m.Engine))
	}
	if m.GlobalPooling != nil {
		n += 2
	}
	return n
}

func (m *PowerParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Power != nil {
		n += 5
	}
	if m.Scale != nil {
		n += 5
	}
	if m.Shift != nil {
		n += 5
	}
	return n
}

func (m *PythonParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Module)
	n += 1 + l + sovCaffe(uint64(l))
	l = len(m.Layer)
	n += 1 + l + sovCaffe(uint64(l))
	if m.ParamStr != nil {
		l = len(*m.ParamStr)
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.ShareInParallel != nil {
		n += 2
	}
	return n
}

func (m *RecurrentParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumOutput != nil {
		n += 1 + sovCaffe(uint64(*m.NumOutput))
	}
	if m.WeightFiller != nil {
		l = m.WeightFiller.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.BiasFiller != nil {
		l = m.BiasFiller.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.DebugInfo != nil {
		n += 2
	}
	if m.ExposeHidden != nil {
		n += 2
	}
	return n
}

func (m *ReductionParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		n += 1 + sovCaffe(uint64(*m.Operation))
	}
	if m.Axis != nil {
		n += 1 + sovCaffe(uint64(*m.Axis))
	}
	if m.Coeff != nil {
		n += 5
	}
	return n
}

func (m *ReLUParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NegativeSlope != nil {
		n += 5
	}
	if m.Engine != nil {
		n += 1 + sovCaffe(uint64(*m.Engine))
	}
	return n
}

func (m *ReshapeParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shape != nil {
		l = m.Shape.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.Axis != nil {
		n += 1 + sovCaffe(uint64(*m.Axis))
	}
	if m.NumAxes != nil {
		n += 1 + sovCaffe(uint64(*m.NumAxes))
	}
	return n
}

func (m *ScaleParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Axis != nil {
		n += 1 + sovCaffe(uint64(*m.Axis))
	}
	if m.NumAxes != nil {
		n += 1 + sovCaffe(uint64(*m.NumAxes))
	}
	if m.Filler != nil {
		l = m.Filler.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.BiasTerm != nil {
		n += 2
	}
	if m.BiasFiller != nil {
		l = m.BiasFiller.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	return n
}

func (m *SigmoidParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Engine != nil {
		n += 1 + sovCaffe(uint64(*m.Engine))
	}
	return n
}

func (m *SliceParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SliceDim != nil {
		n += 1 + sovCaffe(uint64(*m.SliceDim))
	}
	if len(m.SlicePoint) > 0 {
		for _, e := range m.SlicePoint {
			n += 1 + sovCaffe(uint64(e))
		}
	}
	if m.Axis != nil {
		n += 1 + sovCaffe(uint64(*m.Axis))
	}
	return n
}

func (m *SoftmaxParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Engine != nil {
		n += 1 + sovCaffe(uint64(*m.Engine))
	}
	if m.Axis != nil {
		n += 1 + sovCaffe(uint64(*m.Axis))
	}
	return n
}

func (m *TanHParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Engine != nil {
		n += 1 + sovCaffe(uint64(*m.Engine))
	}
	return n
}

func (m *TileParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Axis != nil {
		n += 1 + sovCaffe(uint64(*m.Axis))
	}
	n += 1 + sovCaffe(uint64(m.Tiles))
	return n
}

func (m *ThresholdParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Threshold != nil {
		n += 5
	}
	return n
}

func (m *WindowDataParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	n += 1 + l + sovCaffe(uint64(l))
	if m.Scale != nil {
		n += 5
	}
	l = len(m.MeanFile)
	n += 1 + l + sovCaffe(uint64(l))
	n += 1 + sovCaffe(uint64(m.BatchSize))
	if m.CropSize != nil {
		n += 1 + sovCaffe(uint64(*m.CropSize))
	}
	if m.Mirror != nil {
		n += 2
	}
	if m.FgThreshold != nil {
		n += 5
	}
	if m.BgThreshold != nil {
		n += 5
	}
	if m.FgFraction != nil {
		n += 5
	}
	if m.ContextPad != nil {
		n += 1 + sovCaffe(uint64(*m.ContextPad))
	}
	if m.CropMode != nil {
		l = len(*m.CropMode)
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.CacheImages != nil {
		n += 2
	}
	if m.RootFolder != nil {
		l = len(*m.RootFolder)
		n += 1 + l + sovCaffe(uint64(l))
	}
	return n
}

func (m *SPPParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCaffe(uint64(m.PyramidHeight))
	if m.Pool != nil {
		n += 1 + sovCaffe(uint64(*m.Pool))
	}
	if m.Engine != nil {
		n += 1 + sovCaffe(uint64(*m.Engine))
	}
	return n
}

func (m *V1LayerParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layer != nil {
		l = m.Layer.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if len(m.Bottom) > 0 {
		for _, s := range m.Bottom {
			l = len(s)
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.Top) > 0 {
		for _, s := range m.Top {
			l = len(s)
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	l = len(m.Name)
	n += 1 + l + sovCaffe(uint64(l))
	n += 1 + sovCaffe(uint64(m.Type))
	if len(m.Blobs) > 0 {
		for _, e := range m.Blobs {
			l = e.Size()
			n += 1 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.BlobsLr) > 0 {
		n += 5 * len(m.BlobsLr)
	}
	if len(m.WeightDecay) > 0 {
		n += 5 * len(m.WeightDecay)
	}
	if m.ConcatParam != nil {
		l = m.ConcatParam.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.ConvolutionParam != nil {
		l = m.ConvolutionParam.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.DataParam != nil {
		l = m.DataParam.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.DropoutParam != nil {
		l = m.DropoutParam.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.Hdf5DataParam != nil {
		l = m.Hdf5DataParam.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.Hdf5OutputParam != nil {
		l = m.Hdf5OutputParam.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.ImageDataParam != nil {
		l = m.ImageDataParam.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.InfogainLossParam != nil {
		l = m.InfogainLossParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.InnerProductParam != nil {
		l = m.InnerProductParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.LrnParam != nil {
		l = m.LrnParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.PoolingParam != nil {
		l = m.PoolingParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.WindowDataParam != nil {
		l = m.WindowDataParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.PowerParam != nil {
		l = m.PowerParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.MemoryDataParam != nil {
		l = m.MemoryDataParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ArgmaxParam != nil {
		l = m.ArgmaxParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.EltwiseParam != nil {
		l = m.EltwiseParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ThresholdParam != nil {
		l = m.ThresholdParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.DummyDataParam != nil {
		l = m.DummyDataParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.AccuracyParam != nil {
		l = m.AccuracyParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.HingeLossParam != nil {
		l = m.HingeLossParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ReluParam != nil {
		l = m.ReluParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.SliceParam != nil {
		l = m.SliceParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if len(m.Include) > 0 {
		for _, e := range m.Include {
			l = e.Size()
			n += 2 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.Exclude) > 0 {
		for _, e := range m.Exclude {
			l = e.Size()
			n += 2 + l + sovCaffe(uint64(l))
		}
	}
	if m.MvnParam != nil {
		l = m.MvnParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if len(m.LossWeight) > 0 {
		n += 6 * len(m.LossWeight)
	}
	if m.TransformParam != nil {
		l = m.TransformParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.TanhParam != nil {
		l = m.TanhParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.SigmoidParam != nil {
		l = m.SigmoidParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.SoftmaxParam != nil {
		l = m.SoftmaxParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ContrastiveLossParam != nil {
		l = m.ContrastiveLossParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.ExpParam != nil {
		l = m.ExpParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.LossParam != nil {
		l = m.LossParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	if len(m.Param) > 0 {
		for _, s := range m.Param {
			l = len(s)
			n += 2 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.BlobShareMode) > 0 {
		for _, e := range m.BlobShareMode {
			n += 2 + sovCaffe(uint64(e))
		}
	}
	return n
}

func (m *V0LayerParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCaffe(uint64(l))
	l = len(m.Type)
	n += 1 + l + sovCaffe(uint64(l))
	n += 1 + sovCaffe(uint64(m.NumOutput))
	if m.Biasterm != nil {
		n += 2
	}
	if m.WeightFiller != nil {
		l = m.WeightFiller.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.BiasFiller != nil {
		l = m.BiasFiller.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.Pad != nil {
		n += 1 + sovCaffe(uint64(*m.Pad))
	}
	n += 1 + sovCaffe(uint64(m.Kernelsize))
	if m.Group != nil {
		n += 1 + sovCaffe(uint64(*m.Group))
	}
	if m.Stride != nil {
		n += 1 + sovCaffe(uint64(*m.Stride))
	}
	if m.Pool != nil {
		n += 1 + sovCaffe(uint64(*m.Pool))
	}
	if m.DropoutRatio != nil {
		n += 5
	}
	if m.LocalSize != nil {
		n += 1 + sovCaffe(uint64(*m.LocalSize))
	}
	if m.Alpha != nil {
		n += 5
	}
	if m.Beta != nil {
		n += 5
	}
	l = len(m.Source)
	n += 2 + l + sovCaffe(uint64(l))
	if m.Scale != nil {
		n += 6
	}
	l = len(m.Meanfile)
	n += 2 + l + sovCaffe(uint64(l))
	n += 2 + sovCaffe(uint64(m.Batchsize))
	if m.Cropsize != nil {
		n += 2 + sovCaffe(uint64(*m.Cropsize))
	}
	if m.Mirror != nil {
		n += 3
	}
	if m.K != nil {
		n += 6
	}
	if len(m.Blobs) > 0 {
		for _, e := range m.Blobs {
			l = e.Size()
			n += 2 + l + sovCaffe(uint64(l))
		}
	}
	if len(m.BlobsLr) > 0 {
		n += 6 * len(m.BlobsLr)
	}
	if len(m.WeightDecay) > 0 {
		n += 6 * len(m.WeightDecay)
	}
	if m.RandSkip != nil {
		n += 2 + sovCaffe(uint64(*m.RandSkip))
	}
	if m.DetFgThreshold != nil {
		n += 6
	}
	if m.DetBgThreshold != nil {
		n += 6
	}
	if m.DetFgFraction != nil {
		n += 6
	}
	if m.DetContextPad != nil {
		n += 2 + sovCaffe(uint64(*m.DetContextPad))
	}
	if m.DetCropMode != nil {
		l = len(*m.DetCropMode)
		n += 2 + l + sovCaffe(uint64(l))
	}
	if m.NewNum != nil {
		n += 2 + sovCaffe(uint64(*m.NewNum))
	}
	if m.NewChannels != nil {
		n += 2 + sovCaffe(uint64(*m.NewChannels))
	}
	if m.NewHeight != nil {
		n += 2 + sovCaffe(uint64(*m.NewHeight))
	}
	if m.NewWidth != nil {
		n += 2 + sovCaffe(uint64(*m.NewWidth))
	}
	if m.ShuffleImages != nil {
		n += 3
	}
	if m.ConcatDim != nil {
		n += 2 + sovCaffe(uint64(*m.ConcatDim))
	}
	if m.Hdf5OutputParam != nil {
		l = m.Hdf5OutputParam.Size()
		n += 2 + l + sovCaffe(uint64(l))
	}
	return n
}

func (m *PReLUParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filler != nil {
		l = m.Filler.Size()
		n += 1 + l + sovCaffe(uint64(l))
	}
	if m.ChannelShared != nil {
		n += 2
	}
	return n
}

func sovCaffe(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCaffe(x uint64) (n int) {
	return sovCaffe(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BlobShape) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobShape: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobShape: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dim = append(m.Dim, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dim = append(m.Dim, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dim", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Num = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Channels = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Height = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Width = &v
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Data = append(m.Data, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.Data) == 0 {
					m.Data = make([]float32, 0, packedLen/4)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Data = append(m.Data, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Diff = append(m.Diff, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.Diff) == 0 {
					m.Diff = make([]float32, 0, packedLen/4)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Diff = append(m.Diff, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Diff", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shape == nil {
				m.Shape = &BlobShape{}
			}
			if err := m.Shape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.DoubleData = append(m.DoubleData, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.DoubleData) == 0 {
					m.DoubleData = make([]float64, 0, packedLen/8)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.DoubleData = append(m.DoubleData, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleData", wireType)
			}
		case 9:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.DoubleDiff = append(m.DoubleDiff, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.DoubleDiff) == 0 {
					m.DoubleDiff = make([]float64, 0, packedLen/8)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.DoubleDiff = append(m.DoubleDiff, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleDiff", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobProtoVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobProtoVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobProtoVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blobs = append(m.Blobs, &BlobProto{})
			if err := m.Blobs[len(m.Blobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Datum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Datum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Datum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			m.Channels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channels |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.FloatData = append(m.FloatData, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.FloatData) == 0 {
					m.FloatData = make([]float32, 0, packedLen/4)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.FloatData = append(m.FloatData, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatData", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Encoded = &b
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FillerParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FillerParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FillerParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Value = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Min = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Max = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mean", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Mean = &v2
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Std", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Std = &v2
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sparse", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sparse = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VarianceNorm", wireType)
			}
			var v FillerParameter_VarianceNorm
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (FillerParameter_VarianceNorm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VarianceNorm = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layers = append(m.Layers, &V1LayerParameter{})
			if err := m.Layers[len(m.Layers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = append(m.Input, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InputDim = append(m.InputDim, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InputDim = append(m.InputDim, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InputDim", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceBackward", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ForceBackward = &b
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &NetState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugInfo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DebugInfo = &b
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputShape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputShape = append(m.InputShape, &BlobShape{})
			if err := m.InputShape[len(m.InputShape)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layer = append(m.Layer, &LayerParameter{})
			if err := m.Layer[len(m.Layer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SolverParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SolverParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SolverParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainNet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrainNet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestNet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestNet = append(m.TestNet, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TestIter = append(m.TestIter, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TestIter = append(m.TestIter, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TestIter", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestInterval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TestInterval = &v
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseLr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BaseLr = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			m.Display = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Display |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxIter", wireType)
			}
			m.MaxIter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxIter |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LrPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LrPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gamma", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Gamma = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Power = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Momentum", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Momentum = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightDecay", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WeightDecay = float32(math.Float32frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stepsize", wireType)
			}
			m.Stepsize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stepsize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Snapshot = &v
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotDiff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SnapshotDiff = &b
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SolverMode", wireType)
			}
			var v SolverParameter_SolverMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (SolverParameter_SolverMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SolverMode = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeviceId = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestComputeLoss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TestComputeLoss = &b
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSeed", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RandomSeed = &v
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainNetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrainNetParam == nil {
				m.TrainNetParam = &NetParameter{}
			}
			if err := m.TrainNetParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestNetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestNetParam = append(m.TestNetParam, &NetParameter{})
			if err := m.TestNetParam[len(m.TestNetParam)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugInfo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DebugInfo = &b
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Net", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Net = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetParam == nil {
				m.NetParam = &NetParameter{}
			}
			if err := m.NetParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrainState == nil {
				m.TrainState = &NetState{}
			}
			if err := m.TrainState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestState = append(m.TestState, &NetState{})
			if err := m.TestState[len(m.TestState)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotAfterTrain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SnapshotAfterTrain = &b
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegularizationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RegularizationType = &s
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SolverType", wireType)
			}
			var v SolverParameter_SolverType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (SolverParameter_SolverType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SolverType = &v
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Delta = &v2
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestInitialization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TestInitialization = &b
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageLoss", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AverageLoss = &v
		case 34:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Stepvalue = append(m.Stepvalue, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Stepvalue = append(m.Stepvalue, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Stepvalue", wireType)
			}
		case 35:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClipGradients", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.ClipGradients = &v2
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IterSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IterSize = &v
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotFormat", wireType)
			}
			var v SolverParameter_SnapshotFormat
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (SolverParameter_SnapshotFormat(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SnapshotFormat = &v
		case 38:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RmsDecay", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RmsDecay = float32(math.Float32frombits(v))
		case 39:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Momentum2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Momentum2 = &v2
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SolverState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SolverState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SolverState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iter", wireType)
			}
			m.Iter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iter |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnedNet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LearnedNet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.History = append(m.History, &BlobProto{})
			if err := m.History[len(m.History)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentStep", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CurrentStep = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var v Phase
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Phase(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Phase = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Level = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stage = append(m.Stage, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetStateRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetStateRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetStateRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= (Phase(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLevel", wireType)
			}
			m.MinLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLevel", wireType)
			}
			m.MaxLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stage = append(m.Stage, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotStage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotStage = append(m.NotStage, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParamSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParamSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParamSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareMode", wireType)
			}
			m.ShareMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShareMode |= (ParamSpec_DimCheckMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LrMult", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LrMult = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecayMult", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DecayMult = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LayerParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LayerParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LayerParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bottom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bottom = append(m.Bottom, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Top", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Top = append(m.Top, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.LossWeight = append(m.LossWeight, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.LossWeight) == 0 {
					m.LossWeight = make([]float32, 0, packedLen/4)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.LossWeight = append(m.LossWeight, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LossWeight", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = append(m.Param, &ParamSpec{})
			if err := m.Param[len(m.Param)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blobs = append(m.Blobs, &BlobProto{})
			if err := m.Blobs[len(m.Blobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Include", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Include = append(m.Include, &NetStateRule{})
			if err := m.Include[len(m.Include)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exclude = append(m.Exclude, &NetStateRule{})
			if err := m.Exclude[len(m.Exclude)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= (Phase(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PropagateDown = append(m.PropagateDown, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PropagateDown = append(m.PropagateDown, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PropagateDown", wireType)
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransformParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransformParam == nil {
				m.TransformParam = &TransformationParameter{}
			}
			if err := m.TransformParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LossParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LossParam == nil {
				m.LossParam = &LossParameter{}
			}
			if err := m.LossParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccuracyParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccuracyParam == nil {
				m.AccuracyParam = &AccuracyParameter{}
			}
			if err := m.AccuracyParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgmaxParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ArgmaxParam == nil {
				m.ArgmaxParam = &ArgMaxParameter{}
			}
			if err := m.ArgmaxParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcatParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConcatParam == nil {
				m.ConcatParam = &ConcatParameter{}
			}
			if err := m.ConcatParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 105:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContrastiveLossParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContrastiveLossParam == nil {
				m.ContrastiveLossParam = &ContrastiveLossParameter{}
			}
			if err := m.ContrastiveLossParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 106:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConvolutionParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConvolutionParam == nil {
				m.ConvolutionParam = &ConvolutionParameter{}
			}
			if err := m.ConvolutionParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 107:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataParam == nil {
				m.DataParam = &DataParameter{}
			}
			if err := m.DataParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropoutParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DropoutParam == nil {
				m.DropoutParam = &DropoutParameter{}
			}
			if err := m.DropoutParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 109:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DummyDataParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DummyDataParam == nil {
				m.DummyDataParam = &DummyDataParameter{}
			}
			if err := m.DummyDataParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 110:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EltwiseParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EltwiseParam == nil {
				m.EltwiseParam = &EltwiseParameter{}
			}
			if err := m.EltwiseParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 111:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpParam == nil {
				m.ExpParam = &ExpParameter{}
			}
			if err := m.ExpParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 112:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hdf5DataParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hdf5DataParam == nil {
				m.Hdf5DataParam = &HDF5DataParameter{}
			}
			if err := m.Hdf5DataParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 113:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hdf5OutputParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hdf5OutputParam == nil {
				m.Hdf5OutputParam = &HDF5OutputParameter{}
			}
			if err := m.Hdf5OutputParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HingeLossParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HingeLossParam == nil {
				m.HingeLossParam = &HingeLossParameter{}
			}
			if err := m.HingeLossParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 115:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageDataParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageDataParam == nil {
				m.ImageDataParam = &ImageDataParameter{}
			}
			if err := m.ImageDataParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 116:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfogainLossParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfogainLossParam == nil {
				m.InfogainLossParam = &InfogainLossParameter{}
			}
			if err := m.InfogainLossParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 117:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerProductParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InnerProductParam == nil {
				m.InnerProductParam = &InnerProductParameter{}
			}
			if err := m.InnerProductParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 118:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LrnParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LrnParam == nil {
				m.LrnParam = &LRNParameter{}
			}
			if err := m.LrnParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 119:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryDataParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoryDataParam == nil {
				m.MemoryDataParam = &MemoryDataParameter{}
			}
			if err := m.MemoryDataParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 120:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvnParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MvnParam == nil {
				m.MvnParam = &MVNParameter{}
			}
			if err := m.MvnParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 121:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolingParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PoolingParam == nil {
				m.PoolingParam = &PoolingParameter{}
			}
			if err := m.PoolingParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 122:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PowerParam == nil {
				m.PowerParam = &PowerParameter{}
			}
			if err := m.PowerParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 123:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReluParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReluParam == nil {
				m.ReluParam = &ReLUParameter{}
			}
			if err := m.ReluParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 124:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigmoidParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigmoidParam == nil {
				m.SigmoidParam = &SigmoidParameter{}
			}
			if err := m.SigmoidParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 125:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoftmaxParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SoftmaxParam == nil {
				m.SoftmaxParam = &SoftmaxParameter{}
			}
			if err := m.SoftmaxParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 126:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliceParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SliceParam == nil {
				m.SliceParam = &SliceParameter{}
			}
			if err := m.SliceParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 127:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TanhParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TanhParam == nil {
				m.TanhParam = &TanHParameter{}
			}
			if err := m.TanhParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 128:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ThresholdParam == nil {
				m.ThresholdParam = &ThresholdParameter{}
			}
			if err := m.ThresholdParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 129:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowDataParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WindowDataParam == nil {
				m.WindowDataParam = &WindowDataParameter{}
			}
			if err := m.WindowDataParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 130:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PythonParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PythonParam == nil {
				m.PythonParam = &PythonParameter{}
			}
			if err := m.PythonParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 131:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreluParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreluParam == nil {
				m.PreluParam = &PReLUParameter{}
			}
			if err := m.PreluParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 132:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SppParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SppParam == nil {
				m.SppParam = &SPPParameter{}
			}
			if err := m.SppParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 133:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReshapeParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReshapeParam == nil {
				m.ReshapeParam = &ReshapeParameter{}
			}
			if err := m.ReshapeParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 134:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogParam == nil {
				m.LogParam = &LogParameter{}
			}
			if err := m.LogParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 135:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlattenParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlattenParam == nil {
				m.FlattenParam = &FlattenParameter{}
			}
			if err := m.FlattenParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 136:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReductionParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReductionParam == nil {
				m.ReductionParam = &ReductionParameter{}
			}
			if err := m.ReductionParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 137:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmbedParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EmbedParam == nil {
				m.EmbedParam = &EmbedParameter{}
			}
			if err := m.EmbedParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 138:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TileParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TileParam == nil {
				m.TileParam = &TileParameter{}
			}
			if err := m.TileParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 139:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchNormParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchNormParam == nil {
				m.BatchNormParam = &BatchNormParameter{}
			}
			if err := m.BatchNormParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 140:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EluParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EluParam == nil {
				m.EluParam = &ELUParameter{}
			}
			if err := m.EluParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 141:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiasParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BiasParam == nil {
				m.BiasParam = &BiasParameter{}
			}
			if err := m.BiasParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 142:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScaleParam == nil {
				m.ScaleParam = &ScaleParameter{}
			}
			if err := m.ScaleParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 143:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputParam == nil {
				m.InputParam = &InputParameter{}
			}
			if err := m.InputParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 144:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CropParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CropParam == nil {
				m.CropParam = &CropParameter{}
			}
			if err := m.CropParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 145:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParameterParam == nil {
				m.ParameterParam = &ParameterParameter{}
			}
			if err := m.ParameterParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 146:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecurrentParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecurrentParam == nil {
				m.RecurrentParam = &RecurrentParameter{}
			}
			if err := m.RecurrentParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransformationParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransformationParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransformationParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Scale = &v2
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Mirror = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CropSize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CropSize = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeanFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeanFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.MeanValue = append(m.MeanValue, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.MeanValue) == 0 {
					m.MeanValue = make([]float32, 0, packedLen/4)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.MeanValue = append(m.MeanValue, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MeanValue", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceColor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ForceColor = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceGray", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ForceGray = &b
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LossParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LossParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LossParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreLabel", wireType)
			}
			m.IgnoreLabel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IgnoreLabel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Normalize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Normalize = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Normalization", wireType)
			}
			var v LossParameter_NormalizationMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (LossParameter_NormalizationMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Normalization = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccuracyParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccuracyParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccuracyParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopK", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TopK = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Axis = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreLabel", wireType)
			}
			m.IgnoreLabel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IgnoreLabel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgMaxParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgMaxParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgMaxParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutMaxVal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OutMaxVal = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopK", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TopK = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			m.Axis = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Axis |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConcatParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConcatParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConcatParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcatDim", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConcatDim = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Axis = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchNormParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchNormParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchNormParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseGlobalStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseGlobalStats = bool(v != 0)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MovingAverageFraction", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MovingAverageFraction = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Eps = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BiasParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BiasParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BiasParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Axis = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAxes", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumAxes = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filler == nil {
				m.Filler = &FillerParameter{}
			}
			if err := m.Filler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContrastiveLossParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContrastiveLossParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContrastiveLossParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Margin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Margin = &v2
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyVersion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LegacyVersion = &b
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvolutionParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvolutionParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvolutionParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOutput", wireType)
			}
			m.NumOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOutput |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiasTerm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BiasTerm = &b
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Pad = append(m.Pad, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Pad = append(m.Pad, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pad", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KernelSize = append(m.KernelSize, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KernelSize = append(m.KernelSize, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelSize", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Group = &v
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Stride = append(m.Stride, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Stride = append(m.Stride, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Stride", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightFiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WeightFiller == nil {
				m.WeightFiller = &FillerParameter{}
			}
			if err := m.WeightFiller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiasFiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BiasFiller == nil {
				m.BiasFiller = &FillerParameter{}
			}
			if err := m.BiasFiller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PadH", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PadH = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PadW", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PadW = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelH", wireType)
			}
			m.KernelH = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelH |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelW", wireType)
			}
			m.KernelW = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelW |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrideH", wireType)
			}
			m.StrideH = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StrideH |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrideW", wireType)
			}
			m.StrideW = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StrideW |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Engine", wireType)
			}
			var v ConvolutionParameter_Engine
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ConvolutionParameter_Engine(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Engine = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Axis = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceNdIm2Col", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ForceNdIm2Col = &b
		case 18:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dilation = append(m.Dilation, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dilation = append(m.Dilation, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dilation", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CropParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CropParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CropParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Axis = &v
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Offset = append(m.Offset, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Offset = append(m.Offset, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Scale = &v2
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeanFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeanFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CropSize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CropSize = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Mirror = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandSkip", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RandSkip = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backend", wireType)
			}
			var v DataParameter_DB
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (DataParameter_DB(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Backend = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceEncodedColor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ForceEncodedColor = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefetch", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Prefetch = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropoutParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropoutParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropoutParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropoutRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DropoutRatio = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DummyDataParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DummyDataParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DummyDataParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFiller = append(m.DataFiller, &FillerParameter{})
			if err := m.DataFiller[len(m.DataFiller)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Num = append(m.Num, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Num = append(m.Num, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Channels = append(m.Channels, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Channels = append(m.Channels, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Height = append(m.Height, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Height = append(m.Height, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Width = append(m.Width, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Width = append(m.Width, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shape = append(m.Shape, &BlobShape{})
			if err := m.Shape[len(m.Shape)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EltwiseParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EltwiseParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EltwiseParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var v EltwiseParameter_EltwiseOp
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (EltwiseParameter_EltwiseOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Operation = &v
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Coeff = append(m.Coeff, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.Coeff) == 0 {
					m.Coeff = make([]float32, 0, packedLen/4)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Coeff = append(m.Coeff, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Coeff", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StableProdGrad", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.StableProdGrad = &b
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ELUParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ELUParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ELUParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alpha", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Alpha = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmbedParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmbedParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmbedParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOutput", wireType)
			}
			m.NumOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOutput |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputDim", wireType)
			}
			m.InputDim = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputDim |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiasTerm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BiasTerm = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightFiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WeightFiller == nil {
				m.WeightFiller = &FillerParameter{}
			}
			if err := m.WeightFiller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiasFiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BiasFiller == nil {
				m.BiasFiller = &FillerParameter{}
			}
			if err := m.BiasFiller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Base = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Scale = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shift", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Shift = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlattenParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlattenParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlattenParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Axis = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndAxis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EndAxis = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HDF5DataParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HDF5DataParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HDF5DataParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Shuffle = &b
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HDF5OutputParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HDF5OutputParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HDF5OutputParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HingeLossParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HingeLossParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HingeLossParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Norm", wireType)
			}
			var v HingeLossParameter_Norm
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (HingeLossParameter_Norm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Norm = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageDataParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageDataParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageDataParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Scale = &v2
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeanFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeanFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BatchSize = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CropSize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CropSize = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Mirror = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandSkip", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RandSkip = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Shuffle = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewHeight", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewHeight = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewWidth", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewWidth = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsColor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsColor = &b
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootFolder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RootFolder = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfogainLossParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfogainLossParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfogainLossParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InnerProductParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InnerProductParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InnerProductParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOutput", wireType)
			}
			m.NumOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOutput |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiasTerm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BiasTerm = &b
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightFiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WeightFiller == nil {
				m.WeightFiller = &FillerParameter{}
			}
			if err := m.WeightFiller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiasFiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BiasFiller == nil {
				m.BiasFiller = &FillerParameter{}
			}
			if err := m.BiasFiller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Axis = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transpose", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Transpose = &b
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shape = append(m.Shape, &BlobShape{})
			if err := m.Shape[len(m.Shape)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Base = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Scale = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shift", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Shift = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LRNParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LRNParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LRNParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalSize = &v
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alpha", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Alpha = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Beta", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Beta = &v2
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormRegion", wireType)
			}
			var v LRNParameter_NormRegion
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (LRNParameter_NormRegion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NormRegion = &v
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.K = &v2
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Engine", wireType)
			}
			var v LRNParameter_Engine
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (LRNParameter_Engine(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Engine = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryDataParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryDataParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryDataParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			m.Channels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channels |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVNParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVNParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVNParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalizeVariance", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NormalizeVariance = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcrossChannels", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AcrossChannels = &b
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Eps = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParameterParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParameterParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParameterParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shape == nil {
				m.Shape = &BlobShape{}
			}
			if err := m.Shape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolingParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolingParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolingParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var v PoolingParameter_PoolMethod
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (PoolingParameter_PoolMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pool = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelSize", wireType)
			}
			m.KernelSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stride", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stride = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pad", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pad = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelH", wireType)
			}
			m.KernelH = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelH |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelW", wireType)
			}
			m.KernelW = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelW |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrideH", wireType)
			}
			m.StrideH = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StrideH |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrideW", wireType)
			}
			m.StrideW = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StrideW |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PadH", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PadH = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PadW", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PadW = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Engine", wireType)
			}
			var v PoolingParameter_Engine
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (PoolingParameter_Engine(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Engine = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalPooling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.GlobalPooling = &b
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PowerParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PowerParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PowerParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Power = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Scale = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shift", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Shift = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PythonParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PythonParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PythonParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ParamStr = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareInParallel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ShareInParallel = &b
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecurrentParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecurrentParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecurrentParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOutput", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumOutput = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightFiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WeightFiller == nil {
				m.WeightFiller = &FillerParameter{}
			}
			if err := m.WeightFiller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiasFiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BiasFiller == nil {
				m.BiasFiller = &FillerParameter{}
			}
			if err := m.BiasFiller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugInfo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DebugInfo = &b
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposeHidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ExposeHidden = &b
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReductionParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReductionParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReductionParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var v ReductionParameter_ReductionOp
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ReductionParameter_ReductionOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Operation = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Axis = &v
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coeff", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Coeff = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReLUParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReLUParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReLUParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeSlope", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.NegativeSlope = &v2
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Engine", wireType)
			}
			var v ReLUParameter_Engine
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ReLUParameter_Engine(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Engine = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReshapeParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReshapeParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReshapeParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shape == nil {
				m.Shape = &BlobShape{}
			}
			if err := m.Shape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Axis = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAxes", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumAxes = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScaleParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScaleParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScaleParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Axis = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAxes", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumAxes = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filler == nil {
				m.Filler = &FillerParameter{}
			}
			if err := m.Filler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiasTerm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BiasTerm = &b
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiasFiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BiasFiller == nil {
				m.BiasFiller = &FillerParameter{}
			}
			if err := m.BiasFiller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigmoidParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigmoidParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigmoidParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Engine", wireType)
			}
			var v SigmoidParameter_Engine
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (SigmoidParameter_Engine(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Engine = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SliceParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SliceParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SliceParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliceDim", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SliceDim = &v
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SlicePoint = append(m.SlicePoint, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SlicePoint = append(m.SlicePoint, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SlicePoint", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Axis = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoftmaxParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoftmaxParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoftmaxParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Engine", wireType)
			}
			var v SoftmaxParameter_Engine
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (SoftmaxParameter_Engine(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Engine = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Axis = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TanHParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TanHParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TanHParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Engine", wireType)
			}
			var v TanHParameter_Engine
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (TanHParameter_Engine(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Engine = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TileParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TileParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TileParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Axis", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Axis = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tiles", wireType)
			}
			m.Tiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tiles |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Threshold = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowDataParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowDataParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowDataParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Scale = &v2
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeanFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeanFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CropSize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CropSize = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Mirror = &b
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FgThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FgThreshold = &v2
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.BgThreshold = &v2
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FgFraction", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FgFraction = &v2
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextPad", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContextPad = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CropMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CropMode = &s
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheImages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CacheImages = &b
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootFolder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RootFolder = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SPPParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SPPParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SPPParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PyramidHeight", wireType)
			}
			m.PyramidHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PyramidHeight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var v SPPParameter_PoolMethod
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (SPPParameter_PoolMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pool = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Engine", wireType)
			}
			var v SPPParameter_Engine
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (SPPParameter_Engine(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Engine = &v
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *V1LayerParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: V1LayerParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: V1LayerParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Layer == nil {
				m.Layer = &V0LayerParameter{}
			}
			if err := m.Layer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bottom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bottom = append(m.Bottom, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Top", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Top = append(m.Top, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (V1LayerParameter_LayerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blobs = append(m.Blobs, &BlobProto{})
			if err := m.Blobs[len(m.Blobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.BlobsLr = append(m.BlobsLr, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.BlobsLr) == 0 {
					m.BlobsLr = make([]float32, 0, packedLen/4)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.BlobsLr = append(m.BlobsLr, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BlobsLr", wireType)
			}
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.WeightDecay = append(m.WeightDecay, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.WeightDecay) == 0 {
					m.WeightDecay = make([]float32, 0, packedLen/4)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.WeightDecay = append(m.WeightDecay, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightDecay", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcatParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConcatParam == nil {
				m.ConcatParam = &ConcatParameter{}
			}
			if err := m.ConcatParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConvolutionParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConvolutionParam == nil {
				m.ConvolutionParam = &ConvolutionParameter{}
			}
			if err := m.ConvolutionParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataParam == nil {
				m.DataParam = &DataParameter{}
			}
			if err := m.DataParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropoutParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DropoutParam == nil {
				m.DropoutParam = &DropoutParameter{}
			}
			if err := m.DropoutParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hdf5DataParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hdf5DataParam == nil {
				m.Hdf5DataParam = &HDF5DataParameter{}
			}
			if err := m.Hdf5DataParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hdf5OutputParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hdf5OutputParam == nil {
				m.Hdf5OutputParam = &HDF5OutputParameter{}
			}
			if err := m.Hdf5OutputParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageDataParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageDataParam == nil {
				m.ImageDataParam = &ImageDataParameter{}
			}
			if err := m.ImageDataParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfogainLossParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfogainLossParam == nil {
				m.InfogainLossParam = &InfogainLossParameter{}
			}
			if err := m.InfogainLossParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerProductParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InnerProductParam == nil {
				m.InnerProductParam = &InnerProductParameter{}
			}
			if err := m.InnerProductParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LrnParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LrnParam == nil {
				m.LrnParam = &LRNParameter{}
			}
			if err := m.LrnParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolingParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PoolingParam == nil {
				m.PoolingParam = &PoolingParameter{}
			}
			if err := m.PoolingParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowDataParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WindowDataParam == nil {
				m.WindowDataParam = &WindowDataParameter{}
			}
			if err := m.WindowDataParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PowerParam == nil {
				m.PowerParam = &PowerParameter{}
			}
			if err := m.PowerParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryDataParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoryDataParam == nil {
				m.MemoryDataParam = &MemoryDataParameter{}
			}
			if err := m.MemoryDataParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgmaxParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ArgmaxParam == nil {
				m.ArgmaxParam = &ArgMaxParameter{}
			}
			if err := m.ArgmaxParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EltwiseParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EltwiseParam == nil {
				m.EltwiseParam = &EltwiseParameter{}
			}
			if err := m.EltwiseParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ThresholdParam == nil {
				m.ThresholdParam = &ThresholdParameter{}
			}
			if err := m.ThresholdParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DummyDataParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DummyDataParam == nil {
				m.DummyDataParam = &DummyDataParameter{}
			}
			if err := m.DummyDataParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccuracyParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccuracyParam == nil {
				m.AccuracyParam = &AccuracyParameter{}
			}
			if err := m.AccuracyParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HingeLossParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HingeLossParam == nil {
				m.HingeLossParam = &HingeLossParameter{}
			}
			if err := m.HingeLossParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReluParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReluParam == nil {
				m.ReluParam = &ReLUParameter{}
			}
			if err := m.ReluParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliceParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SliceParam == nil {
				m.SliceParam = &SliceParameter{}
			}
			if err := m.SliceParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Include", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Include = append(m.Include, &NetStateRule{})
			if err := m.Include[len(m.Include)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exclude = append(m.Exclude, &NetStateRule{})
			if err := m.Exclude[len(m.Exclude)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvnParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MvnParam == nil {
				m.MvnParam = &MVNParameter{}
			}
			if err := m.MvnParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.LossWeight = append(m.LossWeight, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.LossWeight) == 0 {
					m.LossWeight = make([]float32, 0, packedLen/4)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.LossWeight = append(m.LossWeight, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LossWeight", wireType)
			}
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransformParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransformParam == nil {
				m.TransformParam = &TransformationParameter{}
			}
			if err := m.TransformParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TanhParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TanhParam == nil {
				m.TanhParam = &TanHParameter{}
			}
			if err := m.TanhParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigmoidParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigmoidParam == nil {
				m.SigmoidParam = &SigmoidParameter{}
			}
			if err := m.SigmoidParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoftmaxParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SoftmaxParam == nil {
				m.SoftmaxParam = &SoftmaxParameter{}
			}
			if err := m.SoftmaxParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContrastiveLossParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContrastiveLossParam == nil {
				m.ContrastiveLossParam = &ContrastiveLossParameter{}
			}
			if err := m.ContrastiveLossParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpParam == nil {
				m.ExpParam = &ExpParameter{}
			}
			if err := m.ExpParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LossParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LossParam == nil {
				m.LossParam = &LossParameter{}
			}
			if err := m.LossParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = append(m.Param, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 1002:
			if wireType == 0 {
				var v V1LayerParameter_DimCheckMode
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (V1LayerParameter_DimCheckMode(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BlobShareMode = append(m.BlobShareMode, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v V1LayerParameter_DimCheckMode
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCaffe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (V1LayerParameter_DimCheckMode(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BlobShareMode = append(m.BlobShareMode, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BlobShareMode", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *V0LayerParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: V0LayerParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: V0LayerParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOutput", wireType)
			}
			m.NumOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOutput |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Biasterm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Biasterm = &b
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightFiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WeightFiller == nil {
				m.WeightFiller = &FillerParameter{}
			}
			if err := m.WeightFiller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiasFiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BiasFiller == nil {
				m.BiasFiller = &FillerParameter{}
			}
			if err := m.BiasFiller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pad", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pad = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kernelsize", wireType)
			}
			m.Kernelsize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kernelsize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Group = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stride", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stride = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var v V0LayerParameter_PoolMethod
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (V0LayerParameter_PoolMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pool = &v
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropoutRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DropoutRatio = &v2
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalSize = &v
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alpha", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Alpha = &v2
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Beta", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Beta = &v2
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Scale = &v2
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meanfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Meanfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batchsize", wireType)
			}
			m.Batchsize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Batchsize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cropsize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cropsize = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Mirror = &b
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.K = &v2
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blobs = append(m.Blobs, &BlobProto{})
			if err := m.Blobs[len(m.Blobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.BlobsLr = append(m.BlobsLr, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.BlobsLr) == 0 {
					m.BlobsLr = make([]float32, 0, packedLen/4)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.BlobsLr = append(m.BlobsLr, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BlobsLr", wireType)
			}
		case 52:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.WeightDecay = append(m.WeightDecay, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCaffe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.WeightDecay) == 0 {
					m.WeightDecay = make([]float32, 0, packedLen/4)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.WeightDecay = append(m.WeightDecay, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightDecay", wireType)
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandSkip", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RandSkip = &v
		case 54:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetFgThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DetFgThreshold = &v2
		case 55:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetBgThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DetBgThreshold = &v2
		case 56:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetFgFraction", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DetFgFraction = &v2
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetContextPad", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DetContextPad = &v
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetCropMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DetCropMode = &s
			iNdEx = postIndex
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewNum = &v
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewChannels", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewChannels = &v
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewHeight", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewHeight = &v
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewWidth", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewWidth = &v
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleImages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ShuffleImages = &b
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcatDim", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConcatDim = &v
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hdf5OutputParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hdf5OutputParam == nil {
				m.Hdf5OutputParam = &HDF5OutputParameter{}
			}
			if err := m.Hdf5OutputParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PReLUParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PReLUParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PReLUParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaffe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filler == nil {
				m.Filler = &FillerParameter{}
			}
			if err := m.Filler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelShared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ChannelShared = &b
		default:
			iNdEx = preIndex
			skippy, err := skipCaffe(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCaffe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCaffe(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCaffe
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaffe
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCaffe
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCaffe
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCaffe(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCaffe = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCaffe   = fmt.Errorf("proto: integer overflow")
)

func disabled_init2() { proto.RegisterFile("caffe.proto", fileDescriptor_caffe_1be6848cf218e0b1) }

var fileDescriptor_caffe_1be6848cf218e0b1 = []byte{
	// 6565 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x7c, 0x49, 0x6c, 0x23, 0xd9,
	0x79, 0x70, 0x73, 0x93, 0xc8, 0x8f, 0x22, 0x55, 0x7a, 0xea, 0x56, 0xb3, 0x37, 0xb5, 0xba, 0x7a,
	0x19, 0x79, 0x16, 0xfd, 0xdd, 0x3d, 0xd3, 0xb3, 0x68, 0xc6, 0x0b, 0x25, 0x52, 0x12, 0xff, 0x50,
	0x24, 0x53, 0xa4, 0xd4, 0x33, 0xf1, 0x81, 0x28, 0xb1, 0x1e, 0xc9, 0x72, 0x17, 0xab, 0x98, 0xaa,
	0xa2, 0x96, 0xc9, 0x66, 0x67, 0x5f, 0x1c, 0xc7, 0x0e, 0x10, 0xe7, 0xe2, 0x00, 0x39, 0x04, 0x39,
	0x06, 0xc8, 0x3d, 0x87, 0x20, 0x40, 0x10, 0x1f, 0x9d, 0xe4, 0xe2, 0x5c, 0x8c, 0xc0, 0x3e, 0x18,
	0xce, 0x2d, 0x87, 0x00, 0x39, 0x05, 0xc1, 0x5b, 0xaa, 0xea, 0x3d, 0x2e, 0x1a, 0xa9, 0xdd, 0x36,
	0x90, 0x93, 0xf8, 0xbe, 0xef, 0x7b, 0xfb, 0xf7, 0xbe, 0xbd, 0x04, 0xd9, 0x8e, 0xde, 0xed, 0xe2,
	0x8d, 0xa1, 0xeb, 0xf8, 0x0e, 0x4a, 0xd1, 0x86, 0x7a, 0x0f, 0x32, 0x5b, 0x96, 0x73, 0xd4, 0xec,
	0xeb, 0x43, 0x8c, 0xae, 0x42, 0xc2, 0x30, 0x07, 0x85, 0xd8, 0x5a, 0x62, 0x3d, 0xb1, 0x15, 0x57,
	0x62, 0x1a, 0x69, 0xaa, 0x7f, 0x16, 0x67, 0x34, 0x0d, 0xda, 0x6f, 0x19, 0x12, 0xf6, 0x88, 0xd0,
	0xc4, 0xd6, 0x53, 0x9b, 0xb1, 0xc7, 0x1a, 0x69, 0xa1, 0x3b, 0x90, 0xee, 0xf4, 0x75, 0xdb, 0xc6,
	0x96, 0x57, 0x88, 0x07, 0x98, 0x10, 0x84, 0x6e, 0xc0, 0x5c, 0x1f, 0x9b, 0xbd, 0xbe, 0x5f, 0x48,
	0x04, 0x48, 0x0e, 0x40, 0xd7, 0x21, 0x75, 0x62, 0x1a, 0x7e, 0xbf, 0x90, 0x0c, 0x30, 0xac, 0x8d,
	0x56, 0x20, 0x69, 0xe8, 0xbe, 0x5e, 0x48, 0xad, 0x25, 0xd6, 0xe3, 0x74, 0x31, 0xb4, 0x4d, 0xe1,
	0x66, 0xb7, 0x5b, 0x98, 0x13, 0xe0, 0x66, 0xb7, 0x8b, 0x1e, 0x41, 0xca, 0x23, 0x9b, 0x28, 0xcc,
	0xaf, 0xc5, 0xd6, 0xb3, 0x4f, 0x95, 0x0d, 0xb6, 0xd9, 0x70, 0x73, 0x1a, 0x43, 0xa3, 0xfb, 0x90,
	0x35, 0x9c, 0xd1, 0x91, 0x85, 0xdb, 0x74, 0xf8, 0xf4, 0x5a, 0x62, 0x3d, 0x46, 0x87, 0x01, 0x06,
	0x2e, 0x91, 0x49, 0x04, 0x22, 0x32, 0x57, 0x66, 0x82, 0xc8, 0xec, 0x76, 0xd5, 0x0f, 0x60, 0x31,
	0x3c, 0x96, 0x43, 0xdc, 0xf1, 0x1d, 0x97, 0x2c, 0xe2, 0xc8, 0x72, 0x8e, 0x3c, 0x7a, 0x84, 0xf2,
	0x22, 0x28, 0x99, 0xc6, 0xd0, 0xea, 0xbf, 0xc5, 0x20, 0x55, 0xd2, 0xfd, 0xd1, 0x00, 0xad, 0x09,
	0x27, 0x47, 0xcf, 0x74, 0x2b, 0xf9, 0xdd, 0x1f, 0xdc, 0xbd, 0x22, 0x1c, 0xde, 0xed, 0xf0, 0xf0,
	0xe2, 0x02, 0x3e, 0x38, 0xbf, 0x9b, 0xc1, 0xf9, 0x25, 0x04, 0x24, 0x3f, 0xc2, 0x02, 0x3f, 0x42,
	0x72, 0xb4, 0x0b, 0x1c, 0xc5, 0x0e, 0xf1, 0x26, 0xa4, 0x2c, 0xfd, 0x08, 0x5b, 0x85, 0x94, 0xd8,
	0x8b, 0x82, 0xd0, 0x1d, 0x80, 0xae, 0xe5, 0xe8, 0x3e, 0x3b, 0x1f, 0x7a, 0xcc, 0x5a, 0x86, 0x42,
	0xe8, 0xd1, 0xdc, 0x85, 0x79, 0x6c, 0x77, 0x1c, 0x03, 0x1b, 0xf4, 0xa4, 0xd3, 0x9b, 0xa9, 0xae,
	0x6e, 0x79, 0x58, 0x0b, 0xa0, 0xea, 0x3f, 0xc4, 0x61, 0x71, 0xc7, 0xb4, 0x2c, 0xec, 0x36, 0x74,
	0x57, 0x1f, 0x60, 0x1f, 0xbb, 0xe8, 0x36, 0x24, 0xfd, 0xb3, 0x21, 0xa6, 0x3b, 0xcc, 0x6c, 0xa6,
	0x3b, 0x8e, 0xed, 0xf9, 0xba, 0xed, 0x6b, 0x14, 0x4a, 0x78, 0xe0, 0x58, 0xb7, 0x46, 0x98, 0x6e,
	0x30, 0x4e, 0x79, 0x80, 0xb6, 0x09, 0xaf, 0x0d, 0x4c, 0x9b, 0x6e, 0x8d, 0x82, 0x49, 0x8b, 0x02,
	0xf5, 0x53, 0xba, 0xa9, 0xf8, 0x66, 0xec, 0x89, 0x46, 0x5a, 0xe8, 0x1a, 0x24, 0x07, 0x58, 0xb7,
	0xe9, 0x7e, 0x28, 0x29, 0x6d, 0x12, 0x5a, 0xcf, 0x37, 0x0a, 0x73, 0x21, 0xad, 0xe7, 0x1b, 0xe8,
	0x26, 0xcc, 0x79, 0x43, 0xdd, 0xf5, 0x18, 0xab, 0xa4, 0x36, 0xe3, 0x6f, 0x3d, 0xd1, 0x38, 0x04,
	0x35, 0x20, 0x77, 0xac, 0xbb, 0xa6, 0x6e, 0x77, 0x70, 0xdb, 0x76, 0xdc, 0x41, 0x21, 0xbd, 0x16,
	0x5b, 0xcf, 0x3f, 0xbd, 0xcf, 0x2f, 0x72, 0x6c, 0x5f, 0x1b, 0x87, 0x9c, 0xb6, 0xe6, 0xb8, 0x83,
	0xcd, 0xb9, 0x9d, 0x62, 0xad, 0x5d, 0xa9, 0x69, 0x0b, 0xc7, 0x02, 0x54, 0x7d, 0x07, 0x16, 0x44,
	0x2a, 0x04, 0xc0, 0xe9, 0x94, 0x2b, 0x28, 0x0b, 0xf3, 0xe4, 0x77, 0xfd, 0xa0, 0xa5, 0xc4, 0x48,
	0xa3, 0x78, 0x58, 0xd6, 0x8a, 0xbb, 0x65, 0x25, 0xae, 0xfe, 0x38, 0x0e, 0x0b, 0x35, 0xec, 0x47,
	0x27, 0x58, 0x80, 0xa4, 0xad, 0x0f, 0xf8, 0x09, 0x06, 0x77, 0x49, 0x20, 0xe8, 0xff, 0xc1, 0x9c,
	0xa5, 0x9f, 0x61, 0x97, 0xbc, 0x3c, 0xc2, 0x74, 0xd7, 0xf9, 0x5a, 0x0f, 0x9f, 0x54, 0x09, 0x38,
	0x1c, 0x42, 0xe3, 0x64, 0xe8, 0x2a, 0xa4, 0x4c, 0x7b, 0x38, 0x22, 0x8f, 0x31, 0xb1, 0x9e, 0xd1,
	0x58, 0x03, 0xdd, 0x82, 0x0c, 0xfd, 0xd1, 0x26, 0x12, 0x20, 0xb9, 0x96, 0x58, 0x4f, 0x69, 0x69,
	0x0a, 0x28, 0x99, 0x03, 0xf4, 0x26, 0xe4, 0xbb, 0x8e, 0xdb, 0xc1, 0xed, 0x23, 0xbd, 0xf3, 0xe2,
	0x44, 0x77, 0x0d, 0x7a, 0xd0, 0xe1, 0xdd, 0xe7, 0x28, 0x72, 0x8b, 0xe3, 0xd0, 0x43, 0x48, 0x79,
	0xbe, 0xee, 0x63, 0x7a, 0xee, 0xd9, 0xa7, 0x8b, 0x7c, 0x41, 0x35, 0xec, 0x37, 0x09, 0x58, 0x63,
	0x58, 0xf4, 0x00, 0xc0, 0xc0, 0x47, 0xa3, 0x5e, 0xdb, 0xb4, 0xbb, 0x8e, 0xcc, 0x4c, 0x19, 0x8a,
	0xa8, 0xd8, 0x5d, 0x07, 0x3d, 0x81, 0x2c, 0x5b, 0x17, 0x7b, 0xdd, 0xe9, 0x89, 0x87, 0xc5, 0x5e,
	0x37, 0x50, 0x22, 0x26, 0xc6, 0xde, 0x20, 0xdc, 0x7d, 0x86, 0xdd, 0x82, 0x41, 0x89, 0xaf, 0x71,
	0xe2, 0xb1, 0xe3, 0x60, 0x34, 0xea, 0xdf, 0xe5, 0x61, 0xb1, 0xe9, 0x58, 0xc7, 0x22, 0xbb, 0xde,
	0x83, 0x8c, 0xef, 0xea, 0xa6, 0xdd, 0xb6, 0xb1, 0x2f, 0x9d, 0x78, 0x9a, 0x82, 0x6b, 0xd8, 0x47,
	0x37, 0x20, 0xed, 0x63, 0xcf, 0xa7, 0x14, 0x71, 0x7a, 0x8e, 0xf3, 0xa4, 0x4d, 0x50, 0xb7, 0x20,
	0x43, 0x51, 0xa6, 0x8f, 0x5d, 0x7a, 0xc6, 0x29, 0x8d, 0xd2, 0x56, 0xc8, 0xd0, 0x8f, 0x20, 0xc7,
	0x90, 0xb6, 0x8f, 0xdd, 0x63, 0xdd, 0x8a, 0xe4, 0xde, 0x02, 0xa5, 0xe1, 0x60, 0x74, 0x07, 0xe6,
	0x8f, 0x74, 0x0f, 0xb7, 0x2d, 0x97, 0xf1, 0x74, 0xf0, 0xec, 0x09, 0xb0, 0xea, 0xa2, 0x55, 0x98,
	0x37, 0x4c, 0x6f, 0x68, 0xe9, 0x67, 0xf4, 0x90, 0x83, 0x27, 0x1c, 0x00, 0xd1, 0x5d, 0x48, 0x0f,
	0xf4, 0x53, 0xb6, 0x84, 0x79, 0x91, 0x60, 0xa0, 0x9f, 0x56, 0xf8, 0x16, 0x2d, 0xb7, 0x3d, 0x74,
	0x2c, 0xb3, 0x73, 0x46, 0x99, 0x3c, 0xdc, 0xa2, 0xe5, 0x36, 0x28, 0x94, 0x08, 0x89, 0x9e, 0x3e,
	0x18, 0xe8, 0x85, 0x8c, 0xb0, 0x00, 0x06, 0x22, 0xb8, 0xa1, 0x73, 0x82, 0xdd, 0x02, 0x88, 0x38,
	0x0a, 0x22, 0x22, 0x6d, 0xe0, 0x0c, 0xb0, 0xed, 0x8f, 0x06, 0x85, 0xac, 0x80, 0x0e, 0xa1, 0xe8,
	0x35, 0x58, 0x38, 0xa1, 0xe2, 0xab, 0x6d, 0xe0, 0x8e, 0x7e, 0x56, 0x58, 0x10, 0xa8, 0xb2, 0x0c,
	0x53, 0x22, 0x08, 0x32, 0x94, 0xe7, 0xe3, 0xa1, 0x67, 0x7e, 0x8a, 0x0b, 0x39, 0x51, 0x3a, 0x06,
	0x50, 0xa2, 0x79, 0x3c, 0x5b, 0x1f, 0x7a, 0x7d, 0xc7, 0x2f, 0xe4, 0x43, 0xcd, 0x13, 0x80, 0xd0,
	0x5b, 0xb0, 0x18, 0xfc, 0x6e, 0x0f, 0x5d, 0xdc, 0x35, 0x4f, 0x0b, 0x8b, 0xc2, 0x66, 0xf3, 0x01,
	0xb2, 0x41, 0x71, 0xe8, 0x75, 0xc8, 0x85, 0xe4, 0x54, 0xf2, 0x2b, 0x22, 0x57, 0x2e, 0x04, 0x38,
	0x22, 0xfe, 0xd1, 0x2e, 0x64, 0x3d, 0xca, 0x37, 0xed, 0x81, 0x63, 0xe0, 0xc2, 0x12, 0x15, 0x14,
	0xf7, 0x38, 0xaf, 0x8d, 0x71, 0x14, 0x6f, 0xef, 0x3b, 0x06, 0xde, 0x4c, 0xec, 0x36, 0x0e, 0x34,
	0xf0, 0x42, 0x00, 0x5a, 0x85, 0x8c, 0x81, 0x8f, 0xcd, 0x0e, 0x6e, 0x9b, 0x46, 0x01, 0x85, 0x7b,
	0x60, 0xb0, 0x8a, 0x81, 0x9e, 0xc0, 0x12, 0x65, 0x99, 0x8e, 0x33, 0x18, 0x8e, 0x7c, 0xdc, 0xb6,
	0x1c, 0xcf, 0x2b, 0x2c, 0x8b, 0x0b, 0x5b, 0x24, 0xf8, 0x6d, 0x86, 0xae, 0x3a, 0x9e, 0x47, 0xf4,
	0x97, 0xab, 0xdb, 0x86, 0x33, 0x68, 0x7b, 0x18, 0x1b, 0x85, 0xab, 0x6b, 0xb1, 0xf5, 0x04, 0x95,
	0x73, 0xc0, 0xc0, 0x4d, 0x8c, 0x0d, 0xf4, 0x21, 0x2c, 0x86, 0x5c, 0xde, 0x1e, 0x92, 0xa5, 0x16,
	0xae, 0xd1, 0x07, 0xbb, 0x1c, 0x3d, 0xd8, 0xe8, 0xb9, 0xe4, 0x02, 0xd6, 0xa7, 0x20, 0xf4, 0x01,
	0xe4, 0x03, 0xfe, 0xe7, 0x7d, 0x57, 0xe8, 0x63, 0x9b, 0xda, 0x77, 0x81, 0x3f, 0x0d, 0xd6, 0x55,
	0x7e, 0xf7, 0xd7, 0x67, 0xbc, 0xfb, 0x15, 0x48, 0x90, 0xb7, 0x55, 0x10, 0x6e, 0x8b, 0x00, 0xd0,
	0x63, 0xc8, 0x44, 0x73, 0xde, 0x98, 0xbd, 0xde, 0xb4, 0x1d, 0xcc, 0xf7, 0x18, 0xb2, 0x6c, 0x9f,
	0x4c, 0x28, 0xdd, 0x9c, 0x2e, 0x94, 0x80, 0xd2, 0xd0, 0xdf, 0x68, 0x03, 0x80, 0x6e, 0x8e, 0x75,
	0xb8, 0x45, 0x37, 0x36, 0xd1, 0x81, 0x3e, 0x72, 0x46, 0xff, 0x2e, 0x5c, 0x0d, 0xd9, 0x46, 0xef,
	0xfa, 0xd8, 0x6d, 0xd3, 0xc1, 0x0a, 0xb7, 0xe9, 0xde, 0x92, 0xbe, 0x3b, 0xc2, 0x1a, 0x0a, 0x28,
	0x8a, 0x84, 0xa0, 0x45, 0xf0, 0xe8, 0x6d, 0x58, 0x76, 0x71, 0x6f, 0x64, 0xe9, 0xae, 0xf9, 0xa9,
	0xee, 0x9b, 0x8e, 0xdd, 0xa6, 0x5a, 0xf2, 0x0e, 0xd5, 0x92, 0xf1, 0xea, 0x53, 0x0d, 0xc9, 0xe8,
	0x16, 0xd1, 0x96, 0x11, 0xdf, 0x51, 0xe2, 0xd5, 0x0b, 0xf0, 0x1d, 0xe9, 0xb7, 0x99, 0x68, 0xee,
	0x96, 0x02, 0xbe, 0xa3, 0x03, 0xdd, 0x82, 0x94, 0x81, 0x2d, 0x5f, 0x2f, 0xdc, 0xa5, 0xea, 0x31,
	0xf5, 0x04, 0xbf, 0xf5, 0xf8, 0x7d, 0x8d, 0xc1, 0xd0, 0x33, 0x58, 0xe6, 0x72, 0xca, 0xf4, 0x4d,
	0xdd, 0xe2, 0x0b, 0x28, 0xac, 0x89, 0x3b, 0x62, 0x02, 0x4b, 0xc4, 0xa3, 0x07, 0xb0, 0xa0, 0x1f,
	0x63, 0x57, 0xef, 0x71, 0x36, 0xbd, 0xc7, 0xd8, 0xf9, 0x89, 0x96, 0xe5, 0x60, 0xca, 0x9e, 0xb7,
	0x21, 0x43, 0x1e, 0x30, 0x53, 0xfa, 0x2a, 0x95, 0x90, 0x11, 0x00, 0x7d, 0x0e, 0xf2, 0x1d, 0xcb,
	0x1c, 0xb6, 0x7b, 0xae, 0x6e, 0x98, 0xd8, 0xf6, 0xbd, 0xc2, 0x7d, 0xba, 0x40, 0xc2, 0xbf, 0x39,
	0x82, 0xd9, 0x0d, 0x10, 0xe4, 0xe9, 0x10, 0x11, 0xd7, 0xa6, 0x02, 0xe2, 0x41, 0x30, 0x57, 0x9a,
	0xc0, 0x9a, 0x44, 0x3a, 0x7c, 0x59, 0x78, 0xfe, 0x5d, 0xc7, 0x1d, 0xe8, 0x7e, 0xe1, 0x21, 0x3d,
	0xaf, 0x87, 0xb3, 0xce, 0x8b, 0x53, 0xef, 0x50, 0xe2, 0xcd, 0xec, 0x56, 0xa5, 0x56, 0xd4, 0x3e,
	0x69, 0x68, 0xf5, 0x56, 0x3d, 0x12, 0x16, 0x0c, 0x49, 0x44, 0xa8, 0x3b, 0xf0, 0xb8, 0x08, 0x7b,
	0x24, 0x0a, 0x3a, 0x77, 0xe0, 0x31, 0xf9, 0x75, 0x1f, 0x32, 0x81, 0xd0, 0x7b, 0x5a, 0x78, 0x8d,
	0x1d, 0xf3, 0xe3, 0x8d, 0x0f, 0x3e, 0xf8, 0x40, 0x8b, 0xe0, 0xe8, 0x3a, 0x37, 0x8e, 0xd6, 0xe9,
	0xb5, 0xd3, 0x6b, 0xa2, 0x00, 0xf5, 0x0d, 0xc8, 0xcb, 0xeb, 0x41, 0x69, 0x48, 0xee, 0x95, 0x76,
	0x9e, 0x29, 0x57, 0xd0, 0x22, 0x88, 0x6b, 0x53, 0x62, 0xea, 0x2a, 0x40, 0x24, 0x64, 0xd0, 0x3c,
	0x24, 0xb6, 0x1b, 0x07, 0xca, 0x15, 0xf2, 0x63, 0xb7, 0x71, 0xa0, 0xc4, 0xd4, 0x83, 0x00, 0x4f,
	0xef, 0x7e, 0x1e, 0xc8, 0x3c, 0xca, 0x15, 0xb4, 0x00, 0xe9, 0x5a, 0xb9, 0xd9, 0x2a, 0x6b, 0xf5,
	0x43, 0x6e, 0x83, 0x94, 0x8a, 0xbb, 0x5a, 0xb1, 0xa4, 0xc4, 0x49, 0x43, 0xdb, 0x6f, 0x36, 0xb4,
	0x7a, 0x43, 0x49, 0x10, 0xba, 0x62, 0xa9, 0x58, 0x2a, 0x57, 0x5b, 0x45, 0x25, 0x49, 0xd6, 0x51,
	0x2c, 0x15, 0xf7, 0x95, 0x94, 0xfa, 0x97, 0x31, 0xc8, 0xb2, 0x71, 0xd9, 0x53, 0x28, 0x40, 0x92,
	0x2a, 0x1d, 0xd1, 0x96, 0xa5, 0x10, 0xf4, 0x10, 0xb2, 0x16, 0xd6, 0x5d, 0x1b, 0x1b, 0x5c, 0x69,
	0x46, 0x0f, 0x1b, 0x38, 0x82, 0x68, 0xcf, 0xd7, 0x61, 0xbe, 0x6f, 0x7a, 0xbe, 0xe3, 0x9e, 0x51,
	0xdd, 0x39, 0xcd, 0x88, 0x0e, 0x08, 0x08, 0xb7, 0x75, 0x46, 0xae, 0x8b, 0x6d, 0xf2, 0x54, 0xf1,
	0x30, 0xd2, 0xa5, 0x59, 0x0e, 0x6e, 0xfa, 0x78, 0xa8, 0x76, 0x20, 0x1d, 0x3c, 0x5a, 0xb4, 0x0e,
	0xa9, 0x61, 0x5f, 0xf7, 0x98, 0x1d, 0x95, 0x7f, 0xba, 0xc0, 0xc7, 0x6e, 0x10, 0xd8, 0x66, 0xb2,
	0x55, 0x6e, 0xb6, 0x34, 0x46, 0x40, 0x8c, 0x52, 0x0b, 0x1f, 0x63, 0x2b, 0xf2, 0x67, 0x58, 0x9b,
	0x98, 0x4f, 0x9e, 0xaf, 0xf7, 0x70, 0x60, 0x3e, 0xd1, 0x86, 0xfa, 0xb7, 0x31, 0x6a, 0xb0, 0x31,
	0xd1, 0x30, 0xb2, 0xce, 0x9f, 0x29, 0xd4, 0x97, 0x74, 0xa6, 0x7b, 0x90, 0x19, 0x98, 0x76, 0x5b,
	0x98, 0x2d, 0x54, 0x98, 0xa6, 0x5d, 0xa5, 0x73, 0x12, 0x12, 0xfd, 0x94, 0x93, 0x24, 0x24, 0x12,
	0xfd, 0xb4, 0x2a, 0x2f, 0x2b, 0x29, 0x2c, 0x8b, 0xd8, 0x22, 0xb6, 0x43, 0x05, 0x59, 0x0f, 0x53,
	0x57, 0x2a, 0xa3, 0xa5, 0x6d, 0x87, 0x2c, 0xb3, 0x87, 0xd5, 0x7f, 0x8d, 0x41, 0x86, 0xb2, 0x7e,
	0x73, 0x88, 0x3b, 0xe7, 0x58, 0x98, 0x5b, 0x00, 0x5e, 0x5f, 0x77, 0x31, 0x53, 0x74, 0x71, 0xba,
	0x9f, 0x3b, 0xc1, 0x7e, 0x82, 0xfe, 0x1b, 0x25, 0x73, 0xb0, 0xdd, 0xc7, 0x9d, 0x17, 0x84, 0xff,
	0x78, 0xf7, 0x0c, 0xed, 0x46, 0x19, 0xf2, 0x26, 0xcc, 0x5b, 0x6e, 0x7b, 0x30, 0xb2, 0xfc, 0xc0,
	0x9c, 0x7f, 0xa2, 0xcd, 0x59, 0xee, 0xfe, 0xc8, 0xf2, 0xd1, 0x1a, 0x51, 0x08, 0x1d, 0xfd, 0x8c,
	0xa1, 0x43, 0xc3, 0x3e, 0x43, 0x81, 0x84, 0x42, 0x7d, 0x1d, 0x16, 0xc4, 0xe1, 0x89, 0x11, 0xdd,
	0x6c, 0x69, 0x95, 0xed, 0x96, 0x72, 0x05, 0xe5, 0x01, 0x1a, 0x65, 0x6d, 0xbf, 0xd2, 0x6c, 0x56,
	0x0e, 0xcb, 0x4a, 0x4c, 0xfd, 0xef, 0x1b, 0x90, 0x97, 0x4d, 0xbd, 0x73, 0xb6, 0x56, 0xe0, 0x6f,
	0x4f, 0xe4, 0x46, 0xe6, 0x94, 0xac, 0xc0, 0xdc, 0x91, 0xe3, 0xfb, 0xce, 0x80, 0xdf, 0x33, 0x6f,
	0x21, 0x05, 0x12, 0xbe, 0x33, 0xe4, 0xa7, 0x4c, 0x7e, 0xa2, 0xbb, 0x90, 0x25, 0xb2, 0xae, 0xcd,
	0x0c, 0x17, 0xe6, 0xb0, 0x6a, 0x40, 0x40, 0xcf, 0x99, 0x8f, 0xf6, 0x08, 0x52, 0x4c, 0x5d, 0xcd,
	0x49, 0x0c, 0x1d, 0x1e, 0x9d, 0xc6, 0xd0, 0x91, 0xf7, 0x38, 0x7f, 0xae, 0xf7, 0x88, 0xde, 0x82,
	0x79, 0xd3, 0xee, 0x58, 0x23, 0x23, 0x30, 0x87, 0x97, 0xc7, 0x75, 0xd3, 0xc8, 0xc2, 0x5a, 0x40,
	0x43, 0xc8, 0xf1, 0x29, 0x23, 0xcf, 0x9c, 0x43, 0xce, 0x69, 0x22, 0xc6, 0x85, 0xcf, 0x62, 0xdc,
	0x87, 0x90, 0x1f, 0xba, 0xce, 0x50, 0xef, 0xe9, 0x3e, 0x6e, 0x1b, 0xce, 0x89, 0x5d, 0xc8, 0xae,
	0x25, 0xd6, 0xd3, 0x5a, 0x2e, 0x84, 0x96, 0x9c, 0x13, 0x1b, 0xed, 0x52, 0x3b, 0xc3, 0xf6, 0x88,
	0x00, 0xe6, 0x7a, 0xdb, 0xa0, 0x3a, 0x78, 0x95, 0x0f, 0xdd, 0x0a, 0xb0, 0x54, 0x87, 0x44, 0x2a,
	0x3c, 0x1f, 0x76, 0x63, 0x8a, 0xfc, 0x6d, 0xa0, 0xa7, 0xca, 0xc7, 0xc0, 0x74, 0x8c, 0xab, 0x81,
	0x71, 0xef, 0x78, 0x5e, 0xd4, 0x33, 0x63, 0x05, 0x4d, 0xf4, 0x45, 0xc8, 0xeb, 0x9d, 0xce, 0xc8,
	0xd5, 0x3b, 0x67, 0xbc, 0x63, 0x97, 0x76, 0x2c, 0xf0, 0x8e, 0x45, 0x8e, 0x14, 0x2c, 0x1d, 0x5d,
	0x04, 0xa1, 0x0f, 0x60, 0x41, 0x77, 0x7b, 0xe4, 0xf9, 0xb1, 0xee, 0x3d, 0xda, 0x7d, 0x25, 0xe8,
	0xee, 0xf6, 0xf6, 0xf5, 0xd3, 0xa8, 0x73, 0x96, 0xd1, 0x86, 0x5d, 0x3b, 0x8e, 0xdd, 0xd1, 0x03,
	0x73, 0xa5, 0x2f, 0x75, 0xdd, 0xa6, 0x28, 0xa1, 0x6b, 0x27, 0x02, 0xa0, 0x03, 0x58, 0xe9, 0x38,
	0xb6, 0xef, 0xea, 0x9e, 0x6f, 0x1e, 0x33, 0x65, 0xca, 0x07, 0x31, 0xe9, 0x20, 0x77, 0xa3, 0x41,
	0x02, 0x22, 0xf9, 0x08, 0xae, 0x76, 0xa6, 0x60, 0xd0, 0x1e, 0x2c, 0x75, 0x1c, 0xfb, 0xd8, 0xb1,
	0x46, 0xd4, 0xdc, 0x60, 0x23, 0x7e, 0x85, 0x8e, 0x78, 0x2b, 0x1a, 0x31, 0xc0, 0x47, 0xa3, 0x29,
	0x9d, 0x31, 0x28, 0xb9, 0x0c, 0x43, 0xf7, 0x75, 0x3e, 0xc4, 0x0b, 0xe9, 0x32, 0x4a, 0xba, 0xaf,
	0x0b, 0x97, 0x61, 0x04, 0x4d, 0xf4, 0x11, 0xe4, 0x0c, 0xd7, 0x19, 0x3a, 0xa3, 0xe0, 0x44, 0x2c,
	0xda, 0x2f, 0x70, 0x59, 0x4b, 0x0c, 0x27, 0x18, 0x8e, 0x86, 0x00, 0x41, 0xdb, 0xa0, 0x18, 0xa3,
	0xc1, 0xe0, 0xac, 0x2d, 0x4c, 0x3c, 0xa0, 0x03, 0xdc, 0x08, 0x06, 0x20, 0x68, 0x79, 0xf6, 0xbc,
	0x21, 0xc1, 0xc8, 0x12, 0xb0, 0xe5, 0x9f, 0x98, 0x1e, 0xe6, 0x23, 0xd8, 0xd2, 0x12, 0xca, 0x0c,
	0x27, 0x2c, 0x01, 0x0b, 0x10, 0x62, 0x7d, 0xe2, 0xd3, 0x21, 0xef, 0xe9, 0x48, 0xd6, 0x67, 0xf9,
	0x74, 0x28, 0x58, 0x9f, 0x98, 0xb7, 0xd0, 0x97, 0x60, 0xb1, 0x6f, 0x74, 0x9f, 0x89, 0x6b, 0x1e,
	0x4a, 0x0c, 0x48, 0x14, 0xba, 0xbc, 0xe4, 0x1c, 0xe9, 0x10, 0xad, 0x78, 0x07, 0x96, 0xe8, 0x08,
	0xce, 0xc8, 0x1f, 0x86, 0x07, 0xf7, 0xcb, 0x74, 0x8c, 0x9b, 0xc2, 0x18, 0x75, 0x8a, 0x8e, 0x46,
	0xa1, 0xd3, 0x0a, 0x40, 0x72, 0x7c, 0x7d, 0xd3, 0xee, 0x49, 0xcc, 0xe4, 0x4a, 0xc7, 0xb7, 0x47,
	0xd0, 0x32, 0x1b, 0xe5, 0xfb, 0x12, 0x8c, 0x0c, 0x62, 0x0e, 0x88, 0x79, 0x27, 0xec, 0xc7, 0x93,
	0x06, 0xa9, 0x10, 0xf4, 0xd8, 0x1d, 0x98, 0x12, 0x0c, 0x55, 0x61, 0x99, 0xd8, 0xfe, 0x3d, 0x62,
	0x94, 0x0b, 0x8b, 0xf1, 0xe9, 0x38, 0xb7, 0x83, 0x71, 0x38, 0x85, 0xbc, 0x9e, 0x25, 0x73, 0x1c,
	0xcc, 0x46, 0xb3, 0xb1, 0xdb, 0x1e, 0xba, 0x8e, 0x31, 0xea, 0x04, 0x27, 0x34, 0x1a, 0x1b, 0xcd,
	0xc6, 0x6e, 0x83, 0x11, 0x48, 0xa3, 0x8d, 0x81, 0xc9, 0x0d, 0x5b, 0x6e, 0xf0, 0x32, 0x8e, 0xa5,
	0x1b, 0xae, 0x6a, 0x35, 0xe1, 0x86, 0x2d, 0xd7, 0x0e, 0xef, 0x67, 0x80, 0x07, 0x8e, 0x2b, 0xf1,
	0xe5, 0x89, 0x74, 0x3f, 0xfb, 0x14, 0x2f, 0x1f, 0xca, 0xe2, 0x40, 0x06, 0x92, 0x99, 0x07, 0xc7,
	0xc1, 0xcc, 0xa7, 0xd2, 0xcc, 0xfb, 0x87, 0xe2, 0xcc, 0x83, 0x63, 0x3b, 0xe4, 0xe5, 0xa1, 0xe3,
	0x58, 0xa6, 0xdd, 0xe3, 0xbd, 0xce, 0x24, 0x5e, 0x6e, 0x30, 0x9c, 0xc0, 0xcb, 0x43, 0x01, 0x82,
	0xde, 0x85, 0x2c, 0x75, 0xd8, 0x79, 0xdf, 0x4f, 0x69, 0xdf, 0x6b, 0x61, 0xdf, 0x13, 0x31, 0x58,
	0x02, 0xc3, 0xb0, 0x4d, 0x5e, 0xbe, 0x8b, 0xad, 0x11, 0xef, 0xf6, 0x2b, 0xd2, 0xcb, 0xd7, 0x70,
	0xf5, 0x40, 0x78, 0xf9, 0x84, 0x2e, 0x5c, 0xaa, 0x67, 0xf6, 0x06, 0x8e, 0x69, 0xf0, 0x7e, 0xbf,
	0x2a, 0x2d, 0xb5, 0xc9, 0x70, 0xc2, 0x52, 0x3d, 0x01, 0x42, 0x7b, 0x3b, 0x5d, 0x3f, 0x12, 0xc2,
	0xbf, 0x26, 0xf7, 0x66, 0x38, 0xb1, 0xb7, 0x00, 0x21, 0x1b, 0xf5, 0x2c, 0xe2, 0x5f, 0xb3, 0xbe,
	0xbf, 0x2e, 0x6d, 0xb4, 0x49, 0x30, 0xc2, 0x46, 0xbd, 0xb0, 0x4d, 0x36, 0xea, 0xeb, 0x76, 0x9f,
	0x77, 0xfb, 0x0d, 0x69, 0xa3, 0x2d, 0xdd, 0xde, 0x13, 0x36, 0x4a, 0xe8, 0x82, 0x07, 0xb2, 0xe8,
	0xf7, 0x5d, 0xec, 0xf5, 0x1d, 0x2b, 0xd8, 0xea, 0x57, 0x63, 0xd2, 0x03, 0x69, 0x05, 0x68, 0x51,
	0xd3, 0x49, 0x30, 0xb4, 0x0b, 0x4b, 0x27, 0xa6, 0x6d, 0x38, 0x27, 0x22, 0x4b, 0x7d, 0x2d, 0x26,
	0xf1, 0xd4, 0x73, 0x4a, 0x30, 0xc6, 0x53, 0x27, 0x32, 0x10, 0x6d, 0xc2, 0xc2, 0xf0, 0xcc, 0xef,
	0x87, 0xa2, 0xfe, 0x37, 0x63, 0x92, 0x0a, 0x6a, 0x50, 0x9c, 0xa0, 0x82, 0x86, 0x11, 0x00, 0xbd,
	0x07, 0xd9, 0xa1, 0x70, 0xd1, 0xbf, 0x15, 0x93, 0x19, 0x44, 0xbe, 0x6a, 0x18, 0x46, 0x77, 0xfd,
	0x04, 0x32, 0xde, 0x30, 0x10, 0x92, 0xbf, 0x1d, 0x93, 0x38, 0xb9, 0xd9, 0x68, 0x08, 0x9c, 0xec,
	0x0d, 0xb9, 0x94, 0xfc, 0x3c, 0xe4, 0xc8, 0x01, 0xe8, 0xc3, 0xe0, 0x92, 0x7e, 0x27, 0x26, 0xdd,
	0xb0, 0xc6, 0x90, 0xc2, 0x0d, 0xbb, 0x02, 0x84, 0xcc, 0x68, 0x39, 0xc1, 0x23, 0xf8, 0x5d, 0x79,
	0xc6, 0xaa, 0xd3, 0x13, 0x5f, 0x2d, 0x6f, 0x91, 0x19, 0xbb, 0x96, 0xee, 0xfb, 0x38, 0x38, 0x9a,
	0xdf, 0x93, 0x67, 0xdc, 0x61, 0x48, 0x61, 0xc6, 0xae, 0x00, 0x21, 0xd7, 0xec, 0x62, 0x22, 0x35,
	0x22, 0x35, 0xfa, 0xfb, 0xf2, 0x35, 0x6b, 0x01, 0x5a, 0xb8, 0x66, 0x57, 0x82, 0x91, 0x13, 0xc6,
	0x83, 0x23, 0x1c, 0xf0, 0xc9, 0x1f, 0xc8, 0x27, 0x5c, 0x26, 0x28, 0xe1, 0x84, 0x71, 0xd8, 0x46,
	0xef, 0x00, 0xf8, 0xa6, 0x15, 0x9c, 0xd5, 0x1f, 0xc6, 0x64, 0xd6, 0x34, 0x2d, 0x2c, 0xb2, 0x66,
	0xd0, 0x44, 0x25, 0x50, 0x8e, 0x74, 0xbf, 0xd3, 0xa7, 0x91, 0x6d, 0xde, 0xf7, 0x8f, 0xe4, 0x45,
	0x6f, 0x11, 0x7c, 0x2d, 0xb0, 0xb8, 0xd8, 0xa2, 0x8f, 0x24, 0x18, 0x39, 0xeb, 0x88, 0x29, 0xbe,
	0x2e, 0x9f, 0x75, 0x59, 0x64, 0x89, 0x74, 0xc8, 0x10, 0xef, 0x00, 0x1c, 0x99, 0x7a, 0x20, 0xe6,
	0xff, 0x58, 0x5e, 0xee, 0x96, 0xa9, 0x8b, 0x96, 0xdb, 0x51, 0xd0, 0x24, 0xa7, 0xe3, 0x75, 0xf4,
	0x70, 0x97, 0xdf, 0x90, 0x4f, 0xa7, 0x49, 0x50, 0xe2, 0xbb, 0x0d, 0xdb, 0xa4, 0x23, 0x0b, 0x19,
	0xb3, 0x8e, 0x7f, 0x22, 0x77, 0xac, 0xd8, 0x92, 0x9a, 0x64, 0x81, 0xe3, 0x70, 0x9d, 0x1d, 0xd7,
	0x09, 0x38, 0xf7, 0x9b, 0xf2, 0x3a, 0xb7, 0x5d, 0x47, 0x50, 0xf0, 0x99, 0x4e, 0xd0, 0x24, 0xac,
	0x30, 0x0c, 0xe0, 0xbc, 0xeb, 0xb7, 0xe4, 0x53, 0x0d, 0xbb, 0x09, 0xa7, 0x3a, 0x94, 0x60, 0x8c,
	0x9f, 0x02, 0x67, 0x96, 0x0d, 0xf2, 0xa7, 0xe3, 0xfc, 0xc4, 0xd1, 0x12, 0x3f, 0x89, 0x30, 0xf5,
	0x6b, 0x71, 0xb8, 0x3e, 0xc3, 0x98, 0x26, 0xfe, 0x2c, 0x3d, 0x22, 0xea, 0x04, 0x51, 0xff, 0x8a,
	0xb5, 0xd1, 0x1d, 0x98, 0x1b, 0x98, 0xae, 0xeb, 0xb8, 0xd4, 0x09, 0x0a, 0x43, 0x71, 0x1c, 0x88,
	0x56, 0x81, 0x6e, 0x95, 0x85, 0x58, 0x88, 0xeb, 0x96, 0x63, 0xb9, 0x3d, 0xd7, 0x19, 0xd2, 0x10,
	0x0b, 0x71, 0x4d, 0xb1, 0x6e, 0xb7, 0xbb, 0xa6, 0x85, 0xa9, 0xef, 0x16, 0x06, 0x92, 0x09, 0x78,
	0xc7, 0xa4, 0x33, 0x00, 0x25, 0x61, 0xf1, 0x1e, 0xe6, 0x1f, 0xd1, 0x4e, 0x87, 0x34, 0xde, 0xf3,
	0x08, 0xb2, 0x2c, 0xb9, 0xd0, 0x71, 0x2c, 0xc7, 0xa5, 0xf1, 0xec, 0x70, 0x15, 0x40, 0x31, 0xdb,
	0x04, 0x81, 0x1e, 0x00, 0x6b, 0xb5, 0x7b, 0xae, 0x7e, 0x36, 0x96, 0x2f, 0xa0, 0x88, 0x5d, 0x57,
	0x3f, 0x53, 0xff, 0x2b, 0x06, 0x39, 0xc9, 0x64, 0x40, 0xaf, 0xc1, 0x82, 0xd9, 0xb3, 0x1d, 0x17,
	0xb7, 0x59, 0xce, 0x4b, 0x0c, 0x4d, 0x64, 0x19, 0xa6, 0x4a, 0x33, 0x5f, 0x2a, 0x71, 0x96, 0xdd,
	0x81, 0x6e, 0x91, 0xad, 0xd2, 0xc3, 0x08, 0xfc, 0xd8, 0x10, 0x8c, 0x9a, 0x90, 0x0b, 0x1a, 0x2c,
	0x22, 0x96, 0xa0, 0x5e, 0xd2, 0xa3, 0x69, 0x6e, 0xc8, 0x46, 0x4d, 0xa4, 0xa4, 0xc1, 0xdf, 0xd4,
	0x61, 0xb1, 0x5a, 0x29, 0x69, 0xf2, 0x18, 0xea, 0x16, 0x2c, 0x4d, 0x90, 0xa2, 0x34, 0x24, 0x77,
	0x0e, 0xaa, 0x55, 0xe5, 0x0a, 0xca, 0x00, 0xeb, 0xa6, 0xc4, 0x88, 0xb3, 0xbb, 0x55, 0x6c, 0x6d,
	0xef, 0xb5, 0x9b, 0x95, 0x5f, 0x2a, 0x2b, 0x71, 0x42, 0x54, 0xab, 0xd7, 0xca, 0x4a, 0x42, 0x7d,
	0x01, 0x4b, 0x13, 0xae, 0x0c, 0x5a, 0x81, 0x94, 0xef, 0x0c, 0xdb, 0x2f, 0xe8, 0x9e, 0x73, 0xe4,
	0xd2, 0x93, 0xbe, 0x33, 0xfc, 0x05, 0x74, 0x0d, 0x92, 0xfa, 0xa9, 0x19, 0xe6, 0x6a, 0x9f, 0x68,
	0xb4, 0x39, 0x71, 0x52, 0x89, 0x19, 0x27, 0xa5, 0x7e, 0x05, 0x16, 0xc7, 0x1c, 0x1f, 0xf4, 0x10,
	0xb2, 0xc4, 0xac, 0x27, 0x2a, 0xfa, 0x58, 0x67, 0x87, 0x1c, 0x5d, 0x8f, 0x33, 0xf2, 0xf7, 0xf5,
	0xd3, 0x43, 0xdd, 0x8a, 0x56, 0x14, 0x97, 0x57, 0x54, 0xe0, 0x2b, 0x12, 0xa7, 0xa4, 0x10, 0xf5,
	0xff, 0xc3, 0xe2, 0x98, 0xa7, 0x84, 0xd6, 0x00, 0xb8, 0x5f, 0xc5, 0xd2, 0xd5, 0x7c, 0xa4, 0x0c,
	0x03, 0x96, 0xcc, 0xc1, 0x8c, 0x0d, 0xaa, 0xdf, 0x89, 0x01, 0x9a, 0x14, 0x71, 0x68, 0x03, 0x94,
	0x91, 0x87, 0xdb, 0x3d, 0xcb, 0x39, 0xd2, 0x2d, 0x1a, 0xf5, 0x65, 0xc9, 0xd8, 0xe0, 0xfe, 0xf3,
	0x23, 0x0f, 0xef, 0x52, 0x24, 0xf1, 0x97, 0x3d, 0xf4, 0x79, 0xb8, 0x3e, 0x70, 0x8e, 0x89, 0xd9,
	0x15, 0x04, 0x3b, 0xbb, 0xae, 0x4e, 0xe5, 0x3a, 0x4f, 0x61, 0xf2, 0x20, 0xdf, 0x35, 0x46, 0x55,
	0x64, 0x44, 0x3b, 0x9c, 0x06, 0x5d, 0x87, 0x04, 0x1e, 0x7a, 0x3c, 0x0e, 0x42, 0xc3, 0xae, 0xcf,
	0x34, 0x02, 0x51, 0x7d, 0xc8, 0x49, 0xd2, 0x30, 0xdc, 0x46, 0x4c, 0xbe, 0xa7, 0xdb, 0x90, 0xb6,
	0x47, 0x83, 0xb6, 0x7e, 0x8a, 0x85, 0x1d, 0xce, 0xdb, 0xa3, 0x41, 0xf1, 0x14, 0x7b, 0x68, 0x03,
	0xe6, 0xba, 0x34, 0x4f, 0x49, 0x67, 0x88, 0x94, 0xfd, 0x58, 0xf2, 0x52, 0xe3, 0x54, 0x6a, 0x07,
	0x0a, 0xb3, 0xbc, 0x48, 0x74, 0x03, 0xe6, 0x06, 0xba, 0xdb, 0x33, 0xed, 0x48, 0x6c, 0x70, 0x00,
	0x7a, 0x13, 0xf2, 0x16, 0xee, 0x11, 0xb7, 0xfa, 0x18, 0xbb, 0x5e, 0xb0, 0xf7, 0x28, 0x27, 0xc8,
	0x90, 0x87, 0x0c, 0xa7, 0xfe, 0x7d, 0x0a, 0xae, 0x4e, 0xf3, 0x2c, 0xd1, 0x7d, 0x00, 0xb2, 0x17,
	0xe6, 0xdc, 0xb0, 0xbb, 0x0c, 0x5f, 0xdd, 0x68, 0xc0, 0xfc, 0x17, 0x22, 0x64, 0xa8, 0x02, 0xf1,
	0xb1, 0x3b, 0xe0, 0xd3, 0xb0, 0x18, 0x74, 0x9a, 0x80, 0x5b, 0xd8, 0xa5, 0x71, 0x99, 0xa1, 0x6e,
	0xd0, 0x60, 0x4d, 0x4e, 0x23, 0x3f, 0xd1, 0x5d, 0xc8, 0xbe, 0xc0, 0xae, 0x8d, 0x2d, 0x26, 0xbb,
	0x92, 0x14, 0x03, 0x0c, 0x44, 0x45, 0xd7, 0x75, 0x48, 0xf5, 0x5c, 0x67, 0x34, 0xa4, 0x19, 0x36,
	0xca, 0x41, 0xac, 0x8d, 0x56, 0x60, 0xce, 0xf3, 0x5d, 0xd3, 0xc0, 0x34, 0x62, 0x93, 0xd3, 0x78,
	0x0b, 0x7d, 0x08, 0x39, 0x9e, 0xb7, 0xe2, 0x07, 0x3c, 0x7f, 0xee, 0x01, 0xf3, 0x24, 0x17, 0x03,
	0x13, 0xad, 0x44, 0xf7, 0xc0, 0xbb, 0xa6, 0xcf, 0xed, 0x4a, 0xf5, 0x25, 0xef, 0xb8, 0x02, 0xa9,
	0xa1, 0x6e, 0xb4, 0xfb, 0x34, 0x0f, 0x47, 0xa5, 0x6f, 0x72, 0xa8, 0x1b, 0x7b, 0x01, 0xfc, 0x84,
	0x06, 0x6a, 0x42, 0xf8, 0x73, 0x74, 0x17, 0xd2, 0x7c, 0xdf, 0x7d, 0x9a, 0x7f, 0x0b, 0xce, 0x73,
	0x9e, 0x41, 0xf7, 0x04, 0x82, 0x13, 0x9a, 0x7a, 0x1b, 0x23, 0xa0, 0x23, 0xb0, 0x1d, 0xb7, 0xfb,
	0x34, 0xed, 0x16, 0x12, 0x30, 0xe8, 0x9e, 0x40, 0x70, 0x42, 0xb3, 0x6e, 0x63, 0x04, 0xcf, 0xd1,
	0x36, 0xcc, 0x61, 0xbb, 0x67, 0xda, 0x98, 0xa6, 0xdb, 0xf2, 0x4f, 0xd5, 0x73, 0x82, 0x0b, 0x1b,
	0x65, 0x4a, 0xb9, 0x39, 0x5f, 0x2a, 0xef, 0x14, 0x0f, 0xaa, 0x2d, 0x8d, 0x77, 0x0d, 0xb9, 0x5f,
	0x91, 0xb9, 0xff, 0x2d, 0x58, 0x64, 0x7a, 0xc0, 0x36, 0xda, 0xe6, 0xe0, 0x69, 0xc7, 0xb1, 0x68,
	0xf2, 0x6d, 0x2c, 0x1b, 0x5d, 0x33, 0x2a, 0x14, 0x87, 0x6e, 0x42, 0xda, 0x30, 0x2d, 0x26, 0xac,
	0x11, 0xbd, 0xce, 0xb0, 0xad, 0xbe, 0x01, 0x73, 0x6c, 0x72, 0x94, 0x85, 0x60, 0x7a, 0x26, 0x70,
	0xb7, 0x8b, 0x3b, 0x3b, 0x65, 0x25, 0x46, 0x7f, 0x1e, 0x94, 0x6a, 0x35, 0x25, 0xae, 0x7e, 0x01,
	0x72, 0x92, 0x0d, 0x30, 0xfe, 0x3a, 0x9f, 0xf2, 0xf5, 0xad, 0xc0, 0x9c, 0xd3, 0xed, 0x7a, 0x3c,
	0x31, 0x9c, 0xd3, 0x78, 0x4b, 0xfd, 0x4e, 0x02, 0x72, 0x92, 0xb9, 0x8e, 0x6e, 0xc3, 0x9c, 0xe7,
	0x8c, 0xdc, 0x8e, 0x1c, 0x99, 0xe4, 0xb0, 0x48, 0x63, 0xc7, 0xc7, 0x34, 0xb6, 0xa4, 0x72, 0x13,
	0x53, 0x55, 0xee, 0x7d, 0x00, 0x66, 0xea, 0x71, 0xd6, 0x17, 0x5e, 0x15, 0x85, 0x53, 0xfe, 0x97,
	0x54, 0x7b, 0x6a, 0x52, 0xb5, 0x47, 0x96, 0xc1, 0xdc, 0x0c, 0xcb, 0xc0, 0xd5, 0x6d, 0xa3, 0xed,
	0xbd, 0x30, 0x87, 0xf4, 0x25, 0xb0, 0xee, 0x04, 0xd6, 0x7c, 0x61, 0x0e, 0xd1, 0x26, 0xcc, 0x1f,
	0xe9, 0x9d, 0x17, 0xd8, 0x36, 0x78, 0x15, 0xc5, 0xf5, 0x69, 0xe1, 0xa1, 0x8d, 0xd2, 0xd6, 0xe6,
	0x7c, 0xb5, 0x7c, 0x58, 0xae, 0x96, 0xb6, 0xb4, 0xa0, 0x03, 0x7a, 0x06, 0xcb, 0xec, 0x8e, 0x79,
	0x55, 0x09, 0xb7, 0x0d, 0x32, 0xe2, 0x3a, 0x96, 0x28, 0x45, 0x99, 0x11, 0x30, 0x13, 0xe1, 0x0e,
	0xa4, 0x87, 0x2e, 0xee, 0x62, 0xbf, 0xd3, 0x0f, 0x5e, 0xc5, 0x3b, 0x5a, 0x08, 0x52, 0x6f, 0x41,
	0xbc, 0xb4, 0x45, 0xae, 0x9a, 0xcf, 0xa7, 0x5c, 0x21, 0x0a, 0xb4, 0xba, 0x5f, 0xda, 0x52, 0x62,
	0xea, 0x47, 0xa0, 0x8c, 0xc7, 0x9f, 0xd0, 0x7a, 0x14, 0xaf, 0x72, 0x09, 0xc7, 0x70, 0x29, 0x98,
	0x78, 0xbc, 0xf1, 0x2c, 0x8c, 0x4d, 0x69, 0x04, 0xa1, 0xfe, 0x73, 0x0c, 0xd0, 0x64, 0xf4, 0x89,
	0x3c, 0x7a, 0xea, 0xc1, 0xf1, 0x47, 0xcf, 0xca, 0x82, 0x66, 0x3e, 0x7a, 0x42, 0xca, 0x1f, 0xbd,
	0xc2, 0xca, 0xac, 0x18, 0x07, 0xd1, 0x1a, 0xab, 0x9b, 0x42, 0xa5, 0x10, 0x93, 0x72, 0x51, 0x8d,
	0xd0, 0x4a, 0x58, 0x23, 0xc4, 0xa4, 0x5c, 0x50, 0x1d, 0x74, 0x35, 0xa8, 0x0e, 0x4a, 0x51, 0x30,
	0xaf, 0x0b, 0x0a, 0x4b, 0xa5, 0xe6, 0x66, 0x14, 0x53, 0x30, 0xb4, 0xfa, 0x4f, 0x31, 0x50, 0xc6,
	0xe3, 0x61, 0xa8, 0x04, 0x19, 0x67, 0x88, 0x5d, 0xf6, 0x9e, 0x62, 0x52, 0xf2, 0x71, 0x9c, 0x36,
	0x00, 0xd4, 0x87, 0x9b, 0x89, 0xe6, 0xc1, 0xbe, 0x16, 0x75, 0x24, 0x0b, 0xeb, 0x38, 0xb8, 0xdb,
	0xa5, 0x1b, 0x8c, 0x6b, 0xac, 0x41, 0xf4, 0xb0, 0xe7, 0xeb, 0x47, 0xc4, 0xe4, 0x77, 0x1d, 0x83,
	0x26, 0x00, 0x29, 0x7f, 0x07, 0xd2, 0x3e, 0xcf, 0xb0, 0x0d, 0xd7, 0x31, 0x76, 0x5d, 0xdd, 0x50,
	0x5f, 0x83, 0x4c, 0x38, 0x05, 0xb9, 0xc9, 0x86, 0x56, 0x2f, 0xb1, 0x9c, 0x57, 0xf3, 0x60, 0x5f,
	0x89, 0x91, 0x1f, 0xfb, 0xc5, 0x8f, 0x95, 0xb8, 0xfa, 0x1a, 0x2c, 0x88, 0xae, 0x09, 0x79, 0x5a,
	0xba, 0x35, 0xec, 0xeb, 0x82, 0x31, 0x4c, 0xdb, 0xea, 0x7f, 0xc6, 0x20, 0x2f, 0xfb, 0x5d, 0x17,
	0x56, 0x50, 0x51, 0xf5, 0x4c, 0x5c, 0xa0, 0x89, 0x6a, 0x68, 0x24, 0x1d, 0x96, 0x98, 0xaa, 0xc3,
	0x26, 0xf4, 0x4b, 0xf2, 0xe5, 0xf5, 0x4b, 0xea, 0xa2, 0xfa, 0x45, 0xfd, 0x18, 0x16, 0xc4, 0xd8,
	0x25, 0x5a, 0x81, 0xe4, 0x51, 0x90, 0xb8, 0x62, 0x59, 0x57, 0xda, 0x9e, 0x2d, 0x8f, 0x08, 0xa2,
	0x6f, 0x76, 0xfd, 0xa8, 0x50, 0x8b, 0xb5, 0xd5, 0x3d, 0x50, 0xc6, 0xdd, 0xe8, 0x59, 0x26, 0xcd,
	0x1d, 0x48, 0x63, 0xdb, 0x68, 0x0b, 0x46, 0x1b, 0x99, 0x78, 0x1e, 0xdb, 0x46, 0x91, 0x18, 0x6e,
	0x27, 0xb0, 0x34, 0x11, 0x27, 0xfd, 0x0c, 0xf1, 0x29, 0x8b, 0xc0, 0xf8, 0x74, 0x11, 0x78, 0x17,
	0xe6, 0xbd, 0xfe, 0xa8, 0xdb, 0xe5, 0x82, 0x34, 0xaa, 0x66, 0xe3, 0x50, 0xf5, 0x7d, 0x58, 0x9e,
	0x12, 0x5c, 0x25, 0x97, 0x49, 0xa4, 0x6f, 0x7b, 0x22, 0xad, 0x94, 0x26, 0xe0, 0x9a, 0x3e, 0xc0,
	0xaa, 0x01, 0x68, 0x32, 0x9e, 0x8a, 0xde, 0x85, 0x24, 0xad, 0x2b, 0x63, 0x2f, 0x67, 0x75, 0x66,
	0xe0, 0x95, 0xfa, 0x0e, 0x9b, 0xf1, 0xea, 0x13, 0x8d, 0xd2, 0xab, 0x2b, 0x90, 0xa4, 0xe5, 0x63,
	0x73, 0x10, 0xaf, 0x3e, 0x51, 0x62, 0xf4, 0xef, 0x53, 0x25, 0xae, 0x7e, 0x3b, 0x01, 0x68, 0x32,
	0xe2, 0xfa, 0x33, 0xd4, 0x2c, 0x6b, 0x93, 0x9a, 0x85, 0xda, 0xde, 0x3f, 0x37, 0xb5, 0x22, 0x5c,
	0x59, 0x7a, 0xda, 0x95, 0x91, 0x15, 0xda, 0xf8, 0xa4, 0xcd, 0x05, 0x62, 0x68, 0x34, 0x65, 0x6c,
	0x7c, 0xb2, 0xc7, 0xc4, 0xe2, 0x2a, 0x90, 0x46, 0x9b, 0x89, 0xc6, 0xd0, 0x7a, 0x4a, 0xdb, 0xf8,
	0xe4, 0x39, 0x15, 0x90, 0x77, 0x21, 0x6d, 0x7a, 0x5c, 0xe5, 0x64, 0x85, 0x97, 0x3a, 0x6f, 0x7a,
	0x4c, 0xcf, 0xdc, 0x83, 0xac, 0xeb, 0xd0, 0x9a, 0x02, 0xcb, 0xc0, 0x2e, 0x35, 0xa2, 0x32, 0x9b,
	0x57, 0x34, 0x20, 0xc0, 0x1d, 0x0a, 0x53, 0x9f, 0xc1, 0xb5, 0xa9, 0x11, 0xec, 0xf3, 0xaf, 0x46,
	0xfd, 0x56, 0x9c, 0xf4, 0x9b, 0x12, 0xab, 0x7e, 0x65, 0x86, 0xf2, 0x84, 0x90, 0x49, 0xbc, 0xbc,
	0x90, 0x49, 0x5e, 0xd8, 0x88, 0x0d, 0x9e, 0x7d, 0x4a, 0x7e, 0xf6, 0xf7, 0x69, 0xa5, 0x9d, 0xed,
	0x0d, 0x1d, 0x0f, 0xcb, 0xec, 0x10, 0xc1, 0xd5, 0xf7, 0x21, 0x2f, 0x07, 0x6d, 0x22, 0x0d, 0x16,
	0x3b, 0x5f, 0x83, 0x7d, 0x0c, 0x0b, 0x62, 0xf8, 0xef, 0x15, 0x8a, 0xb6, 0x1f, 0xc7, 0x61, 0x41,
	0xcc, 0x07, 0x10, 0xae, 0xb3, 0x9c, 0x8e, 0xce, 0x9d, 0x0d, 0xee, 0x93, 0x3e, 0xd3, 0x32, 0x14,
	0x18, 0xb8, 0x1b, 0x4c, 0xe9, 0xc4, 0x65, 0xa5, 0x43, 0x7c, 0xdf, 0x23, 0xec, 0xeb, 0x7c, 0x8e,
	0xe4, 0xe3, 0x8d, 0xf7, 0x9e, 0x69, 0x14, 0x82, 0x1a, 0x90, 0xa5, 0xb1, 0x3a, 0x17, 0xf7, 0x88,
	0xba, 0x4d, 0x4a, 0x42, 0x43, 0x9c, 0x9e, 0x8a, 0x0b, 0x8d, 0x52, 0x6d, 0x2e, 0x16, 0xb7, 0xb5,
	0x7a, 0xb3, 0xd9, 0xde, 0xde, 0x2b, 0xd6, 0x6a, 0xe5, 0x6a, 0x53, 0x03, 0x3b, 0x44, 0xa2, 0x45,
	0x88, 0xbd, 0x08, 0xaa, 0x64, 0x9f, 0x68, 0xb1, 0x17, 0xe8, 0xc3, 0xd0, 0x52, 0x9f, 0xa3, 0xa3,
	0xdf, 0x9c, 0x36, 0xfa, 0x0c, 0x0b, 0x5d, 0x7d, 0x06, 0x10, 0x4d, 0x8c, 0x96, 0x61, 0x7c, 0x6a,
	0xe5, 0x0a, 0x42, 0x90, 0x7f, 0x5e, 0x69, 0xed, 0x55, 0x6a, 0x01, 0x50, 0x89, 0x5d, 0xce, 0xec,
	0xfe, 0x76, 0x0c, 0x96, 0xa7, 0xe4, 0x4f, 0xc6, 0xe4, 0x7b, 0x6c, 0xba, 0x7c, 0x5f, 0x1b, 0x2b,
	0x4c, 0xcf, 0x9d, 0x53, 0x5e, 0x9d, 0x10, 0xf0, 0x13, 0xe5, 0xd5, 0xa2, 0x09, 0xcd, 0x40, 0xea,
	0xd7, 0x63, 0xb0, 0x20, 0x26, 0x66, 0xd0, 0xdb, 0x80, 0xc2, 0x40, 0x51, 0x3b, 0x28, 0x02, 0xe6,
	0x91, 0x10, 0xf6, 0x0a, 0x97, 0x42, 0x7c, 0x50, 0x13, 0x8c, 0x36, 0x60, 0x51, 0xef, 0xb8, 0x8e,
	0xe7, 0xb5, 0xa5, 0x85, 0x86, 0xef, 0x20, 0xcf, 0xb0, 0xdb, 0xc1, 0x7a, 0x27, 0x83, 0x07, 0x1f,
	0xb0, 0xe0, 0xc1, 0x47, 0x80, 0x26, 0xe3, 0x8c, 0xe2, 0x4b, 0x39, 0xaf, 0x2c, 0x5e, 0xfd, 0xeb,
	0x24, 0x28, 0xe3, 0xf9, 0x22, 0xf4, 0x21, 0x24, 0x87, 0x8e, 0x63, 0x71, 0x65, 0xa5, 0xce, 0x48,
	0x2b, 0x51, 0xc0, 0x3e, 0xf6, 0xfb, 0x8e, 0xb1, 0x49, 0xec, 0x2d, 0x8d, 0x76, 0x42, 0x0f, 0x65,
	0xf7, 0x5b, 0x3c, 0x7d, 0xd1, 0x09, 0xbf, 0x11, 0xfa, 0xda, 0x89, 0x40, 0x97, 0x04, 0xee, 0xf6,
	0x32, 0x73, 0xe9, 0x93, 0x81, 0x80, 0xe6, 0x5e, 0x7d, 0xe4, 0xdd, 0xa6, 0x3e, 0xcb, 0xbb, 0x9d,
	0xfb, 0x2c, 0xef, 0x76, 0xfe, 0xb3, 0xbc, 0xdb, 0xf4, 0x34, 0xef, 0xf6, 0xb2, 0x1e, 0xf9, 0x17,
	0xc3, 0x37, 0x96, 0x95, 0x5e, 0xf0, 0xc4, 0x49, 0xce, 0xf2, 0x84, 0xdf, 0x84, 0x3c, 0x0f, 0x4e,
	0xf1, 0x0c, 0x1e, 0x55, 0x39, 0x91, 0xc7, 0xcb, 0x90, 0x7c, 0x38, 0x75, 0x03, 0x20, 0xba, 0x92,
	0xc0, 0x08, 0xa6, 0x66, 0x71, 0xf1, 0xb0, 0xcc, 0x82, 0x88, 0xcd, 0x56, 0x7d, 0x7b, 0xaf, 0xd8,
	0x6c, 0x55, 0xb6, 0x95, 0xf8, 0xe5, 0x9e, 0xe3, 0x97, 0x21, 0x2f, 0xe7, 0x06, 0x89, 0x5c, 0x63,
	0xb5, 0xc0, 0x91, 0x31, 0xcd, 0x0a, 0x81, 0x2f, 0x2f, 0x55, 0xff, 0x22, 0x06, 0x8b, 0x63, 0x39,
	0x29, 0xf2, 0x40, 0x07, 0x8e, 0x31, 0xb2, 0xc6, 0xf4, 0x25, 0x83, 0xb1, 0x2f, 0x19, 0xce, 0xb0,
	0x2b, 0x55, 0xf0, 0x30, 0x10, 0xba, 0x03, 0x19, 0x1a, 0x49, 0x6f, 0x7b, 0x3e, 0xd3, 0x72, 0x44,
	0x47, 0xa7, 0x29, 0xa8, 0xe9, 0xbb, 0xe8, 0x09, 0x2c, 0xb1, 0xb2, 0x26, 0x93, 0x65, 0x70, 0x2c,
	0x0b, 0xb3, 0x72, 0xec, 0xa8, 0xae, 0x96, 0xe2, 0x2b, 0x74, 0x31, 0x04, 0xab, 0xfe, 0x4f, 0x0c,
	0xd0, 0x64, 0x1c, 0x9e, 0x5a, 0x1c, 0x63, 0xaa, 0x99, 0x59, 0x1c, 0xa1, 0x5e, 0x9e, 0x50, 0xba,
	0xf1, 0x97, 0x57, 0xba, 0x89, 0x0b, 0x2b, 0x5d, 0xb9, 0xd2, 0x36, 0x39, 0xa3, 0xd2, 0xf6, 0x75,
	0xc8, 0xe1, 0x53, 0xa2, 0x68, 0xdb, 0x7d, 0xd3, 0x30, 0xb0, 0x2d, 0xd7, 0xf6, 0x2f, 0x30, 0xdc,
	0x1e, 0x45, 0xa9, 0xff, 0x48, 0x0f, 0x60, 0x3c, 0xb1, 0x85, 0xf6, 0x26, 0x9d, 0xc2, 0x87, 0x33,
	0xd3, 0x60, 0x11, 0x68, 0x8a, 0x63, 0x38, 0x16, 0xb8, 0x7d, 0xcc, 0xed, 0x84, 0xeb, 0x81, 0xbf,
	0x18, 0x16, 0x8f, 0xb1, 0xb6, 0xfa, 0x0c, 0xb2, 0xc2, 0x70, 0x91, 0xeb, 0x97, 0x86, 0x64, 0x91,
	0xfc, 0x8a, 0x13, 0xde, 0x6d, 0x1e, 0xec, 0x37, 0x7f, 0x51, 0x49, 0x10, 0xe0, 0x7e, 0xb9, 0x58,
	0x53, 0x92, 0xea, 0x5f, 0xc5, 0x20, 0x27, 0x25, 0x30, 0xd1, 0x3a, 0xe4, 0x6d, 0xdc, 0xd3, 0x69,
	0xb5, 0x8d, 0x67, 0x39, 0xc3, 0x30, 0x51, 0xf2, 0x58, 0xcb, 0x05, 0x88, 0x26, 0x81, 0xa3, 0x8f,
	0xc2, 0xd7, 0xcc, 0x4a, 0xe1, 0x6e, 0x4d, 0xcb, 0x7d, 0xcf, 0x54, 0x99, 0x97, 0x7a, 0x6c, 0x43,
	0x50, 0xc6, 0x33, 0x9f, 0x17, 0x95, 0xe8, 0xb3, 0x4e, 0xf2, 0x8e, 0x10, 0x3b, 0x4e, 0x44, 0x8e,
	0x16, 0x0f, 0x1e, 0xab, 0xff, 0x12, 0x83, 0xbc, 0x9c, 0x5a, 0xfb, 0xb9, 0x04, 0xa1, 0x91, 0x2a,
	0x1a, 0xae, 0x12, 0xa7, 0x46, 0x96, 0xeb, 0x4b, 0x7b, 0xb8, 0x5f, 0x8d, 0x81, 0x32, 0x5e, 0x61,
	0x20, 0x08, 0x65, 0xd9, 0x17, 0x1b, 0x27, 0x7c, 0x35, 0x37, 0xd9, 0x87, 0xbc, 0x5c, 0x69, 0x40,
	0x9c, 0x10, 0x56, 0x95, 0x20, 0xe5, 0x30, 0xd2, 0x14, 0x56, 0x32, 0x07, 0xe8, 0x6e, 0x58, 0xb5,
	0xe0, 0x98, 0x76, 0x10, 0x4b, 0xe4, 0xe5, 0x09, 0x04, 0x12, 0xde, 0x4b, 0x42, 0xce, 0x71, 0xfc,
	0x39, 0xd9, 0xec, 0x58, 0x41, 0xc4, 0xec, 0xcd, 0x8e, 0x11, 0x7e, 0x66, 0x2c, 0x76, 0x2c, 0xa1,
	0x72, 0xa9, 0x33, 0xf8, 0x14, 0x72, 0x52, 0xd9, 0x84, 0xf0, 0x92, 0x62, 0xd2, 0x4b, 0x92, 0xa8,
	0x5e, 0xcd, 0xf9, 0x6f, 0x41, 0x4e, 0xca, 0x8b, 0xcf, 0xe2, 0xea, 0x9b, 0x90, 0xf2, 0x4d, 0x2b,
	0x60, 0xe9, 0x40, 0x9f, 0x50, 0x90, 0xfa, 0x0c, 0xd0, 0x64, 0xed, 0x06, 0xba, 0x0b, 0x99, 0xb0,
	0x7a, 0x23, 0x92, 0x19, 0x11, 0x4c, 0xfd, 0x41, 0x02, 0x96, 0xa7, 0x14, 0x6b, 0xfc, 0x1f, 0x8f,
	0xfe, 0x3e, 0x82, 0x85, 0x6e, 0xaf, 0x1d, 0xed, 0x7c, 0x3e, 0x8a, 0x8c, 0x66, 0xbb, 0xbd, 0xf0,
	0x9c, 0x08, 0xdd, 0x91, 0x48, 0x97, 0x16, 0xe8, 0x8e, 0x04, 0xba, 0x87, 0x90, 0xed, 0xf6, 0xa2,
	0x3c, 0x5a, 0x26, 0xf0, 0x85, 0x9e, 0x3e, 0xd3, 0xa0, 0xdb, 0x0b, 0x73, 0x67, 0x2a, 0x64, 0x3b,
	0x8e, 0xed, 0xe3, 0x53, 0xbf, 0x4d, 0x6c, 0xc3, 0xd0, 0xd0, 0x02, 0x0e, 0x6d, 0xe8, 0x06, 0x39,
	0x21, 0xba, 0x33, 0x5a, 0xae, 0x9c, 0xa5, 0x7a, 0x3f, 0x79, 0xa2, 0xbb, 0x43, 0xb6, 0x39, 0x9a,
	0x5c, 0x5d, 0x87, 0x85, 0x8e, 0xde, 0xe9, 0xe3, 0x36, 0xad, 0x4c, 0xf3, 0x64, 0x73, 0x2a, 0x4b,
	0x51, 0x34, 0xaa, 0xe2, 0x8d, 0xbb, 0xfa, 0xb9, 0x29, 0xae, 0xfe, 0x37, 0xe2, 0xb0, 0x20, 0xd6,
	0xb5, 0xa0, 0x37, 0x20, 0x3f, 0x3c, 0x73, 0xf5, 0x81, 0x69, 0x04, 0x51, 0x08, 0xd1, 0x3d, 0xc9,
	0x71, 0x1c, 0x0f, 0x46, 0xbc, 0xc7, 0x8d, 0xec, 0xb8, 0xfc, 0x30, 0x85, 0xf1, 0x66, 0x18, 0xd8,
	0xb3, 0x3c, 0x37, 0xa9, 0xeb, 0xac, 0xc7, 0xf3, 0x33, 0xb5, 0x11, 0xbf, 0x51, 0x00, 0x65, 0xfc,
	0xf3, 0x43, 0xf4, 0x56, 0x60, 0xa9, 0xc9, 0x75, 0x36, 0x87, 0x8f, 0xa7, 0x7e, 0x97, 0x27, 0xd4,
	0x5f, 0xc7, 0xa7, 0xd5, 0x5f, 0x27, 0xa2, 0xfa, 0xeb, 0xa0, 0xba, 0x3b, 0x39, 0x51, 0xdd, 0xfd,
	0x21, 0xaf, 0xee, 0x4e, 0x49, 0x61, 0xea, 0xf1, 0x95, 0xb1, 0x0f, 0x03, 0x5b, 0x67, 0x43, 0x2c,
	0x15, 0x80, 0x87, 0xd5, 0xd8, 0x73, 0xe7, 0x57, 0x63, 0xdf, 0x80, 0x34, 0xfd, 0xd1, 0xb6, 0x5c,
	0x5a, 0xb8, 0x1d, 0xd7, 0xe6, 0x69, 0xbb, 0xea, 0xa2, 0x7b, 0x63, 0xdf, 0xb9, 0xa5, 0x29, 0x5a,
	0xfa, 0xc2, 0x6d, 0xbc, 0x44, 0x38, 0x73, 0xf1, 0x12, 0xe1, 0xa9, 0xb5, 0xbc, 0xf0, 0xd3, 0xd7,
	0xf2, 0x66, 0x5f, 0xb2, 0x96, 0x77, 0xe1, 0x32, 0xb5, 0xbc, 0x53, 0xca, 0x62, 0x73, 0xaf, 0xa0,
	0x2c, 0x36, 0xff, 0x52, 0x65, 0xb1, 0x13, 0x15, 0xad, 0x8b, 0xaf, 0xa8, 0xa2, 0x55, 0x79, 0xa5,
	0x15, 0xad, 0x4b, 0xaf, 0xa0, 0xa2, 0x15, 0x5d, 0xa4, 0xa2, 0x75, 0xa2, 0xae, 0x74, 0xf9, 0x32,
	0x75, 0xa5, 0x3b, 0xd3, 0x8a, 0x17, 0xaf, 0x5e, 0xbe, 0x76, 0x71, 0xac, 0x3e, 0xf5, 0xda, 0x45,
	0xeb, 0x53, 0xa7, 0xd6, 0xe3, 0xae, 0x5c, 0xbe, 0x1e, 0x77, 0xbc, 0xf0, 0xff, 0xfa, 0xc5, 0x0b,
	0xff, 0x27, 0x8a, 0xcc, 0x0b, 0x97, 0x29, 0x32, 0xdf, 0x9a, 0x2c, 0x21, 0xbd, 0x71, 0xd9, 0x0a,
	0xd2, 0x69, 0xb5, 0xf2, 0x37, 0x2f, 0x5b, 0x2b, 0x3f, 0xf9, 0xed, 0xc4, 0xad, 0xcb, 0x7d, 0x3b,
	0x31, 0xad, 0xe4, 0xfc, 0xce, 0x65, 0x4b, 0xce, 0xe5, 0x7a, 0xe3, 0xd5, 0x8b, 0xd5, 0x1b, 0x8f,
	0xd5, 0xfc, 0xde, 0xbd, 0x68, 0xcd, 0xaf, 0xf0, 0x6d, 0xcd, 0xda, 0xe5, 0xbe, 0xad, 0xb9, 0x77,
	0x81, 0x6f, 0x6b, 0xa4, 0x12, 0x6f, 0xf5, 0x22, 0x25, 0xde, 0x63, 0x1f, 0x17, 0xdd, 0x9f, 0xf8,
	0xb8, 0x68, 0xca, 0xd7, 0x35, 0x0f, 0x5e, 0xf6, 0xeb, 0x1a, 0xa1, 0xda, 0xf9, 0xe1, 0xc5, 0xaa,
	0x9d, 0x27, 0xca, 0xba, 0x1f, 0xfd, 0x54, 0x65, 0xdd, 0xaf, 0x5d, 0xa6, 0xac, 0x7b, 0xf6, 0x27,
	0x32, 0xeb, 0x3f, 0xcd, 0x27, 0x32, 0xd2, 0x27, 0x1e, 0x9f, 0xbb, 0xc8, 0x27, 0x1e, 0xf2, 0x77,
	0x49, 0xaf, 0x5f, 0xec, 0xbb, 0xa4, 0x6b, 0xc1, 0x47, 0x61, 0x3f, 0x99, 0x67, 0x1f, 0xec, 0xb1,
	0x6f, 0xc0, 0xf6, 0x61, 0x91, 0x58, 0x0f, 0x6d, 0xe1, 0x83, 0xbb, 0xff, 0x20, 0x04, 0xf9, 0xa7,
	0x0f, 0x66, 0x99, 0x2f, 0xe2, 0x97, 0x71, 0x5a, 0xee, 0x88, 0xc5, 0x01, 0xd8, 0x67, 0x77, 0xea,
	0xf7, 0x93, 0x90, 0x09, 0xcd, 0x9b, 0xb0, 0x5a, 0xf0, 0x0a, 0x02, 0x98, 0x2b, 0x6e, 0x35, 0x0f,
	0x8b, 0x55, 0xe5, 0x3e, 0xfd, 0xb4, 0x73, 0x7b, 0xfb, 0x40, 0x2b, 0x6e, 0x7f, 0xa2, 0xc4, 0x28,
	0x46, 0xdb, 0x25, 0xd6, 0xe0, 0x2a, 0xa1, 0xdf, 0xaa, 0x55, 0xab, 0x4a, 0x9c, 0x40, 0xb7, 0xeb,
	0xb5, 0xed, 0x62, 0x4b, 0x49, 0xa0, 0xab, 0xa0, 0x6c, 0xd7, 0x6b, 0x2d, 0x8d, 0x98, 0x86, 0x87,
	0xe5, 0x76, 0xb5, 0xde, 0x6c, 0x2a, 0x0f, 0xd1, 0x22, 0x64, 0xb7, 0xeb, 0xb5, 0xc3, 0x7a, 0xf5,
	0xa0, 0x55, 0xa9, 0xd7, 0xd8, 0x37, 0xa2, 0xa5, 0x62, 0xab, 0xa8, 0xa4, 0xd0, 0x12, 0xe4, 0x4a,
	0x65, 0x11, 0xf9, 0x1a, 0x35, 0x22, 0xb5, 0x7a, 0xa3, 0x7e, 0xd0, 0x52, 0xe6, 0x88, 0xad, 0x59,
	0x3a, 0xd8, 0xdf, 0xff, 0xa4, 0x4d, 0xe9, 0xd7, 0x10, 0x82, 0x7c, 0xf9, 0x60, 0xbb, 0x5a, 0x29,
	0x95, 0x8b, 0x35, 0x36, 0xfc, 0x3c, 0xe9, 0x50, 0xae, 0xb6, 0x9e, 0x57, 0x9a, 0x65, 0xe5, 0x06,
	0xb1, 0x52, 0xcb, 0x1f, 0x37, 0x94, 0x47, 0xf4, 0x1f, 0x68, 0x54, 0x8b, 0xad, 0x56, 0xb9, 0xa6,
	0xa4, 0x51, 0x0e, 0x32, 0x44, 0xe1, 0xb3, 0x51, 0x32, 0x64, 0x41, 0xb4, 0x59, 0x3f, 0x68, 0x35,
	0x0e, 0x5a, 0x0a, 0x90, 0x69, 0xf6, 0x2a, 0xb5, 0x5d, 0xbe, 0xe2, 0xdb, 0x64, 0x4f, 0x95, 0xfd,
	0xa7, 0xdb, 0xf5, 0xaa, 0x92, 0x25, 0xb8, 0xca, 0x7e, 0x71, 0xb7, 0xcc, 0x3a, 0x2f, 0x90, 0x25,
	0x57, 0x6a, 0x3b, 0xf5, 0xdd, 0x62, 0x85, 0xaf, 0x20, 0xc7, 0x40, 0xb5, 0xb2, 0xd6, 0x6e, 0x68,
	0xf5, 0xd2, 0xc1, 0x76, 0x4b, 0xc9, 0x93, 0x75, 0x54, 0xb5, 0x9a, 0xb2, 0x48, 0xe6, 0xda, 0x2f,
	0xef, 0xd7, 0x35, 0xbe, 0x85, 0x3b, 0xe8, 0x0e, 0xdc, 0xd8, 0x3f, 0xa8, 0xb6, 0x2a, 0xb5, 0xfa,
	0x7e, 0xa5, 0x58, 0x6d, 0x57, 0xeb, 0xbb, 0x15, 0x62, 0x48, 0xb3, 0xb1, 0x14, 0x6a, 0x6f, 0x1f,
	0xd6, 0x14, 0x95, 0x6c, 0xa0, 0x51, 0xaf, 0x57, 0x2b, 0xb5, 0x5d, 0x65, 0x89, 0x58, 0xd0, 0x8d,
	0xfa, 0xf3, 0xb2, 0xa6, 0xdc, 0x24, 0x87, 0xa7, 0x95, 0xab, 0x07, 0x0a, 0x22, 0x14, 0xcd, 0xca,
	0xee, 0x7e, 0xbd, 0x52, 0x52, 0x96, 0xd1, 0x2a, 0xdc, 0xe4, 0x8d, 0x36, 0x4b, 0xb4, 0x94, 0x6b,
	0x2d, 0xad, 0xde, 0xf8, 0x84, 0x8d, 0x7b, 0x8b, 0x11, 0x57, 0xcb, 0xb5, 0xed, 0xb2, 0xf2, 0x80,
	0x36, 0xea, 0x3b, 0x2d, 0x72, 0x95, 0x57, 0x91, 0x02, 0x0b, 0xbc, 0xc1, 0x68, 0xaf, 0xd1, 0xb8,
	0x58, 0xa3, 0x5a, 0x69, 0x29, 0x2b, 0xf4, 0x67, 0xb5, 0xb2, 0x5d, 0x56, 0xee, 0x91, 0x89, 0x5b,
	0xc5, 0xda, 0x9e, 0x72, 0x9d, 0xec, 0xe9, 0x79, 0xa5, 0x56, 0xaa, 0x3f, 0x67, 0x7b, 0x2a, 0x90,
	0xf3, 0x6d, 0xed, 0x69, 0xe5, 0xe6, 0x5e, 0xbd, 0x5a, 0x52, 0xee, 0x5e, 0xea, 0x9b, 0xcc, 0xbf,
	0xc9, 0x82, 0x32, 0x6e, 0xe8, 0xbf, 0xd4, 0x57, 0x99, 0x72, 0x12, 0x34, 0x31, 0x3d, 0x09, 0xba,
	0x06, 0x34, 0x66, 0x24, 0x84, 0x92, 0x84, 0x1c, 0xa8, 0x3f, 0x35, 0x07, 0x9a, 0x7a, 0xf9, 0x70,
	0xec, 0xdc, 0x85, 0xc3, 0xb1, 0x3c, 0x9f, 0x31, 0x2f, 0xe5, 0x33, 0x1e, 0x00, 0xcf, 0x86, 0x50,
	0x3f, 0x3c, 0x3d, 0x99, 0x25, 0xf1, 0xa4, 0x52, 0xc5, 0xcc, 0x58, 0xa9, 0x62, 0x94, 0x3e, 0x81,
	0xf1, 0xf4, 0x49, 0x90, 0xbd, 0xc9, 0x4a, 0xd9, 0x9b, 0xf1, 0x6b, 0x98, 0xe1, 0x5c, 0x4e, 0x54,
	0x3e, 0x2d, 0xcc, 0xa8, 0x7c, 0x1a, 0x4b, 0x7c, 0xe6, 0xce, 0x4b, 0x7c, 0xe6, 0x67, 0x24, 0x3e,
	0x17, 0x27, 0x12, 0x9f, 0x51, 0x6c, 0x44, 0x39, 0x2f, 0x36, 0xb2, 0x34, 0x16, 0x1b, 0x59, 0x03,
	0x1a, 0x04, 0xa1, 0xa1, 0x11, 0x34, 0x1e, 0x1a, 0x21, 0x50, 0x1a, 0x67, 0xd4, 0xfd, 0x4e, 0x9f,
	0x2e, 0x76, 0x79, 0x22, 0x32, 0x12, 0xfc, 0x4f, 0x91, 0x8e, 0xeb, 0xb0, 0xff, 0x3a, 0x72, 0x55,
	0x0a, 0x8c, 0x78, 0x72, 0x60, 0xe4, 0xda, 0xb4, 0xc0, 0x08, 0xcd, 0xb0, 0xae, 0x08, 0x19, 0xd6,
	0xd0, 0x91, 0x7c, 0x7a, 0x71, 0x47, 0xf2, 0xed, 0xf3, 0x1d, 0xc9, 0x77, 0x26, 0x1d, 0x49, 0xa9,
	0x6c, 0xe2, 0xd9, 0x64, 0xd9, 0xc4, 0x5b, 0xa0, 0x18, 0xd8, 0x6f, 0x4b, 0x31, 0x9b, 0x77, 0xa3,
	0x3b, 0xcd, 0x1b, 0xd8, 0xdf, 0x11, 0xc2, 0x31, 0x9c, 0x5c, 0x0a, 0xdd, 0xbc, 0x27, 0x93, 0x6f,
	0x09, 0xe4, 0x6f, 0xc2, 0x22, 0x1f, 0x3d, 0x8c, 0xe0, 0xbc, 0x2f, 0x44, 0x70, 0x72, 0x74, 0xf4,
	0x30, 0x88, 0xf3, 0x39, 0x46, 0x2d, 0x06, 0x72, 0x36, 0x83, 0x15, 0x13, 0xd2, 0xed, 0x28, 0x96,
	0x43, 0xf8, 0x90, 0x90, 0x86, 0xf1, 0x9c, 0x0f, 0x85, 0x78, 0x4e, 0x96, 0xd0, 0x06, 0x21, 0x9d,
	0x9b, 0x30, 0x6f, 0xe3, 0x93, 0xb6, 0x3d, 0x1a, 0x14, 0x3e, 0x0a, 0xff, 0xcb, 0x98, 0x8d, 0x4f,
	0x6a, 0xa3, 0x01, 0x7a, 0x00, 0x0b, 0x04, 0x17, 0x66, 0x58, 0x3f, 0x1f, 0xfe, 0xa3, 0x00, 0x1b,
	0x9f, 0x84, 0xa9, 0x55, 0xb9, 0x70, 0xe4, 0x0b, 0x01, 0xcd, 0xac, 0xc2, 0x91, 0x2f, 0x86, 0xff,
	0xaa, 0x25, 0x2c, 0x1c, 0x79, 0x13, 0xf2, 0xbc, 0x0a, 0x25, 0x08, 0x2c, 0x7d, 0x49, 0xca, 0xd3,
	0x71, 0x24, 0x0f, 0x2d, 0xc9, 0x65, 0xec, 0xc5, 0x29, 0x65, 0xec, 0xbb, 0xd3, 0x7c, 0xdc, 0x9f,
	0xcc, 0x5f, 0xda, 0xc9, 0xbd, 0x74, 0xb8, 0xc7, 0x86, 0xbc, 0xfc, 0x81, 0x97, 0x10, 0xd0, 0x8f,
	0x5d, 0x28, 0xa0, 0xff, 0x26, 0xe4, 0xf9, 0x71, 0x33, 0x5b, 0xc6, 0x18, 0x2b, 0x0f, 0xe7, 0x48,
	0x6a, 0xaa, 0x18, 0xaf, 0xdf, 0x86, 0x14, 0xfd, 0xc0, 0x9c, 0xa8, 0xa2, 0x96, 0x56, 0xa4, 0xff,
	0x1d, 0x8b, 0xa8, 0xa2, 0x72, 0xb3, 0xa5, 0xc4, 0xb6, 0x0a, 0xdf, 0xfd, 0xe1, 0x6a, 0xec, 0x7b,
	0x3f, 0x5c, 0x8d, 0xfd, 0xfb, 0x0f, 0x57, 0x63, 0xdf, 0xfc, 0xd1, 0xea, 0x95, 0xef, 0xfd, 0x68,
	0xf5, 0xca, 0xf7, 0x7f, 0xb4, 0x7a, 0xe5, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x3b, 0x10, 0x5a,
	0x2b, 0xd3, 0x4e, 0x00, 0x00,
}
